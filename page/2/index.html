<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-树" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/树/" class="article-date">
  <time datetime="2019-03-13T03:01:28.687Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉树是一种特殊的树类型，其每个节点最多只能有两个子节点。这两个子节点分别称为当前节点的左孩子和右孩子。</p>
<p>完全二叉树：深度为h，有n个节点的二叉树，当且仅当其每一个节点都与深度为K的满二叉树中编号从1至n的节点一一对应时称之为完全二叉树。</p>
<p>一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</p>
<p>满二叉树：一颗深度为h，且有2的h次方减一个节点称之为满二叉树</p>
<p><img src="pictures/二叉树.png" alt="二叉树"></p>
<p>我们已经了解了数组是将元素连续地排列在内存当中，而二叉树却不是采用连续的内存存放。实际上，通常 BinaryTree 类的实例仅包含根节点（Root Node）实例的引用，而根节点实例又分别指向它的左右孩子节点实例，以此类推。</p>
<p>如果要访问二叉树中的某一个节点，通常需要逐个遍历二叉树中的节点，来定位那个节点。它不象数组那样能对指定的节点进行直接的访问。所以查找二叉树的渐进时间是线性的 O(n)，在最坏的情况下需要查找树中所有的节点。也就是说，随着二叉树节点数量增加时，查找任一节点的步骤数量也将相应地增加。</p>
<p><strong>二叉查找树</strong></p>
<p>二叉查找树（BST）是一种特殊的二叉树，它改善了二叉树节点查找的效率。二叉查找树有以下性质：</p>
<p>其左子树下的每个后代节点的值都小于节点n的值</p>
<p>其右子树下的每个厚道节点的值都大于节点n的值</p>
<p>二叉查找树查找算法的时间复杂度应该是 O(log­2n)，简写为 O(lg n)，如果节点数量增加 n，查找时间只缓慢地增加到 log­2n</p>
<p><strong>插入节点：</strong></p>
<p>BST 的插入算法的复杂度与查找算法的复杂度是一样的：最佳情况是 O(log­2n)，而最坏情况是 O(n)。因为它们对节点的查找定位策略是相同的。</p>
<p><strong>删除节点：</strong></p>
<p>删除节点算法的第一步是定位要被删除的节点，这可以使用前面介绍的查找算法，因此运行时间为 O(log­2n)。接着应该选择合适的节点来代替删除节点的位置，它共有三种情况需要考虑:</p>
<ol>
<li>如果删除的节点没有右孩子，那么就选择它的左孩子来代替原来的节点。二叉查找树的性质保证了被删除节点的左子树必然符合二叉查找树的性质。因此左子树的值要么都大于，要么都小于被删除节点的父节点的值，这取决于被删除节点是左孩子还是右孩子。因此用被删除节点的左子树来替代被删除节点，是完全符合二叉搜索树的性质的。</li>
<li>如果被删除节点的右孩子没有左孩子，那么这个右孩子被用来替换被删除节点。因为被删除节点的右孩子都大于被删除节点左子树的所有节点，同时也大于或小于被删除节点的父节点，这同样取决于被删除节点是左孩子还是右孩子。因此，用右孩子来替换被删除节点，符合二叉查找树的性质。</li>
<li>如果被删除节点的右孩子有左孩子，就需要用被删除节点右孩子的左子树中的最下面的节点来替换它，就是说，我们用被删除节点的右子树中最小值的节点来替换。</li>
</ol>
<p><img src="pictures/二叉樹刪除.png" alt="二叉树-删除"></p>
<p>我们知道，在 BST 中，最小值的节点总是在最左边，最大值的节点总是在最右边。因此替换被删除节点右子树中最小的一个节点，就保证了该节点一定大于被删除节点左子树的所有节点。同时，也保证它替代了被删除节点的位置后，它的右子树的所有节点值都大于它。因此这种选择策略符合二叉查找树的性质。</p>
<p><strong>和查找、插入算法类似，删除算法的运行时间也与 BST 的拓扑结构有关，最佳情况是 O(log­2n)，而最坏情况是 O(n)。</strong></p>
<p><strong>遍历节点：</strong></p>
<ol>
<li>前序遍历（中左右）</li>
</ol>
<p>可以通过递归和非递归两种方式实现：</p>
<p><strong>递归：</strong></p>
<figure class="highlight plain"><figcaption><span>inorder(btree ptr)//中序（输出根节点次序）遍历（递归实现）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if (ptr != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(ptr-&gt;left);</span><br><span class="line">        cout &lt;&lt; ptr-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">        inorder(ptr-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归（使用栈）</strong></p>
<p>//非递归中序遍历（左节点-&gt;根节点-&gt;右节点）思想：即用栈实现<br>因为中序遍历二叉树的特点，所以在当前节点cur不为空或栈不为空的条件下（在该条件下的原因：该条件说明  未遍历完二叉树），开始执行循环体，进行遍历：<br>1.从当前节点cur开始，以cur为循环条件，当cur不为空时，将cur入栈，然后以cur=cur-&gt;_left跟进，直至 将该二叉树的最左节点入栈后，入栈操作结束  </p>
<p>2.取栈顶节点：先保存该节点（用top保存该节点的原因：还要考虑该节点的右孩子）并输出该节点的值，然后执行栈的pop操作。</p>
<p>3.继续以top-&gt;_right为cur值，转（1）操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void inorder2(btree ptr)//中序遍历的非递归实现</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;btree&gt; st;</span><br><span class="line">    while (ptr != nullptr || !st.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        while (ptr != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(ptr);</span><br><span class="line">            ptr = ptr -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        btree tp = st.top();</span><br><span class="line">        cout &lt;&lt; tp -&gt; data &lt;&lt; &quot; &quot;;</span><br><span class="line">        st.pop();</span><br><span class="line">        ptr = tp -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>中序遍历（左中右）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void preorder2(btree ptr)//前序遍历的非递归实现</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;btree&gt; st;</span><br><span class="line">    if (ptr != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        st.push(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    while (!st.empty())</span><br><span class="line">    &#123;       </span><br><span class="line">        btree tp = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        cout &lt;&lt; tp -&gt; data &lt;&lt; &quot; &quot;;</span><br><span class="line">        if (tp-&gt;right != nullptr)</span><br><span class="line">            st.push(tp-&gt;right);</span><br><span class="line">        if (tp-&gt;left != nullptr)</span><br><span class="line">            st.push(tp-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后续遍历（左右中）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//非递归后序遍历（左节点-&gt;右节点-&gt;根节点）思想：即用栈实现  </span><br><span class="line">//（1）在当前节点cur不为空或栈不为空的条件下（在该条件下的原因：该条件说明未遍历完二叉树）。  </span><br><span class="line">//（2）从当前节点cur开始，以cur为循环条件，当cur不为空时，将cur入栈，然后以cur=cur-&gt;_left跟进，直至  </span><br><span class="line">//     将该二叉树的最左节点入栈后，入栈操作结束。取栈顶节点top：先保存该节点（用top保存该节点的原因：  </span><br><span class="line">//     还要考虑该节点的右孩子），  </span><br><span class="line">//（3）若top-&gt;_right==NULL || lastVisited == top-&gt;_right,则输出top-&gt;_value,执行栈的pop操作,并执行lastVisited = top(  </span><br><span class="line">//    用lastVisited保存最近一个所输出的节点，待到下一次同样的操作时，若lastVisited == top-&gt;_right，则  </span><br><span class="line">//    说明top的右节点已经访问过了，可以访问top了，否则会陷在cur = top-&gt;_right这步操作里）;  </span><br><span class="line">//（4）若条件（3）不满足，则继续以top-&gt;_right为cur值，转（1）操作.  </span><br><span class="line">void postorder2(btree ptr)//后序遍历的非递归实现</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;btree&gt; st;</span><br><span class="line">    btree lastVisited  = nullptr;</span><br><span class="line">    while (ptr != nullptr || !st.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        while (ptr != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(ptr);</span><br><span class="line">            ptr = ptr -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        btree tp = st.top();</span><br><span class="line">        if (tp-&gt;right == nullptr || lastVisited == tp-&gt;right)</span><br><span class="line">        &#123;   </span><br><span class="line">            st.pop();</span><br><span class="line">            cout &lt;&lt; tp -&gt; data &lt;&lt; &quot; &quot;;</span><br><span class="line">            lastVisited = tp;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            ptr = tp-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p>
<p><strong>平衡二叉树不平衡的情形：</strong></p>
<p>把需要重新平衡的结点叫做α，由于任意两个结点最多只有两个儿子，因此高度不平衡时，α结点的两颗子树的高度相差2.容易看出，这种不平衡可能出现在下面4中情况中：</p>
<ol>
<li>对α的左儿子的左子树进行一次插入</li>
<li>对α的左儿子的右子树进行一次插入</li>
<li>对α的右儿子的左子树进行一次插入</li>
<li>对α的右儿子的右子树进行一次插入</li>
</ol>
<p><img src="pictures/二叉树不平衡的情况.png" alt="二叉树不平衡"></p>
<p><strong>总共分为4中情况：第一种情况是插入发生在“外边”的情形（左左或右右），该情况可以通过一次单旋转完成调整；第二种情况是插入发生在”n内边”情形（左右或右左），这种情况比较复杂，需要通过双旋转来调整</strong></p>
<p><img src="pictures/单旋转.png" alt="单旋转"><br><img src="pictures/双旋转.png" alt="双旋转"></p>
<p><strong>AVL树的删除操作：</strong></p>
<p>同插入操作一样，删除结点时也有可能破坏平衡性，这就要求我们删除的时候要进行平衡性调整。</p>
<p>删除分为以下几种情况：</p>
<p>首先在整个二叉树中搜索要删除的结点，如果没搜索到直接返回不作处理，否则执行以下操作：</p>
<p>1.要删除的节点是当前根节点T。</p>
<p>如果左右子树都非空。在高度较大的子树中实施删除操作。</p>
<p>分两种情况：</p>
<p>(1)、左子树高度大于右子树高度，将左子树中最大的那个元素赋给当前根节点，然后删除左子树中元素值最大的那个节点。</p>
<p>(2)、左子树高度小于右子树高度，将右子树中最小的那个元素赋给当前根节点，然后删除右子树中元素值最小的那个节点。</p>
<p>如果左右子树中有一个为空，那么直接用那个非空子树或者是NULL替换当前根节点即可。</p>
<p>2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。</p>
<p>递归调用，在左子树中实施删除。</p>
<p>这个是需要判断当前根节点是否仍然满足平衡条件，</p>
<p>如果满足平衡条件，只需要更新当前根节点T的高度信息。</p>
<p>否则，需要进行旋转调整：</p>
<p>如果T的左子节点的左子树的高度大于T的左子节点的右子树的高度，进行相应的单旋转。否则进行双旋转。</p>
<p>3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除</p>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。</p>
<p>但是咱们有面对这样一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</p>
<p>也就是说，因为磁盘的操作费时费资源，如果过于频繁的多次查找势必效率低下。那么如何提高效率，即如何避免磁盘过于频繁的多次查找呢？根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度</p>
<p><strong>外存储器-磁盘</strong></p>
<p>计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。 内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。</p>
<p>外存储器—磁盘是一种直接存取的存储设备(DASD)。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。</p>
<p><strong>磁盘构造</strong></p>
<p>磁盘是一个扁平的圆盘(与电唱机的唱片类似)。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图所示的6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。</p>
<p><img src="pictures/磁盘示意图.png" alt="磁盘示意图"></p>
<p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头(又叫磁头) 下通过时，就可以进行数据的读 / 写了。</p>
<p>一般磁盘分为固定头盘(磁头固定)和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p>
<p>活动头盘 (如上图)的磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的(行动整齐划一)。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p>
<p><strong>磁盘的读/写原理和效率</strong></p>
<p>磁盘上数据必须用一个三维地址唯一表示：柱面号，盘面号，块号（刺刀上的盘块）</p>
<p>读/写磁盘上某一指定数据需要下面3个步骤：</p>
<p>(1)  首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找 。</p>
<p>(2)  如上图所示的6盘组示意图中，所有磁头都定位到了10个盘面的10条磁道上(磁头都是双向的)。这时根据盘面号来确定指定盘面上的磁道。</p>
<p>(3) 盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</p>
<p>经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。</p>
<p>访问某一具体信息，由3部分时间组成：</p>
<p>● 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。</p>
<p>● 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。</p>
<p>● 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2*10^(-8)s</p>
<p><strong>磁盘读取数据是以盘块（block）为基本单位的：</strong>位于同一盘块中的左右数据都能被一次性全部读取出来。而磁盘IO代价花费主要在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。。或则放在同一柱面或则相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</p>
<p>所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。</p>
<p>B树是为了磁盘或其他存储设备而设计的一种多叉平衡查找树，与红黑树很相似，但是在降低磁盘I/O操作方面要更好一些。许多数据库系统都一般使用B树或者B树的各种变形结构</p>
<p>B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p>
<p>如下图所示，即是一棵B树，一棵关键字为英语中辅音字母的B树，现在要从树种查找字母R（包含n[x]个关键字的内结点x，x有n[x]+1]个子女（也就是说，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女）。所有的叶结点都处于相同的深度，带阴影的结点为查找字母R时要检查的结点）：</p>
<p><img src="pictures/B树.png" alt="B树"></p>
<p><strong>相信，从上图你能轻易的看到，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女。如含有2个关键字D H的内结点有3个子女，而含有3个关键字Q T X的内结点有4个子女。</strong></p>
<p><img src="pictures/B阶树的特点.png" alt="M阶B树"></p>
<p><strong>B树的类型和节点定义</strong></p>
<p><img src="pictures/B树的类定义.png" alt="B树的定义"><br><img src="pictures/B树示意图.png" alt="B树示意图"><br>为了简单，这里用少量数据构造一棵3叉树的形式，实际应用中的B树结点中关键字很多的。上面的图中比如根结点，其中17表示一个磁盘文件的文件名；小红方块表示这个17文件内容在硬盘中的存储位置；p1表示指向17左子树的指针。</p>
<p>下面，咱们来模拟下查找文件29的过程：</p>
<p>1.根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】<br>此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17&lt;29&lt;35，因此我们找到指针p2。</p>
<p>2.根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】<br>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26&lt;29&lt;30，因此我们找到指针p2。</p>
<p>3.根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】<br>此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。</p>
<p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。</p>
<p>当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘4次，最多5次，而且文件越多，B树比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。</p>
<p><strong>B树的高度</strong></p>
<p>对于辅存做IO读的次数取决于B树的高度</p>
<p><img src="pictures/B树的高度.png" alt="B树的高度"></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+-tree：是应文件系统所需而产生的一种B-tree的变形树。</p>
<p>一棵m阶的B+树和m阶的B树的异同点在于:</p>
<p>1.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p>
<p>2.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
<p><img src="pictures/B+树示意图.png" alt="B+树"></p>
<p><strong>为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ol>
<li>B+-tree的磁盘读写代价更低</li>
</ol>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<ol start="2">
<li>B+-tree的查询效率更加稳定</li>
</ol>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。B+树相对于B树，范围查找的效率提高了。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B<em>-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B</em>树中非根和非叶子结点再增加指向兄弟的指针；B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）。给出了一个简单实例，如下图所示：<br><img src="pictures/B+树的升级.png" alt="B*树"></p>
<p><strong>B+树的分裂：</strong><br>当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</p>
<h6 id="B-树的分裂"><a href="#B-树的分裂" class="headerlink" title="B*树的分裂:"></a>B*树的分裂:</h6><p>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p>
<h4 id="所以，B-树分配新结点的概率比B-树要低，空间使用率更高。"><a href="#所以，B-树分配新结点的概率比B-树要低，空间使用率更高。" class="headerlink" title="所以，B*树分配新结点的概率比B+树要低，空间使用率更高。"></a>所以，B*树分配新结点的概率比B+树要低，空间使用率更高。</h4><h2 id="B树的插入操作"><a href="#B树的插入操作" class="headerlink" title="B树的插入操作"></a>B树的插入操作</h2><p>插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p>
<p><img src="pictures/B树插入.png" alt="B树插入思路"></p>
<h2 id="B树的删除操作"><a href="#B树的删除操作" class="headerlink" title="B树的删除操作"></a>B树的删除操作</h2><p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（还记得第一节中关于B树的第5个特性中的c点么?： c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）&lt;= n &lt;= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2&lt;=n&lt;=4），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/树/" data-id="cjuajt8l2000ffcamcn7q2nl1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/mysql/" class="article-date">
  <time datetime="2019-03-12T07:55:44.522Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MYSQL常见面试题-索引原理分析"><a href="#MYSQL常见面试题-索引原理分析" class="headerlink" title="MYSQL常见面试题+索引原理分析"></a>MYSQL常见面试题+索引原理分析</h1><p><strong>数据库中最常见的慢查询优化方式：</strong></p>
<p>加索引，因为索引其实就是一种优化查询的数据结构，比如mysql中的索引时用B+树实现的，而B+树就是一种数据结构，可以可以优化查询速度，可以利用索引快速查找数据，所以能优化查询</p>
<p><strong>那些数据结构可以优化查询速度</strong></p>
<p>哈希表，完全平衡二叉树，B树，B+树等等。</p>
<h2 id="为什么哈希表，完全平衡二叉树，B树，B-树都可以优化查询，为何mysql独独喜欢B-树"><a href="#为什么哈希表，完全平衡二叉树，B树，B-树都可以优化查询，为何mysql独独喜欢B-树" class="headerlink" title="为什么哈希表，完全平衡二叉树，B树，B+树都可以优化查询，为何mysql独独喜欢B+树"></a>为什么哈希表，完全平衡二叉树，B树，B+树都可以优化查询，为何mysql独独喜欢B+树</h2><p><strong>哈希表有什么特点</strong></p>
<p>假如有这么一张表：</p>
<p><img src="pictures/mysql样表.png" alt="mysql样表"></p>
<p>现在对name字段建立哈希索引：</p>
<p><img src="pictures/mysql样表2.png" alt="mysql样表2"></p>
<p>字段值所对应的数组下标是哈希算法随机算出来的，所以可能出现哈希冲突。name对于这样一个索引结构，现在SQL语句</p>
<p>select * from sanguo where name=’周瑜’</p>
<p>可以直接对‘周瑜’按哈希算法算出一个数组下标，然后可以直接从数据中取出数据并拿到所对应那一行数据的地址，进而查询那一行数据。若是以下SQL语句：</p>
<p>select * from sanguo where name&gt;’周瑜’</p>
<p>则无能为力，因为哈希表的特点就是   可以快速的精确查找，但是不支持范围查询。</p>
<p><strong>如果用完全平衡二叉树呢</strong></p>
<p>还是上面的数据用完全平衡二叉树表示如下图：</p>
<p><img src="pictures/mysql样表3.png" alt="mysql样表3"></p>
<p>图中的每一个节点实际应该有四部分：</p>
<p> 1.左指针，指向左子树</p>
<p> 2.键值</p>
<p> 3.键值所对应的数据的存储地址</p>
<p> 4.右指针，指向右子树</p>
<p> 另外需要提醒的是，二叉树是有顺序的，简单的说就是“左边的小于右边的”假如我们现在来查找‘周瑜’，需要找2次（第一次曹操，第二次周瑜），比哈希表要多一次。而且由于完全平衡二叉树是有序的，所以也是支持范围查找的。</p>
<p> <strong>如果用B树呢</strong></p>
<p> 还是上面数据用B树表示如下图：</p>
<p><img src="pictures/mysql样表4.png" alt=" mysql样表4"></p>
<p>可以发现同样的元素，B树的表示要比完全平衡二叉树“矮”，原因在于B树中的一个节点可以存储多个元素。</p>
<p><strong>如果用B+树呢</strong></p>
<p><img src="pictures/mysql样表5.png" alt="mysql样表5"></p>
<p>我们可以发现同样的元素，B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。</p>
<p><strong>那么B+树到底有什么优势呢</strong></p>
<p>这里我们用“反证法”，假如我们现在就用完全平衡二叉树作为索引的数据结构，我们来看一下有什么不妥的地方。实际上，索引也是很“大”的，因为索引也是存储元素的，我们的一个表的数据行数越多，那么对应的索引文件其实也是会很大的，实际上也是需要存储在磁盘中的，而不能全部都放在内存中，所以我们在考虑选用哪种数据结构时，我们可以换一个角度思考，哪个数据结构更适合从磁盘中读取数据，或者哪个数据结构能够提高磁盘的IO效率。回头看一下完全平衡二叉树，当我们需要查询“张飞”时，需要以下步骤：</p>
<ol>
<li>从磁盘中取出“曹操”到内存，CPU从内存取出数据进行比较，“张飞”&lt;“曹操”，取左子树（产生了一次磁盘IO）</li>
<li>从磁盘中取出“周瑜”到内存，CPU从内存取出数据进行比较，“张飞”&gt;“周瑜”，取右子树（产生了一次磁盘IO）</li>
<li>从磁盘中取出“孙权”到内存，CPU从内存取出数据进行比较，“张飞”&gt;“孙权”，取右子树（产生了一次磁盘IO）</li>
<li>从磁盘中取出“张飞”到内存，CPU从内存取出数据进行比较，“张飞”=“张飞”，找到结果（产生了一次磁盘IO）</li>
</ol>
<p>同理，看一下B树，我们发现只发送三次磁盘IO就可以找到“张飞”，这就是B树的优点：一个节点可以存储多个元素，相对于完全平衡二叉树所以整颗树的而高度就降低；额，磁盘IO效率提高了。</p>
<p>而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是为了提高范围查找的效率。</p>
<p><strong>总结</strong></p>
<p>到这里可以总结出来，Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。</p>
<p><strong>一个B+树的节点中到底存多少个元素合适呢？</strong></p>
<p>B+树中一个节点为一页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费；如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费；所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。</p>
<p><strong>MYSQL中B+树的一个节点大小为多大呢</strong></p>
<p>这个问题的答案是“1页”，这里说的“页”是Mysql自定义的单位（其实和操作系统类似），Mysql的Innodb引擎中一页的默认大小是16k（如果操作系统中一页大小是4k，那么Mysql中1页=操作系统中4页），可以使用命令SHOW GLOBAL STATUS like ‘Innodbpagesize’; 查看。</p>
<p>并且还可以告诉你的是，一个节点为1页就够了。</p>
<p><strong>Mysql中MyISAM和innodb使用B+树</strong></p>
<p><img src="pictures/mysql样表6.png" alt="mysql样表6"></p>
<p>通常我们认为B+树的非叶子节点不存储数据，只有叶子节点才存储数据；而B树的非叶子和叶子节点都会存储数据，会导致非叶子节点存储的索引值会更少，树的高度相对会比B+树高，平均的I/O效率会比较低，所以使用B+树作为索引的数据结构，再加上B+树的叶子节点之间会有指针相连，也方便进行范围查找。上图的data区域两个存储引擎会有不同。</p>
<p><strong>MyISAM中的B+树</strong></p>
<p>MYISAM中叶子节点的数据区域存储的是数据记录的地址</p>
<p><img src="pictures/mysql样表7.png" alt="mysql样表7"><br><img src="pictures/mysql样表8.png" alt="mysql样表8"></p>
<p>MyISAM存储引擎在使用索引查询数据时，会先根据索引查找到数据地址，再根据地址查询到具体的数据。并且主键索引和辅助索引没有太多区别。</p>
<p><strong>InnoDB中的B+树</strong></p>
<p><img src="pictures/mysql样例9.png" alt="mysql样例9"><br><img src="pictures/mysql样例10.png" alt="mysql样例10"></p>
<p>Innodb中的主键索引和实际数据时绑定在一起的，也就是说Innodb的一个表一定要有主键索引，如果一个表没有手动建立主键索引，Innodb会查看有没有唯一索引，如果有则选用唯一索引作为主键索引，如果连唯一索引也没有，则会默认建立一个隐藏的主键索引（用户不可见）。另外，Innodb的主键索引要比MyISAM的主键索引查询效率要高（少一次磁盘IO），并且比辅助索引也要高很多。所以，我们在使用Innodb作为存储引擎时，我们最好：</p>
<p>1.手动建立主键索引</p>
<p>2.尽量利用主键索引查询</p>
<p><strong>为什么一个节点为1页（16k）就够了？</strong></p>
<p>对着上面Mysql中Innodb中对B+树的实际应用（主要看主键索引），可以发现B+树中的一个节点存储的内容是：</p>
<p>1.非叶子节点：主键+指针</p>
<p>2.叶子节点：数据</p>
<p>那么，假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)，那么一颗高度为2的B+树能存储的数据为：1170<em>16=18720条，一颗高度为3的B+树能存储的数据为：1170</em>1170*16=21902400（千万级条）。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。所以也就回答了我们的问题，1页=16k这么设置是比较合适的，是适用大多数的企业的，当然这个值是可以修改的，所以也能根据业务的时间情况进行调整。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/12/mysql/" data-id="cjuajt8430009fcamyygn9yuu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-腾讯面试" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/腾讯面试/" class="article-date">
  <time datetime="2019-03-11T14:04:24.210Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="腾讯面试面经"><a href="#腾讯面试面经" class="headerlink" title="腾讯面试面经"></a>腾讯面试面经</h1><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元</li>
<li>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器，堆栈，上下文），一个进程至少包括一个线程</li>
<li>进程的创建调用fork或则vfork，而线程的创建调用pthread_create,进程结束后他所拥有的所有线程都将销毁，而线程结束不会影响同个进程能其他线程的结束</li>
<li>线程是轻量级的进程，它的创建和销毁所需要的时间比进程小的多，所有操作系统中的执行功能都是创建线程去完成的</li>
<li>线程中执行时一般要进行同步和互斥，因为他们共享同一进程的所有资源</li>
<li>线程有自己的私有属性TCB，线程id，寄存器，硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</li>
</ol>
<h3 id="fork-函数详解"><a href="#fork-函数详解" class="headerlink" title="fork()函数详解"></a>fork()函数详解</h3><p>一个进程，包括代码，数据和分配给进程的资源。fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程进程可以做完全相同的事，但是如果初始参数或传入的变量不同，两个进程也可以做不同的时。</p>
<p>一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来的进程的值不同。相当于克隆一个自己。</p>
<p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中<br>fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。<br>  每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h3><p>vfork()会产生一个新的子进程，但是vfork创建的子进程与父进程共享数据段，而且由vfork()创建的子进程将优先于父进程运行</p>
<p><strong>vfork()与fork()的相似和区别</strong><br>1.fork():子进程拷贝父进程的数据段，代码段  vfork():但是vfork创建的子进程与父进程共享数据段</p>
<p>2.fork():父子进程的执行次序不确定</p>
<pre><code>vfork():保证子进程先运行，在她调用exec或_exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。调用exec或_exit之前与父进程数据是共享的。
</code></pre><p>3.当需要改变共享数据段中的变量的值，则拷贝父进程。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>可以将资源有选择的复制给子进程，没有复制的数据结构通过指针的复制共享。一般用来创建线程</p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时间结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或则waitpid()系统地哦啊用取得子进程的终止状态</p>
<p><strong>孤儿进程：</strong></p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并有init进程对他们完成转态收集工作。</p>
<p><strong>僵尸进程：</strong></p>
<p>一个进程使用fork()创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，name子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程</p>
<p><strong>危害：</strong></p>
<p>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<p>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
<h3 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h3><p><img src="pictures/多线程与多进程.png" alt="多线程与多进程"></p>
<p><strong>1.需要频繁创建销毁的优先用线程</strong></p>
<p>这种原则最常见的应用就是web服务器，来一个连接建立一线程，断了就销毁线程，要是用进程，创建和销毁的代价很大。</p>
<p><strong>2.需要进程大量运算的优先使用线程</strong></p>
<p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p>
<p><strong>3.强相关处理用线程，若相关处理用进程</strong></p>
<p>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。</p>
<p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>
<p><strong>4.可能要扩展到多机分布的用进程，多核分布的用线程</strong></p>
<p><strong>消耗资源</strong></p>
<p>从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
<p>线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。</p>
<p><strong>通讯方式</strong></p>
<p>进程之间传递数据只能是通过通讯的方式，即费时又不方便。线程时间数据大部分共享（线程函数内部不共享），快捷方便。但是数据同步需要锁对于static变量尤其注意</p>
<p><strong>线程的优势</strong></p>
<p>提高应用程序响应；使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；<br>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。</p>
<h3 id="OSI七层与TCP-IP五层网络架构详解"><a href="#OSI七层与TCP-IP五层网络架构详解" class="headerlink" title="OSI七层与TCP/IP五层网络架构详解"></a>OSI七层与TCP/IP五层网络架构详解</h3><p><img src="pictures/OSI七层.png" alt="OSI七层"></p>
<p><strong>TCP/IP五层模型的协议</strong></p>
<p><img src="pictures/TCP—IP五层协议.png" alt="TCP/IP"></p>
<p><strong>TCP/UDP协议</strong></p>
<p>TCP和UDP协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送，可靠性，有效流控，全双工操作和多路复用。。通过面向连接，端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性，流量或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低，传输经济的应用。TCP支持的应用协议主要有：Telnet，FTP，SMTP等，UDP支持的应用层协议主要有：NFS(网络文件系统)，SNMP简单网络管理协议，DNS（主域名系统），TFTP(通用文件传输协议)等</p>
<p>TCP/IP洗衣与底层的数据链路层和物理层无关。</p>
<p><strong>OSI七层参考模型的各个层次的划分遵循下列原则</strong></p>
<p>1.同一层中的个网络节点都有相同的层次结构，具有同样的功能</p>
<p>2.同一节点内相邻网络之间通过接口（可以是逻辑接口）进行通信</p>
<p>3.七层结构中每一层使用下一层提供的服务，并且向上层提供服务</p>
<p>4.不同节点的同一层按照协议实现对等层之间的通信</p>
<p><strong>第一层：物理层</strong></p>
<p>规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。在这一层，数据的单位称为比特（bit）。</p>
<p><strong>第二层：数据链路层</strong></p>
<p>在物理层提供比特流服务的基础上，建立相邻接点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输，并进行个电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输，该层的作用：物理地址寻址，数据的成帧，流量控制，数据的检错，重发等。在这一层，数据的单位称为帧。数据链路层协议的代表包括：SDLC，HDLC，PPP《STP，帧中继等</p>
<p><strong>网络层</strong></p>
<p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如 果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。</p>
<p><strong>处理信息的传输层</strong></p>
<p>第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。</p>
<p><strong>会话层</strong></p>
<p>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。</p>
<p><strong>表示层</strong></p>
<p>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</p>
<p><strong>应用层</strong></p>
<p>应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="pictures/三次握手.png" alt="TCP 三次握手"></p>
<p>一开始 A和B都处于关闭状态，B首先建立传输控制模块TCB，准备接受连接请求，然后就进入LISTEN（收听）状态，等待客户端的连接请求。</p>
<p>A首先也建立传输控制块TCB，向B发送连接请求，这时首部中同部位SYN=1，同时要选择一个序列号seq=x。TCP规定，SYN同步报文段（即SYN=1）不携带任何数据，但是要消耗一个序号。这时客户端A进入SYN—SEND同步发送状态。</p>
<p>B收到连接请求后，如同意建立连接，需要发送一个确认报文，确认报文的SYN=1和ACK=1，确认号ack=x+1，同时也要为自己设置一个初始序列号seq=y,然后B进入同步收到状态，这个报文也不能携带任何数据，但是也要消耗一个序列号。</p>
<p>A收到B的确认报文段后，还要向B给出确认，确认报文段的ACK=1，确认号ack=y+1，而自己的序列号为seq=x+1，TCP规定ACK报文段可以携带数据，如果不携带数据则不消耗序列号，在这种情况下，下一个数据报文段的序号seq=x+1，TCP已建立连接A进入连接建立阶段，B收到确认报文段后也进入连接建立阶段。</p>
<p><strong>为什么A最后还要发送一次确认呢？</strong></p>
<p>主要是为了防止已失效的连接请求报文段突然到达B，从而产生错误。</p>
<p>已失效的连接请求是这样产生的，A发送了连接请求，但由于网络原因该请求在网络中的某些节点滞留了很长时间，导致A认为连接请求丢失，于是又发送了一次连接请求，这次请求建立正常的连接，并传送完数据后，正常关闭，但是第一个连接请求在连接关闭后到达B，导致B认为A又发送了一次连接请求，于是向A发出同意连接的确认报文，如果没有A的最后一次确认，此时B已经进入了连接已建立的阶段，而A收到确认后，由于没有发出连接请求，不予理会。导致B以为新的连接建立，并一直等待A发送的资源，导致很多资源白白浪费。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="pictures/四次挥手.png" alt="TCP四次挥手"></p>
<p>此时A和B都处于连接建立状态</p>
<p>A首先向TCP发送连接释放报文，并停止发送数据，主动关闭TCP连接，A发出的连接释放报文首部的终止控制位置FIN置1，其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1.这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。FIN报文段不携带任何数据</p>
<p>B收到连接释放请求后发送确认报文，确认号ack=u+1，ACK=1，这个报文段自己的序号是V，然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务进程应通知高层应用进程，从A到B这个方向的连接已经释放了，这时TCP连接处于半关闭状态，A已经没有数据要发送给B，但B可能还有数据要发送给A，也就是说从B到A这个方向的连接还没有释放。<br>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态。</p>
<p>若B没有要想A发送后的报文段，其应用进程就通知TCP释放连接，这时B发出的连接释放报文必须是FIN=1，假定序号为W，B还必须发送上次已经发送过的确认号ack=u+1，这时B就进入最后确认状态，等待A的确认。</p>
<p>A收到B的释放；连接的请求后，必须对此发出确认，在确认报文段中把ACK=1，序列号seq=u+1,确认号ack=w+1,然后进入TIME—WAIT状态，必须经过时间等待计数器设置的时间2MSL后，才进入CLOSED状态。</p>
<p>B收到A的确认报文段后进入CLOSED</p>
<p><strong>为什么A的TIME-WAIT状态必须等待2MSL的时间呢</strong></p>
<p>第一.为了保证A发送的最后一个ACK报文段能够到达B，这个报文段有可能丢失，因为使处在LAST-ACK的B收不到对方对FIN+ACK的确认。B会超时重传这个FIN-ACK。而A就能在2MSL时间能收到这个重传的报文，接着A重传一次确认，重新启动2MSL计时器，最后A和吧都进入CLOSE状态，如果A不在TIME-WAIT等待一段时间，而是发送完ACK后立即进入CLOSED状态，就收不到A重传的FIN+ACK，因而不会发送确认，导致B无法正常关闭。</p>
<p>第二.防止“已经失效的连接请求报文段”出现在本连接中。A在发送完最后的确认报文段后，在经过2MSL，就可以在本连持续的时间内所产生的报文段都从网络中消失。这样就可以在下一个新的连接中不会出现这种旧的连接请求报文段。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/腾讯面试/" data-id="cjuajt8l1000efcamtxbw1oaz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringMvc" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/SpringMvc/" class="article-date">
  <time datetime="2019-03-11T07:49:01.150Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC-架构"><a href="#SpringMVC-架构" class="headerlink" title="SpringMVC  架构"></a>SpringMVC  架构</h2><h4 id="SpringMVC架构图"><a href="#SpringMVC架构图" class="headerlink" title="SpringMVC架构图"></a>SpringMVC架构图</h4><p><img src="pictures/springMvc架构.png" alt="SpringMVC架构"></p>
<h4 id="SpringMVC-架构说明"><a href="#SpringMVC-架构说明" class="headerlink" title="SpringMVC  架构说明"></a>SpringMVC  架构说明</h4><ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回DispatcherServlet</li>
<li>DispatcherServlet通过处理器适配器（HandlerAdapter）调用处理器</li>
<li>执行处理器（Controller）</li>
<li>Controller执行完成返回ModelAndView</li>
<li>处理器适配器将Controller执行结果ModelAndView返回给dispatcherServlet</li>
<li>DispatcherServlet将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对view进行渲染视图（将模型数据填充至视图）</li>
<li>DispatcherServlet响应用户</li>
</ol>
<h4 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h4><p><strong>    DispatcherServlet：前端控制器</strong></p>
<p>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
<p><strong>HandlerMapping：处理器映射器</strong></p>
<p>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
<p><strong>HandlAdapter：处理器适配器</strong></p>
<p>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
<p><strong>    Handler：处理器</strong></p>
<p>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</p>
<p><strong>View Resolver：视图解析器</strong></p>
<p>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p>
<p><strong>View：视图</strong></p>
<p>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。</p>
<p><strong>如果在springMvc中没有显示的配置处理器映射器和处理器适配器，那么springMvc会默认的去DispatcherServlet.properties中查找，对应的处理器映射器和适配器去使用，这样每个请求都要去烧苗一次他的默认配置文件，效率非常低，会降低访问速度，所以要显示的配置处理器映射器和处理器适配器</strong></p>
<h4 id="注解式处理器映射器和注解式处理器适配器"><a href="#注解式处理器映射器和注解式处理器适配器" class="headerlink" title="注解式处理器映射器和注解式处理器适配器"></a>注解式处理器映射器和注解式处理器适配器</h4><p>注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。</p>
<pre><code>&lt;!--注解映射器 --&gt;
&lt;beanclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;
</code></pre><p><strong>4.5.4    <a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a></strong></p>
<p>springmvc使用<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>替代注解处理器和适配器的配置。自动配置最新版的适配器和映射器</p>
<p><strong>7    springmvc与struts2不同</strong></p>
<p>1、    springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</p>
<p>2、    springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<p>3、    Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/SpringMvc/" data-id="cjuajt7r20001fcam7bc9bnn3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maven" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/09/maven/" class="article-date">
  <time datetime="2019-03-09T01:54:53.237Z" itemprop="datePublished">2019-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven的优点"><a href="#Maven的优点" class="headerlink" title="Maven的优点"></a>Maven的优点</h2><ol>
<li><p>平时我们开发项目时，一般都是一个项目就是一个工程。我们划分模块时，都是使用package来进行划分。但是，当项目很大时，有很多子模块时，即使是package来进行划分，也是让人眼花缭乱。</p>
<p>   优点一：项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块之间还是可以发送消息的。</p>
</li>
<li><p>同一项目的jar包  复制 和 粘贴到WEB/INF/lib下</p>
<pre><code>问题：
同样的jar包重复出现在不同的工程中，一方面浪费空间，同时也让工程臃肿
</code></pre><p>   优点二：借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间</p>
</li>
<li><p>如果jar包都到各个官网网站下载，会浪费很多时间，而且可能不全</p>
<p>   优点三：借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中</p>
</li>
<li><p>一个jar包依赖的其他jar包可能没导入到项目而导致项目跑不起来</p>
<p>   优点四：Maven会自动将你要加入到项目中的jar包导入，不仅导入，而且还会将该jar包所依赖的jar包都自动导入进来</p>
</li>
</ol>
<h2 id="Maven的优点是如何实现的"><a href="#Maven的优点是如何实现的" class="headerlink" title="Maven的优点是如何实现的"></a>Maven的优点是如何实现的</h2><ol>
<li><p>依赖管理</p>
<p> 就是对jar 包管理的过程：<br><img src="pictures/Maven-jar依赖管理.png" alt="    Maven-依赖管理"></p>
</li>
<li><p>项目的一键构建</p>
<p> （编译—–测试—–   运行   –打包————–安装 ）</p>
<p> 什么是构建？<br> 指的是项目从编译—–测试—–   运行   –打包————–安装整个过程都交给maven进行管理，这个过程称为构建</p>
</li>
</ol>
<p><img src="pictures/Maven项目的构建过程.png" alt="    Maven-项目的构建过程"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/09/maven/" data-id="cjuajt7rg0005fcamt62797ca" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发编程相关问题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/07/java并发编程相关问题/" class="article-date">
  <time datetime="2019-03-07T09:11:54.222Z" itemprop="datePublished">2019-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java-并发编程相关面试题"><a href="#java-并发编程相关面试题" class="headerlink" title="java 并发编程相关面试题"></a>java 并发编程相关面试题</h1><h3 id="在java中守护线程和本地线程的区别"><a href="#在java中守护线程和本地线程的区别" class="headerlink" title="在java中守护线程和本地线程的区别"></a>在java中守护线程和本地线程的区别</h3><p>java 中的线程分为两种： 守护线程和用户线程</p>
<p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolean on);true 则把该线程设置为守护线程，反之则设置为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则会抛出异常。</p>
<p><strong>区别</strong></p>
<p>唯一的区别判断虚拟机何时离开，守护线程是为其他线程提供服务的，如果全部的User Thread已经撤离，守护线程没有课服务的线程，JVM会自动撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。</p>
<p>守护线程：所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个典型的守护线程，并且这种线程并不属于程序中不可或缺的部分。因此， 当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p>
<p>用户线程：Java虚拟机在它所有非守护线程已经离开后自动离开。</p>
<p>守护线程和非守护线程并没有什么区别，他们唯一的区别就是虚拟机离开时的状态：</p>
<ol>
<li>当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中所有的守护线程</li>
<li>守护线程是用来服务用户线程的，如果没有其他用户线程在运行，那么久没有可服务对象，也没有理由继续下去</li>
</ol>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程： 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，是操作系统分配资源的最小单元。<br>线程： 是进行的一个执行单元。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。是操作系统调度的最小单元。</p>
<p>一个程序至少有一个进程，一个进程至少有一个线程</p>
<p>线程的执行过程是是线性的，尽管会发生中断或则暂停，但是进程所拥有的资源只为该线性执行过程服务，一旦发生线程切换，这些资源需要被保护起来</p>
<p>进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作</p>
<p>线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有资源的变化</p>
<p><strong>区别</strong></p>
<ol>
<li>地址空间：同一个进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间</li>
<li><p>资源拥有：同一进程内的线程共享本进程的资源如内存，I/O，cpu等，但是进程之间的资源是独立的。<br>   一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃后整个进程都死掉了，所以多进程要比多线程健壮。</p>
<p>   进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程</p>
</li>
<li>执行过程：每个独立的进程有一个程序运行的入口，顺序执行序列。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li>
<li>线程是处理器调度的进本单元，但是进程不是</li>
<li>两者均可并发执行</li>
</ol>
<p><strong>优缺点：</strong><br>线程执行开销小，但是不利于资源的管理和保护</p>
<p>进程执行开销大，但是能够很好的进行资源管理和保护</p>
<h3 id="什么叫线程安全？-servlet是线程安全吗？"><a href="#什么叫线程安全？-servlet是线程安全吗？" class="headerlink" title="什么叫线程安全？ servlet是线程安全吗？"></a>什么叫线程安全？ servlet是线程安全吗？</h3><p>线程安全是编程中的术语，指某个函数，函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成</p>
<p>Servlet不是线程安全的，servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的</p>
<p>Struts2的action是多实例多线程，是线程安全的，每个请求过来都会new一个新的action分配给这个请求，请求完成后销毁。</p>
<p>SpringMVC的Controller是不是线程安全</p>
<p>Struts2好处是不用考虑线程安全问题；Servlet和SpringMVC需要考虑线程安全问题，但是性能可以提升不用处理太多的gc，课使用ThreadLocal来处理多线程问题</p>
<h3 id="如何确保线程安全"><a href="#如何确保线程安全" class="headerlink" title="如何确保线程安全"></a>如何确保线程安全</h3><p>确保线程安全的方法有几个：竞争与原子操作，同步与锁，可重入，过度优化</p>
<p><strong>竞争与原子操作</strong></p>
<p>多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严重后果的原因是很多操作被操作系统编译为汇编代码之后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管怎样，单条指令的执行是不会被打断的。</p>
<p><strong>同步与锁</strong></p>
<p>为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。</p>
<p>同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。</p>
<p><strong>可重入</strong></p>
<p>一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。</p>
<p><strong>过度优化</strong></p>
<p>我们可以使用volatile关键字试图阻止过度优化，它可以做两件事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写回；第二，阻止编译器调整操作volatile变量的指令顺序。</p>
<p>在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困难，通常的解决办法是调用CPU提供的一条常被称作barrier的指令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦然。<br>java中 可以使用同步（synchronized），使用原子类（atomic concurrent classes），实现并发锁，使用volatile关键字，使用不变类和线程安全类</p>
<h3 id="什么是多线程中的上下文切换"><a href="#什么是多线程中的上下文切换" class="headerlink" title="什么是多线程中的上下文切换"></a>什么是多线程中的上下文切换</h3><p>多线程会共同使用一组计算机上的CPU，而线程数量大于给程序分配的CPU数量时，为了让哥哥线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切花数据等就是上下文切换。</p>
<p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置之后继续运行。上下文切换时存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换时多任务操作系统和多线程环境的基本特征。</p>
<h3 id="Java中有几种方法可以实现一个线程"><a href="#Java中有几种方法可以实现一个线程" class="headerlink" title="Java中有几种方法可以实现一个线程"></a>Java中有几种方法可以实现一个线程</h3><ol>
<li>继承Thread类，实现run方法</li>
<li>实现Runnable接口</li>
<li>实现Callable接口，需要实现的是call()方法</li>
<li>从线程池中获取一个</li>
</ol>
<h3 id="如何停止一个正在运行的线程"><a href="#如何停止一个正在运行的线程" class="headerlink" title="如何停止一个正在运行的线程"></a>如何停止一个正在运行的线程</h3><ol>
<li>使用共享变量的方式。在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知线程中断。</li>
<li>使用interrupt方法终止线程</li>
</ol>
<p>Thread.interrupt()的作用是通知线程应该中断了，到底中断还是继续执行，应该由被通知的线程自己处理，当对一个线程，调用interrupt()时</p>
<ol>
<li>如果线程处于被阻塞状态(例如处于sleep，wait，join等状态)，那么线程将立即退出被阻塞状态，并抛出一个interruptedException异常</li>
<li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，被设置中断标志的线程将继续正常运行，不受影响</li>
</ol>
<p>这里再说一下interrupted()，贴一下jdk1.8源码的方法注释，当调用这个方法会将中断标志重置，如果线程继续执行，下一次调用这个方法返回为false，除非再次调用interrupt()方法设置一次。简单来说就是一次interrupt()只对应一次interrupted()的true状态</p>
<h3 id="可以直接调用Thread类的run-方法么"><a href="#可以直接调用Thread类的run-方法么" class="headerlink" title="可以直接调用Thread类的run()方法么"></a>可以直接调用Thread类的run()方法么</h3><p>可以，但是如果我们调用了Thread的run()方法，他就会和普通的方法一样，会在当前线程中执行，为了在新的线程中执行我们得代码，必须使用Thread.start()方法</p>
<h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><ol>
<li>初始态：new<br>   创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态</li>
<li><p>运行态：RUNNING<br> 在java中运行态包括就绪态和运行态</p>
<p> 运行态：获得CPU执行权，正在执行的线程，由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</p>
<p> 就绪态:runnable 该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中</p>
</li>
<li><p>阻塞态：BLOKED</p>
<p> 当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在java中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。锁，IO，Socket等都是资源</p>
</li>
<li><p>等待态：WAITING</p>
<p>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。也有一个等待队列存放所有等待态的线程。线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p>
</li>
<li><p>超时等待</p>
<p>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；进入该状态后释放CPU执行权 和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p>
</li>
<li><p>终止态</p>
<p>线程结束后的状态</p>
<p>线程状态转换中几个需要注意的点</p>
<p>1、wait()方法会释放CPU执行权 和 占有的锁。</p>
<p>2、sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</p>
<p>3、yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</p>
<p>4、wait和notify必须配套使用，即必须使用同一把锁调用；</p>
<p>5、wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</p>
</li>
</ol>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p>
<p>Java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级</p>
<h3 id="什么是线程调度器和时间分片"><a href="#什么是线程调度器和时间分片" class="headerlink" title="什么是线程调度器和时间分片"></a>什么是线程调度器和时间分片</h3><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现</p>
<p>线程调度并不受java虚拟机控制，所以由应用程序来控制它是更好的选择</p>
<p>时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU市价可以基于线程优先级或则线程等待的时间</p>
<h3 id="你如何确保main-方法所在的线程是Java-程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java-程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java 程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java 程序最后结束的线程？</h3><p>我们可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。</p>
<p>1.jvm会在所有的非守护线程（用户线程）执行完毕后退出；</p>
<p>2、main线程是用户线程；</p>
<p>3、仅有main线程一个用户线程执行完毕，不能决定jvm是否退出，也即是说main线程并不一定是最后一个退出的线程。</p>
<p>所以如果需要确保main方法所在的线程是jvm中最后结束的线程，这里就需要用到thread类的join()方法：<br>在一个线程中启动另外一个线程的join方法，当前线程将会挂起，而执行被启动的线程，知道被启动的线程执行完毕后，当前线程才开始执行。</p>
<h3 id="为什么-Thread类的sleep-和yield-方法是静态的？"><a href="#为什么-Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么 Thread类的sleep()和yield()方法是静态的？"></a>为什么 Thread类的sleep()和yield()方法是静态的？</h3><p>Thread类的sleep()和yield()方法将在当前执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。</p>
<p>sleep()方法和yield()方法都是Thread类的静态方法，都会使当前处于运行状态的线程放弃CPU，把运行机会让给别的线程。两者的区别在于：</p>
<p>sleep()方法会给其他线程运行的机会，不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。</p>
<p>当线程执行了sleep(long millis)方法，将转到阻塞状态，参数millis指定睡眠时间；当线程执行了yield()方法，将转到就绪状态。</p>
<p>sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明抛出任何异常。</p>
<h3 id="notify-和notifyAll-有什么区别？"><a href="#notify-和notifyAll-有什么区别？" class="headerlink" title="notify()和notifyAll()有什么区别？"></a>notify()和notifyAll()有什么区别？</h3><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p>
<h3 id="为什么wait-notify-和-notifyAll这些方法不在Thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在Thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在Thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在Thread类里面？</h3><p>一个很明显的原因是Java提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h3 id="为什么你应该在循环中检查等待条件？"><a href="#为什么你应该在循环中检查等待条件？" class="headerlink" title="为什么你应该在循环中检查等待条件？"></a>为什么你应该在循环中检查等待条件？</h3><p>处于等待状态的线程可能会受到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<h3 id="java中wait和sleep方法的不同？"><a href="#java中wait和sleep方法的不同？" class="headerlink" title="java中wait和sleep方法的不同？"></a>java中wait和sleep方法的不同？</h3><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。wait通常被用于线程间交互，sleep通常被用于暂停执行。</p>
<p>其此：sleep是线程Thread中的方法，而wait是对象中的方法</p>
<p>java通过  中断  和 共享变量  来实现多个线程之间的通讯和协作</p>
<h3 id="如何在两个线程间共享变量"><a href="#如何在两个线程间共享变量" class="headerlink" title="如何在两个线程间共享变量"></a>如何在两个线程间共享变量</h3><p>在两个线程间共享变量即可实现共享。一般来说，共享变量要求变量本身是线程安全的，然后再线程内使用的时候，如果有对共享变量的复合操作，name也得保证复合操作的线程安全性。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="ThreadLocal的简单介绍"><a href="#ThreadLocal的简单介绍" class="headerlink" title="ThreadLocal的简单介绍"></a>ThreadLocal的简单介绍</h4><p>  ThreadLocal是线程内部的数据存储类，可以使用ThreadLocal在指定的线程中存储数据，而存储后的数据也只有在这个指定的线程中才能够获取到，其他线程则无法过去</p>
<h4 id="涉及到的几个重要类"><a href="#涉及到的几个重要类" class="headerlink" title="涉及到的几个重要类"></a>涉及到的几个重要类</h4><ol>
<li>Thread: 一个Thread代表一个线程</li>
<li>ThreadLocal：</li>
<li>ThreadLocalmap:可以看成一盒HashMap，但是它本身具体的实现并没有继承HashMap甚至跟java.util.map都没有关系。只是内部的实现跟hashMap类似</li>
<li>ThreadLocalMap.Entry:把它看成是保存键值对的对象，其本质上是一个weakReference<threadlocal>对象</threadlocal></li>
</ol>
<h4 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h4><ol>
<li>创建一个泛型为String的ThreadLocal</li>
</ol>
<pre><code>`val threadLocal = ThreadLocal&lt;String&gt;()`
</code></pre><ol start="2">
<li>在指定线程中存储值并取出值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(&quot;MainThreadValue&quot;)</span><br><span class="line">        Log.e(TAG, &quot;$&#123;Thread.currentThread().name&#125; : threadLocal = &quot; + threadLocal.get())</span><br><span class="line"></span><br><span class="line">        Thread(Runnable &#123;</span><br><span class="line">            threadLocal.set(&quot;Thread1Value&quot;)</span><br><span class="line">            Log.e(TAG,&quot;$&#123;Thread.currentThread().name&#125; : threadLocal = &quot; + threadLocal.get())</span><br><span class="line">        &#125;,&quot;Thread1&quot;).start()</span><br><span class="line"></span><br><span class="line">        Thread(Runnable &#123;</span><br><span class="line">            Log.e(TAG,&quot;$&#123;Thread.currentThread().name&#125; : threadLocal = &quot; + threadLocal.get())</span><br><span class="line">        &#125;,&quot;Thread2&quot;).start()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出时可以发现在不同线程中访问的是同一个ThreadLocal对象，但是在不同的线程中获取的值却是不一样的。</p>
<h4 id="ThreadLocal的源码分析"><a href="#ThreadLocal的源码分析" class="headerlink" title="ThreadLocal的源码分析"></a>ThreadLocal的源码分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal是一个泛型类，所以我们可以在ThreadLocal中存储任意类型的值，它的核心方法有3个：get(),set(T value),remove().</p>
<p><strong>1.set()方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       if (map != null)</span><br><span class="line">           map.set(this, value);</span><br><span class="line">       else</span><br><span class="line">           createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">           return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">          t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据当前所在线程getMap(t)获取ThreadLocal对象，如果ThreadLocalMap ！= null就将需要保存的值以&lt;key,value&gt;的形式保存，key是ThreadLocal实例，value是传入的参数value，ThreadLocalMap == null就创建ThreadLocalMap对象，将对象赋值给Thread实例的ThreadLocals属性，并将值保存。我们发现数据的存储于ThreadLocalMap有很大关系，那很自然的数据的获取也与ThreadLocalMap有关</p>
<p><strong>ThreadLocalMap</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">    size = 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个线程对象都有一个ThreadLocalMap类型的变量。ThreadLocalMap是ThreadLocal的内部静态类，是用于线性探测法的散列表实现的。每一个线程对象可以往Map中添加多个ThreadLocal对象为键的键值对，每个键对应的值唯一。所以通过一个ThreadLocal对象设置的值，在每个线程中都是唯一且相互独立的。唯一是因为键的唯一性，独立是因为每个线程都有自己的ThreadLocalMap内部变量。它是归线程所有的。</p>
<p>ThreadLocalMap的构造方法里显示定义一个初始大小为16的Entry数组实例table，用于存储Entry对象。不难理解key，value被封装进了Entry对象里。也就是说，ThreadLocalMap维护着一张哈希表也就是table数组，并且设定了一个临界值setThreashold(),当哈希表里面存储的对象达到容量的2/3的时候就需要扩容。</p>
<p><strong>注意：用于存放Entry对象的table数组是每一个线程都持有的，内部使用THreadLocal&lt;?&gt; key来区分数据来自哪个ThreadLocal。这也是为什么在指定的线程中可以获取到相应的值</strong></p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>entry是ThreadLocalMap中的静态内部类。需要注意的是entry继承自WeakReference，是一个弱引用很有可能会被系统回收掉。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被引用关联的对象。因此如果某个线程已经运行结束，不会因为这里有对它的引用而就无法回收，这个键会在回收后变成null。</p>
<h4 id="ThreadLocal的set方法"><a href="#ThreadLocal的set方法" class="headerlink" title="ThreadLocal的set方法"></a>ThreadLocal的set方法</h4><p>ThreadLocal的set()方法就是调用了ThreadLocalMap的set()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    // 已经调用过set或get方法时，往线程的map中添加新的值，键为当前ThreadLocal对象</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    // 没有调用过set或get方法时，为当前线程创建一个ThreadLocalMap</span><br><span class="line">    // 并添加第一个值，键为当前ThreadLocal对象</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回Thread对象t的ThreadLocalMap属性，初始为null</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadLocalMap中的set</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">            // We don&apos;t use a fast path as with get() because it is at</span><br><span class="line">            // least as common to use set() to create new entries as</span><br><span class="line">            // it is to replace existing ones, in which case, a fast</span><br><span class="line">            // path would fail more often than not.</span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">           //计算存储的位置i</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">           //如果存储的位置i已经存储了对象，就向后寻找下一个位置（nextIndex(i,len)），以此类推直到找到空的位置</span><br><span class="line">            for (Entry e = tab[i];</span><br><span class="line">                 e != null;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">           //如果Entry对象的key值和需要存储的key值是同一个，就对这个value进行替换</span><br><span class="line">                if (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            //key为空对这个位置的Entry对象重新赋值</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           //table数组中没有这样的含有这个key值的Entry对象，创建Entry对象存储</span><br><span class="line">           //判断table数组中存储对象的个数是否超过了临界值（threshold），如果超出了需要扩充并重新计算所有对象的位置（rehash()）</span><br><span class="line">            tab[i] = new Entry(key, value);</span><br><span class="line">            int sz = ++size;</span><br><span class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>致分析上面都已经标注出来了，需要注意的是Entry对象是继承是WeakReference也就是一个弱引用是会被回收的，所以对应 的key值可能是为null的。存放对象之后是需要判断数组中存储对象的个数是否超过了设定的临界值threshold的大小，如果超过了需要扩容，并且还要重新计算扩容后所有对象的位置。扩容的方法是rehash()</p>
<p><strong>扩容方法rehash()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void rehash() &#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            // Use lower threshold for doubling to avoid hysteresis</span><br><span class="line">            if (size &gt;= threshold - threshold / 4)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>rehash()中主要做了两步操作：</p>
<ol>
<li>显示删除过时的Entry：expungeStaleEntries()</li>
<li>如果存储对象个数大于临界值的3/4,扩容</li>
</ol>
<p><strong>expungeStaleEntries()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = tab[j];</span><br><span class="line">                if (e != null &amp;&amp; e.get() == null)</span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>删除数组中过时的Entry对象。有些疑问什么是过时的Entry？为什么会过时？Entry是弱引用会被回收。这个方法中判断的删除条件是，Entry对象不为空并且key值为空。可见expungStaleEntry(j) 方法就是删除指定索引的Entry对象。</p>
<h4 id="resize-扩容"><a href="#resize-扩容" class="headerlink" title="resize()扩容"></a>resize()扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void resize() &#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            int oldLen = oldTab.length;</span><br><span class="line">            int newLen = oldLen * 2;</span><br><span class="line">            Entry[] newTab = new Entry[newLen];</span><br><span class="line">            int count = 0;</span><br><span class="line"></span><br><span class="line">            for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                if (e != null) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    if (k == null) &#123;</span><br><span class="line">                        e.value = null; // Help the GC</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                        while (newTab[h] != null)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>先是创建一个是原来容量两倍的Entry[]数组，在遍历原来的数组，将key值为空的Entry对象的value置为空方便GC回收，key不为空的Entry对象先根据key的hashcode计算需要存放的位置存入新的数组中，存储结束后别忘了更新临界值。</p>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p>调用getMap(t);方法获取当前线程的ThreadLocalMap对象，ThreadLocalMap != null的时候调用ThreadLocalMap的getEntry();方法获取ThreadLocalMap.Entry对象，再获取Entry对象中的value值并返回。如果ThreadLocalMap==null的时候（可能未调用过set();方法进行初始化），调用setInitialValue();初始化value（null），保存，并返回。</p>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><p>调用了ThreadLocalMap的remove()方法;最终调用了Entry的clear();方法，也就是Reference的clear();方法，删除数组中根据key的hashcode计算出来的索引i位置上的Entry对象。</p>
<p><strong>总结</strong><br>总结：从ThreadLocal的set();，get()和remove();方法可以看出，它们所操作的对象都是当前线程的ThreadLocalMap对象的table数组，因此在不同线程中访问同一个ThreadLocal的set();,get();和remove();方法，它们对ThreadLocal所做的读/写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰地存储和修改数据。</p>
<h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>ThreadLocal的设计初衷就是为了提供线程内部的局部变量，方便在本线程内随时随地的读取，并且与其他线程隔离。</p>
<p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p>
<p>每个ThreadLocal可以放一个线程级别的变量，但是它本身可以被多个线程共享使用，而且又可以达到线程安全的目的，且绝对线程安全。</p>
<h3 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h3><p>  很多时候我们会创建一些静态域来保存全局对象，那么这个对象就可能被任意线程访问，如果能保证是线程安全的，那倒是没啥问题，但是有时候很难保证线程安全，这时候我们就需要为每个线程都创建一个对象的副本，我们也可以用ConcurrentMap&lt;Thread, Object&gt;来保存这些对象，这样会比较麻烦，比如当一个线程结束的时候我们如何删除这个线程的对象副本呢？如果使用ThreadLocal就不用有这个担心了，ThreadLocal保证每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）</p>
<ol>
<li><p>当某些数据以线程为作用域，并且不同线程拥有不同数据副本的时候。</p>
<pre><code> 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等

Spring的事务管理器通过AOP切入业务代码，在进入业务代码前，会根据对应的事务管理器提取出相应的事务对象，假如事务管理器是DataSourceTransactionManager，就会从DataSource中获取一个连接对象，通过一定的包装后将其保存在ThreadLocal中。并且Spring也将DataSource进行了包装，重写了其中的getConnection()方法，或者说该方法的返回将由Spring来控制，这样Spring就能让线程内多次获取到的Connection对象是同一个。
</code></pre></li>
<li><p>复杂逻辑下对象传递，比如监听器的传递</p>
<p>   使用参数传递的话：当函数调用栈更深时，设计会很糟糕，为每一个线程定义一个静态变量监听器，如果是多线程的话，一个线程就需要定义一个静态变量，无法扩展，这时候使用ThreadLocal就可以解决问题</p>
<h3 id="java中interrupted和isinterrupted方法的区别？"><a href="#java中interrupted和isinterrupted方法的区别？" class="headerlink" title="java中interrupted和isinterrupted方法的区别？"></a>java中interrupted和isinterrupted方法的区别？</h3></li>
<li><p>interrupt</p>
<p> interrupt方法用于中断线程。调用该方法的线程的状态将被置位“中断状态”<br><strong>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程状态并做处理。支持线程中断的方法就是在监视线程中断的状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常</strong></p>
</li>
</ol>
<p>2.interrupted</p>
<pre><code>查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。
</code></pre><p>3.isInterrupted</p>
<p>  仅仅是查询当前线程的中断状态</p>
<h3 id="Thread类中的yield方法有什么作用"><a href="#Thread类中的yield方法有什么作用" class="headerlink" title="Thread类中的yield方法有什么作用"></a>Thread类中的yield方法有什么作用</h3><pre><code>使当前线程从执行状态变为可执行状态（就绪状态）

当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。
</code></pre><h3 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h3><p>在java.lang.Thread中有一个方法叫holdsLock(),它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h3 id="什么是可重入锁（ReentrantLock-）"><a href="#什么是可重入锁（ReentrantLock-）" class="headerlink" title="什么是可重入锁（ReentrantLock()）"></a>什么是可重入锁（ReentrantLock()）</h3><p>可重入锁，也叫递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。</p>
<p><strong>可重入性</strong><br>ReentrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>锁的实现</strong><br>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，前者的实现时比较难见到的，后者有直接的源码可供阅读。</p>
<p><strong>功能区别</strong></p>
<p>便利性：很明显synchronized的使用比较方便简单，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<p><strong>ReenTrantLock独有的功能</strong></p>
<ol>
<li>ReenTrantLock可以指定公平锁还是非公平锁，而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁</li>
<li>ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个，要么全部唤醒</li>
<li>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li>
</ol>
<p><strong>ReenTrantLock原理简述</strong></p>
<p>ReenTrantLock的实现时一种自旋锁，通过循环调用CAS操作来实现加锁</p>
<h3 id="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h3><p>如果其他方法没有synchronized的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p>
<h3 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h3><p><strong>悲观锁：</strong><br>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次那数据的时候都会上锁，这样别人向南这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。java中的同步synchronized关键字的实现也是悲观锁。</p>
<p><strong>乐观锁：</strong><br>就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁使用与多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是乐观锁。CAS就是乐观锁的一种实现方式。</p>
<p><strong>悲观锁的实现</strong><br>在对任何记录修改前，先尝试为该记录加上排他锁。如果加锁失败，说明该记录正在被修改，name当前查询可能要等待或则抛出异常，如果加锁成功，那么就可以对记录做修改，事务完成后就会解锁。</p>
<p>悲观锁的策略过于保守，并发性能不好而且有产生死锁的风险，所以悲观锁要慎重使用。目前它主要用于数据竞争激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中</p>
<p><strong>乐观锁的实现</strong></p>
<p>1.一般乐观锁的实现都是基于数据版本号，使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新版本号，版本号不一致时可以采取丢弃和再次尝试的策略</p>
<p>2.Java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<p>如果系统的并发非常大的话，悲观锁定会带来非常大的并发问题。所以此时我们就要选着乐观锁进行并发控制</p>
<h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ol>
<li>ABA问题</li>
</ol>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。</p>
<ol start="2">
<li><p>循环时间长开销大：</p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
</ol>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<h3 id="synchronizedMap-与ConcurrentHashMap主要区别"><a href="#synchronizedMap-与ConcurrentHashMap主要区别" class="headerlink" title="synchronizedMap()与ConcurrentHashMap主要区别"></a>synchronizedMap()与ConcurrentHashMap主要区别</h3><p>Collections.synchronizedMap()与ConcurrentHashMap主要区别是：Collections.synchronizedMap()和Hashtable一样，在调用map所有方法的时候，都对整个map进行同步（即不同线程可以同时调用同一个map）。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁，所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。</p>
<h3 id="CopyOnWriteArrayList可以用于什么应用场景"><a href="#CopyOnWriteArrayList可以用于什么应用场景" class="headerlink" title="CopyOnWriteArrayList可以用于什么应用场景"></a>CopyOnWriteArrayList可以用于什么应用场景</h3><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<pre><code>1.由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或则full gc

2.不能用于实时读的场景，像拷贝数组，新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList能做到最终一致性，但是还是没法满足实时性要求。
</code></pre><p>CopyOnWriteArrayList透露的思想：<br>         1.读写分离，读和写分开</p>
<pre><code>2.最终一致性

3.使用另外开辟空间的思路，来解决并发冲突
</code></pre><h3 id="volatile关键字的作用-应用场景"><a href="#volatile关键字的作用-应用场景" class="headerlink" title="volatile关键字的作用   应用场景"></a>volatile关键字的作用   应用场景</h3><p>在启动线程的时候，虚拟机为每个内存分配了一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要的共享变量的副本，当然这是为了提高执行效率，读副本比直接读主内存更快</p>
<p>那么对于volatile修饰的变量（共享变量）来说，在工作内存发生了变化后，必须要马上写到主内存中，而线程读取到是volatile修饰的变量时，必须去主内存中去获取最新的值，而不是读工作内存中主内存的副本，这就有效的保证了线程之间变量的可见性。</p>
<p>特性一： 内存可见性，即线程A对volatile变量的修改，其他线程获取的volatile变量都是最新的</p>
<pre><code>volatile的例子很难重现，因为只有在对变量读取频率很高的情况下，虚拟机才不会及时写会到主内存，当频率没有达到虚拟机认为的高频率时，普通变量和volatile变量是同样的处理逻辑。
</code></pre><p>特性二：可以禁止指令重排序</p>
<pre><code>为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则将程序编写顺序打乱。

如果变量没有volatile修饰，程序执行的顺序可能会进行重排序
</code></pre><p>volatile用于多线程环境下的单次操作（单次读或单次写）</p>
<p>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p>
<ol>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
<p>可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<h3 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意冲排序;</p>
<pre><code>1.单线程环境下不能改变程序的运行结果

2.存在数据依赖关系的不允许重排序
</code></pre><p><strong>注意：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义</strong></p>
<h3 id="死锁与活锁的区别，死锁与饥饿的区别？"><a href="#死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别？"></a>死锁与活锁的区别，死锁与饥饿的区别？</h3><p><strong>死锁：</strong>  是指两个或则两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ol>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件:进程已获得资源，在未使用完成之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p><strong>活锁：</strong>  任务或则执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败</p>
<p>活锁和死锁的区别在于：处于活锁的实体是在不断的改变状态，所谓“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p><strong>饥饿：</strong>   一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态</p>
<p>java中导致饥饿的原因：</p>
<ol>
<li>高优先级线程吞噬所有低优先级线程的CPU时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</li>
<li>线程在等待一个本身也处于永久等待完成的对象，因为其他线程总是被持续地唤醒</li>
</ol>
<h3 id="java中用到的线程调度算法是什么"><a href="#java中用到的线程调度算法是什么" class="headerlink" title="java中用到的线程调度算法是什么"></a>java中用到的线程调度算法是什么</h3><p>线程调度模式：</p>
<ol>
<li><p>抢占式调度</p>
<p> 抢占式调度指的是每条线程执行的时间，线程的切换都由系统控制。系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。</p>
</li>
<li><p>协同式调度</p>
<p> 协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行</p>
</li>
</ol>
<p>Java使用的线程调度是抢占式调度，在JVM中体现为让可运行池中优先级高的线程拥有CPU使用权，如果可运行池中线程优先级一样则随机选择线程，但要注意的是实际上一个绝对时间点只有一个线程在运行（这里是相对于一个CPU来说，如果你的机器是多核的还是可能多个线程同时运行的），直到此线程进入非可运行状态或另一个具有更高优先级的线程进入可运行线程池，才会使之让出CPU的使用权，更高优先级的线程抢占了优先级低的线程的CPU。</p>
<p>采用的是时间片轮转的方式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/07/java并发编程相关问题/" data-id="cjuajt99d000ofcamzjjpmdc5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-concurrentHashMap源码解析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/06/concurrentHashMap源码解析/" class="article-date">
  <time datetime="2019-03-06T07:07:32.559Z" itemprop="datePublished">2019-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解ConcurrentHashMap"><a href="#深入理解ConcurrentHashMap" class="headerlink" title="深入理解ConcurrentHashMap"></a>深入理解ConcurrentHashMap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="JDK1-6分析"><a href="#JDK1-6分析" class="headerlink" title="JDK1.6分析"></a>JDK1.6分析</h3><p>ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。</p>
<p>其包含两个核心静态内部类Segment和HashEntry。</p>
<ol>
<li>Segment继承ReentrantLock用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶。</li>
<li>HashEntry用来封装映射表的键值对</li>
<li>每个桶位是由若干个HashEntry对象链接起来的链表<br>一个ConcurrentHashMap实例中包含由若干个Segment对象组成的数组。</li>
</ol>
<p><img src="pictures/ConcurrentHashMap存储结构.png" alt="ConcurrentHashMap存储结构"></p>
<h3 id="JDK1-8分析"><a href="#JDK1-8分析" class="headerlink" title="JDK1.8分析"></a>JDK1.8分析</h3><p>JDK1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。</p>
<p><img src="pictures/JDK1.8 concurrenthashmap.png" alt="jdk1.8"></p>
<p><strong>基础概念</strong></p>
<ol>
<li>table:默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时默认总是2的幂次方。</li>
<li>nextTable：默认为null，扩容时新生成的数组，其大小为原数组的两倍。</li>
<li>sizeCtl：默认为0，用来控制table的初始化和扩容操作<pre><code>-1：代表table正在初始化；
-N：表示有N-1个线程正在进行扩容操作
其余情况：
      如果table未初始化，表示table需要初始化的大小。
      如果table初始化完成，表示table的容量，默认是table大小的0.75倍
</code></pre></li>
<li>Node：保存key，value及key的hash值的数据结构<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">  final int hash;  </span><br><span class="line">  final K key;  </span><br><span class="line">  volatile V val;  </span><br><span class="line">  volatile Node&lt;K,V&gt; next;  </span><br><span class="line">  ... 省略部分代码  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中value和next都用volatile修饰，保证并发的可见性。</p>
<ol start="5">
<li><p>ForwardingNode：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;  </span><br><span class="line">  final Node&lt;K,V&gt;[] nextTable;  </span><br><span class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </span><br><span class="line">      super(MOVED, null, null, null);  </span><br><span class="line">      this.nextTable = tab;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。</p>
</li>
</ol>
<p><strong>实例初始化</strong><br>实例化ConcurrentHashMap时带参数，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小是2的幂次方，算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;&gt;(100);  </span><br><span class="line">private static final int tableSizeFor(int c) &#123;  </span><br><span class="line">    int n = c - 1;  </span><br><span class="line">    n |= n &gt;&gt;&gt; 1;  </span><br><span class="line">    n |= n &gt;&gt;&gt; 2;  </span><br><span class="line">    n |= n &gt;&gt;&gt; 4;  </span><br><span class="line">    n |= n &gt;&gt;&gt; 8;  </span><br><span class="line">    n |= n &gt;&gt;&gt; 16;  </span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面所有过程，都是保证造成一个所有位1的数据。并且通过最后的+1.变成2的N次方格式的数据<br><strong>注意</strong><br>ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会初始化table，而是延缓到第一次put操作。</p>
<p><strong>table初始化</strong><br>table初始化操作会延缓到第一次put行为。但是put是可以并发执行的，如何做到只初始化一次呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;  </span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;  </span><br><span class="line">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片  </span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)   </span><br><span class="line">            Thread.yield(); // lost initialization race; just spin  </span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;  </span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;  </span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];  </span><br><span class="line">                    table = tab = nt;  </span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                sizeCtl = sc;  </span><br><span class="line">            &#125;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return tab;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行Unsafe.compareAndSwaplnt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其他线程通过Thread.yield()让出CPU时间片等待table初始化完成</p>
<p><strong>put操作</strong><br>假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;  </span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();  </span><br><span class="line">    int hash = spread(key.hashCode());  </span><br><span class="line">    int binCount = 0;  </span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;  </span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;  </span><br><span class="line">        if (tab == null || (n = tab.length) == 0)  </span><br><span class="line">            tab = initTable();  </span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;  </span><br><span class="line">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))  </span><br><span class="line">                break;                   // no lock when adding to empty bin  </span><br><span class="line">        &#125;  </span><br><span class="line">        else if ((fh = f.hash) == MOVED)  </span><br><span class="line">            tab = helpTransfer(tab, f);  </span><br><span class="line">        ...省略部分代码  </span><br><span class="line">    &#125;  </span><br><span class="line">    addCount(1L, binCount);  </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>获取table中对应索引的元素f<br>tabAt采用的是Unsafe.getObjectVolatile来获取，为什么不直接用table[index]呢？</li>
</ol>
<p>在java线程内存模型中，每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但是不能保证table每次拿到的数据都是最新的。，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到的数据都是最新的。</p>
<ol start="2">
<li>如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点<pre><code>1.如果CAS成功，说明Node节点已经插入，随后addCOUNT（1L,binCount）方法会检查当前容量是否需要扩容。
2.如果CAS失败，说明有其他线程提前插入了节点，自旋重新尝试在这个位置插入节点。
</code></pre></li>
<li>如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其他线程正在扩容，则一起进行扩容操作</li>
<li>其余情况把新的Node节点按链表或则红黑树的方式插入到合适的位置，这个过程采用了同步内置锁实现并发：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">synchronized (f) &#123;  </span><br><span class="line"> if (tabAt(tab, i) == f) &#123;  </span><br><span class="line">     if (fh &gt;= 0) &#123;  </span><br><span class="line">         binCount = 1;  </span><br><span class="line">         for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;  </span><br><span class="line">             K ek;  </span><br><span class="line">             if (e.hash == hash &amp;&amp;  </span><br><span class="line">                 ((ek = e.key) == key ||  </span><br><span class="line">                  (ek != null &amp;&amp; key.equals(ek)))) &#123;  </span><br><span class="line">                 oldVal = e.val;  </span><br><span class="line">                 if (!onlyIfAbsent)  </span><br><span class="line">                     e.val = value;  </span><br><span class="line">                 break;  </span><br><span class="line">             &#125;  </span><br><span class="line">             Node&lt;K,V&gt; pred = e;  </span><br><span class="line">             if ((e = e.next) == null) &#123;  </span><br><span class="line">                 pred.next = new Node&lt;K,V&gt;(hash, key,  </span><br><span class="line">                                           value, null);  </span><br><span class="line">                 break;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     else if (f instanceof TreeBin) &#123;  </span><br><span class="line">         Node&lt;K,V&gt; p;  </span><br><span class="line">         binCount = 2;  </span><br><span class="line">         if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,  </span><br><span class="line">                                        value)) != null) &#123;  </span><br><span class="line">             oldVal = p.val;  </span><br><span class="line">             if (!onlyIfAbsent)  </span><br><span class="line">                 p.val = value;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在节点f上进行同步，节点插入之前，再次利用tabAt（tab，i）==f 判断，防止被其他线程修改。</p>
<ol>
<li>如果f.hash&gt;=0,说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。</li>
<li>如果f是TreeBin类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。</li>
<li>如果链表中节点数binCount&gt;=THRESHOLD(默认是8)，则把链表转化为红黑树结构。</li>
</ol>
<p><strong>table扩容</strong></p>
<p>当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。<br>整个扩容分为两部分：</p>
<ol>
<li>构建一个nextTable，大小为table的两倍</li>
<li>把table的数据复制到nextTable中。<br>这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能提升不好，但实现的复杂度上也上升了一个台阶。</li>
</ol>
<p>遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心 。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题</p>
<p>先看第一步，构建nextTable，这个过程只能有单个线程进行nexttable 的初始化，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;  </span><br><span class="line">    ... 省略部分代码  </span><br><span class="line">    if (check &gt;= 0) &#123;  </span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;  </span><br><span class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;  </span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">            int rs = resizeStamp(n);  </span><br><span class="line">            if (sc &lt; 0) &#123;  </span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||  </span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||  </span><br><span class="line">                    transferIndex &lt;= 0)  </span><br><span class="line">                    break;  </span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))  </span><br><span class="line">                    transfer(tab, nt);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,  </span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))  </span><br><span class="line">                transfer(tab, null);  </span><br><span class="line">            s = sumCount();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组为原来的两倍，但是容量是原来的1.5倍。</p>
<p>节点从table移动到nextTable，答题思想是遍历，复制的过程。</p>
<ol>
<li>首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</li>
<li>如果f==null ，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObject方法实现的，很巧妙的实现了节点的并发移动。</li>
<li>如果f是链表的头结点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋fwd。<br>遍历过所有的节点以后就完成了赋值工作，把table指向nextTable,并更新sizeCtl为数组大小的0.75倍，扩容完成。</li>
</ol>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h3 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h3><p>CAS有3个操作数，内存值V，就的预期值A，要修改的新值B。当且晋档预期值A和内存值V相同时，将V修改为B，否则什么都不做。</p>
<p><strong>非阻塞算法</strong><br>一个线程的失败或则挂起不应该影响其他线程的失败或挂起算法。</p>
<p>#concurrent包的实现</p>
<p>由于java的CAS同时具有volatile读和volatile写的内存语义，因此java线程之间的通信现在有了下面四中方式：</p>
<ol>
<li>A线程写Volatile变量，随后B线程读这个Volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p><strong>concurrent包的源码实现，通用的实现模式</strong></p>
<ol>
<li>首先，声明共享变量为volatile</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步</li>
<li>同时，配合以Volatile的读/写和CAS所具有的的volatile读写的内存语义来实现线程之间的通信</li>
</ol>
<p><strong>从整体来看，concurrent包的实现示意图</strong></p>
<p><img src="pictures/concurrent实现示意图.png" alt="concurrent包的实现示意图"></p>
<h1 id="非阻塞同步算法与CAS（Compare-and-Swap）无锁算法"><a href="#非阻塞同步算法与CAS（Compare-and-Swap）无锁算法" class="headerlink" title="非阻塞同步算法与CAS（Compare and Swap）无锁算法"></a>非阻塞同步算法与CAS（Compare and Swap）无锁算法</h1><h2 id="锁的代价"><a href="#锁的代价" class="headerlink" title="锁的代价"></a>锁的代价</h2><p>锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。</p>
<p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用独占的方式来访问这些变量，如果出现多个线程同时访问锁，那第一些线线程将被挂起，当线程恢复执行时，必须等待其它线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>
<p><strong>java中乐观锁和悲观锁</strong><br>悲观锁:一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放.</p>
<p>乐观锁:一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作.</p>
<p><strong>有两种方式来保证乐观锁最后同步数据保证它原子性的方法乐观锁是有一定的不安全性的</strong></p>
<p>1,CAS方式:Java非公开API类Unsafe实现的CAS(比较-交换),由C++编写的调用硬件操作内存,保证这个操作的原子性,concurrent包下很多乐观锁实现使用到这个类,但这个类不作为公开API使用,随时可能会被更改.我在本地测试了一下,确实不能够直接调用,源码中Unsafe是私有构造函数,只能通过getUnsafe方法获取单例,首先去掉eclipse的检查(非API的调用限制)限制以后,执行发现报 java.lang.SecurityException异常,源码中getUnsafe方法中执行访问检查,看来java不允许应用程序获取Unsafe类. 值得一提的是反射是可以得到这个类对象的.</p>
<p>2,加锁方式:利用Java提供的现有API来实现最后数据同步的原子性(用悲观锁).看似乐观锁最后还是用了悲观锁来保证安全,效率没有提高.实际上针对于大多数只执行不同步数据的情况,效率比悲观加锁整个方法要高.特别注意:针对一个对象的数据同步,悲观锁对这个对象加锁和乐观锁效率差不多,如果是多个需要同步数据的对象,乐观锁就比较方便</p>
<h2 id="volatile的问题"><a href="#volatile的问题" class="headerlink" title="volatile的问题"></a>volatile的问题</h2><p>与锁相比，volatile变量是一种和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量。</p>
<p><strong>volatile只能保证变量对各个线程的可见性，但不能保证原子性</strong></p>
<p><strong>1. 内存屏障</strong></p>
<p>内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>
<p><strong>volatile为什么没有原子性</strong></p>
<p>如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
<p>从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失</p>
<p><strong>java中的原子操作</strong></p>
<ol>
<li>除long和double之外的所有原始类型的赋值</li>
<li>所有引用类型的赋值</li>
<li>java.concurrent.Atomic.* 包中所有类的一切操作</li>
<li>被volatile修饰的long型和double型数据的赋值</li>
</ol>
<p>java中的long型赋值分两步操作，先写32位，再厚些32.这样线程就不安全了。</p>
<h2 id="CAS无锁算法"><a href="#CAS无锁算法" class="headerlink" title="CAS无锁算法"></a>CAS无锁算法</h2><p>要实现无锁（lock-free）的非阻塞算法有多种实现方法，其中CAS（比较与交换，Compare and swap）是一种有名的无锁算法。<br>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p><img src="pictures/CAS.png" alt="CAS"></p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/06/concurrentHashMap源码解析/" data-id="cjuajt8ky000bfcampgp08ns2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ArrayList与LInkedlist" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/ArrayList与LInkedlist/" class="article-date">
  <time datetime="2019-03-02T06:09:02.514Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h1><h2 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h2><h3 id="1-1-ArrayList-概述"><a href="#1-1-ArrayList-概述" class="headerlink" title="1.1 ArrayList 概述"></a>1.1 ArrayList 概述</h3><p><kbd>ArrayList是基于数组实现的，是一个动态数组，其容量自动增长。实现了所有可选列表操作，并允许包括null在内的所有元素。</kbd></p>
<p>每个ArrayList实例都有一个容量，该容量是只用来存储列表元素数组的大小，它总是至少等于列表的大小。随着向ArrayList中不断添加元素，该容量也自动增长。自动增长会带来数据项数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这样可以减少递增式再分配的数量。</p>
<p>ArrayList不是线程安全的，只能在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p>
<p>ArrayList实现了Serializable接口，因此它支持序列化，能够序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能够被克隆。</p>
<h3 id="1-2-ArrayList的实现"><a href="#1-2-ArrayList的实现" class="headerlink" title="1.2 ArrayList的实现"></a>1.2 ArrayList的实现</h3><p><strong>1. 私有属性</strong><br>ArrayList定义两个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//对象数组：ArrayList的底层数据结构</span><br><span class="line">     transient Object[] elementData;</span><br><span class="line">    //elementData中已存放的元素的个数，注意：不是elementData的容量</span><br><span class="line">    private int size;</span><br></pre></td></tr></table></figure></p>
<p><strong>transient</strong></p>
<p>java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它，为了在一个特定对象的一个域上关闭serialization可以在这个域前面加上关键字transient</p>
<p>上面的elementData属性采用了transient来修饰，表明其不使用Java默认的序列化机制来实例化，但是该属性是ArrayList的底层数据结构，在网络传输中一定需要将其序列化，之后使用的时候还需要反序列。ArrayList自己实现了序列化和反序列化</p>
<p><strong>2.构造方法</strong><br>ArrayList提供了三种构造方法：可以构造一个默认初始容量为10 的空列表，构造一个指定初始容量的空列表，以及构造一个包含指定collection的列表元素，这些元素按照该collection的迭代器返回它们的顺序排列的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       if (initialCapacity &gt; 0) &#123;</span><br><span class="line">           this.elementData = new Object[initialCapacity];</span><br><span class="line">       &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">           this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    </span><br><span class="line"></span><br><span class="line">   //构造函数二，使用默认的DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值</span><br><span class="line">       public ArrayList() &#123;</span><br><span class="line">       this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //构造一个传入的集合，作为数组的数据</span><br><span class="line">       public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       if ((size = elementData.length) != 0) &#123;</span><br><span class="line">           // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">           if (elementData.getClass() != Object[].class)</span><br><span class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // replace with empty array.</span><br><span class="line">           this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.添加方法</strong><br>ArrayList提供了set(int index ,E element),add(E e),add(int index,E element),addAll(Collection&lt;?extends E&gt; c),addAll(int index,Collection&lt;? extends E&gt; c)这些添加元素的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span><br><span class="line"> public E set(int index, E element) &#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line"></span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">    elementData[index] = element;  </span><br><span class="line">    return oldValue;  </span><br><span class="line"> &#125;    </span><br><span class="line">// 将指定的元素添加到此列表的尾部。  </span><br><span class="line"> public boolean add(E e) &#123;  </span><br><span class="line">    ensureCapacity(size + 1);   </span><br><span class="line">    elementData[size++] = e;  </span><br><span class="line">   return true;  </span><br><span class="line"> &#125;    </span><br><span class="line"> // 将指定的元素插入此列表中的指定位置。  </span><br><span class="line"> // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span><br><span class="line"> public void add(int index, E element) &#123;  </span><br><span class="line">    if (index &gt; size || index &lt; 0)  </span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size);  </span><br><span class="line">   // 如果数组长度不足，将进行扩容。  </span><br><span class="line">    ensureCapacity(size+1);  // Increments modCount!!  </span><br><span class="line">    // 将 elementData中从Index位置开始、长度为size-index的元素，  </span><br><span class="line">   // 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span><br><span class="line">   // 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span><br><span class="line">   System.arraycopy(elementData, index, elementData, index + 1, size - index);  </span><br><span class="line">   elementData[index] = element;  </span><br><span class="line">    size++;  </span><br><span class="line"> &#125;    </span><br><span class="line"> // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span><br><span class="line"> public boolean addAll(Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">   Object[] a = c.toArray();  </span><br><span class="line">   int numNew = a.length;  </span><br><span class="line">  ensureCapacity(size + numNew);  // Increments modCount  </span><br><span class="line">   System.arraycopy(a, 0, elementData, size, numNew);  </span><br><span class="line">   size += numNew;  </span><br><span class="line">  return numNew != 0;  </span><br><span class="line"> &#125;    </span><br><span class="line"> // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span><br><span class="line"> public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">   if (index &gt; size || index &lt; 0)  </span><br><span class="line">        throw new IndexOutOfBoundsException(  </span><br><span class="line">            &quot;Index: &quot; + index + &quot;, Size: &quot; + size);  </span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">   int numNew = a.length;  </span><br><span class="line">    ensureCapacity(size + numNew);  // Increments modCount  </span><br><span class="line"></span><br><span class="line">    int numMoved = size - index;  </span><br><span class="line">    if (numMoved &gt; 0)  </span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </span><br><span class="line">    System.arraycopy(a, 0, elementData, index, numNew);  </span><br><span class="line">    size += numNew;  </span><br><span class="line">    return numNew != 0;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Add（E  element）分析</strong></p>
<p>这里一步步分析，在调用了add(E e)的方法第一步，我们看到了它调用了ensureCapacityInternal(size + 1)方法，在这个方法里面首先判断了数组是不是一个长度为0的空数组，如果是的话就给它容量赋值为默认的容量大小也就是10，然后调用了ensureExplicitCapacity方法，这个方法里面记录了modCount+1之后，并判断了当前的容量是否大于数组当前的长度，如果大于当前数组的长度就开始进行扩容操作调用方法 grow(minCapacity)，扩容的长度是增加了原来数组数组的一半大小，然后并判断了是否达到了数组扩容的上限并赋值，接着把旧数组的数据拷贝到扩容后的新数组里面再次赋值给旧数组，最后把新添加的元素赋值给了扩容后的size+1的位置里面。</p>
<p><strong>Add（int index ，E element）分析</strong></p>
<p>这里面主要是给指定位置添加一个元素，ArrayList首先检查是否索引越界，如果没有越界，就检查是否需要扩容，然后将index位置之后的所有数据，整体拷贝到index+1开始的位置，然后就可以把新加入的数据放到index这个位置，而index前面的数据不需要移动，在这里我们可以看到给指定位置插入数据ArrayList是一项大动作比较耗性能。</p>
<p><strong>4.移除</strong></p>
<ol>
<li><p>根据下标移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        //检查是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        //记录修改次数</span><br><span class="line">        modCount++;</span><br><span class="line">        //获取移除位置上的值</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        //获取要移动元素的个数</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">        //拷贝移动的所有数据到index位置上</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        //把size-1的位置的元素赋值null，方便gc</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">        //最终返回旧的数据</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据元素移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">、</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    //等于null值的移除</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">         //遍历数组</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">            //找到集合里面第一个等于null的元素</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                //然后移除</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //非null情况下，遍历每一个元素通过equals比较</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                //然后移除</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //该方法与通过下标移除的原理一样，整体左移</span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。</strong><br><strong>5.查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">      //检查是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        //返回指定位置上的元素</span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>6.修改</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    //检查是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        //获取旧的元素值</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        //新元素赋值</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        //返回旧的元素值</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>ArrayList总体来说比较简单，不过ArrayList还有以下一些特点：</p>
<p>ArrayList自己实现了序列化和反序列化的方法，因为它自己实现了<br>private void writeObject(java.io.ObjectOutputStream s)和 private void readObject(java.io.ObjectInputStream s) 方法</p>
<p>ArrayList基于数组方式实现，无容量的限制（会扩容）</p>
<p>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量，trimToSize()），删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。</p>
<p>线程不安全</p>
<p>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</p>
<p>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</p>
<p>remove(Object o)需要遍历数组</p>
<p>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</p>
<p>contains(E)需要遍历数组</p>
<p>使用iterator遍历可能会引发多线程异常</p>
<h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><p><strong>LinkedList实现原理总结</strong></p>
<ol>
<li>数据存储是基于双向链表实现的。</li>
<li>插入数据很快。先是在双向链表中找到要插入节点的位置index，找到之后再插入一个新节点。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找；否则，从后向前查找。</li>
<li>删除数据很快。先是在双向链表中找到要插入节点的位置index，找到之后，进行如下操作：node.previous.next = node.next;node.next.previous = node.previous; node =null.查找节点过程和插入一样。</li>
<li>获取数据很慢，需要从head节点进行查找。</li>
<li>遍历数据很慢，每次获取数据都需要从头开始。</li>
</ol>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>LinkedList底层是基于双向链表实现的，链表在内存中是不连续的，而是通过引用来关联所有的元素，所以链表的优点在于添加和删除元素比较快，因为只是移动指针，并且不需要判断是否扩容，缺点是查询和遍历效率比较低</p>
<p><strong>2.1 类结构</strong></p>
<p>LinkedList底层是双链表，实现了list接口可以有队列操作，实现了Deque接口可以有双端队列操作，实现了所有可选的list操作并且允许存储任何元素，包括Null</p>
<p>所有的操作都体现了双链表的结构，所以进入List的操作从头开始或则结尾遍历List，无论任何一个指定的索引</p>
<p>注意：这些实现都是不同步的，意味着线程不安全，如果有多个线程同时访问双链表，至少有一个线程在结构上修改了list，name必须在外部加上同步操作（synchronized）(所谓结构化修改是指增加或则修改一个元素或则多个元素，重新设置元素的值不是结构化修改)，通常通过自然地同步一些对象来封装List来完成</p>
<p>如果没有这样的对象存在，name应该使用Collections.synchronizedList来封装链表。最好是在创建时完成，以防止意外的对链表进行非同步的访问。</p>
<p>此类迭代器和迭代方法返回的迭代器是快速失败的：如果链表在迭代器被创建后的任何时间呗结构化修改，除非是通过迭代器的remove或则add方法操作的，否则将抛出concurrentModificationException异常</p>
<p><strong>注意</strong><br>迭代器快速失败的行为不能保证，一把来说，在存在并发修改的情况下不能确保任何的承诺，快速失败的迭代器尽最大努力抛出异常。因此，编写依赖于此异常的程序的方式是错误的。<br>迭代器的快速失败行为应该仅用于错误检测。</p>
<p><strong>成员变量和构造方法</strong></p>
<ol>
<li><p>LinkedList的核心数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">       E item;        //当前节点</span><br><span class="line">       Node&lt;E&gt; next;  //下一个节点</span><br><span class="line">       Node&lt;E&gt; prev;  //上一个节点</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item = element;</span><br><span class="line">           this.next = next;</span><br><span class="line">           this.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量和构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;      //当前存储元素的个数</span><br><span class="line"></span><br><span class="line">    transient Node&lt;E&gt; first; //首节点</span><br><span class="line"></span><br><span class="line">    transient Node&lt;E&gt; last  ;//末节点</span><br><span class="line"></span><br><span class="line">    //无参数构造方法</span><br><span class="line">    public LinkedList() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //有参数构造方法</span><br><span class="line">    public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看出LinkedList有两个构造方法，一个有参，一个无参，一个有参的够着函数的功能是通过一个集合参数并把里面所有的元素给插入到LinkedList中，注意这里之所以说是插入，而不是说初始化添加，因为LinkedList并非线程安全，完全有可能在this()方法调用之后，后面有其他线程向里面插入了数据</p>
<p><strong>2.3 常用方法</strong></p>
<ol>
<li>addAll方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//在链表的尾端追加指定集合的所有元素，按指定的迭代器的集合顺序返回，在这个操作执行总是如果指定的集合被修改了，那么该行为操作将提示未定义</span><br><span class="line"></span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"></span><br><span class="line">	 //检查index是否越界，index=size+1</span><br><span class="line"></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    //  将集合参数转化为数组</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;             //要插入的集合长度</span><br><span class="line">    if (numNew == 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">                                      // 定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line"></span><br><span class="line">                                      //这里为什么要写if..else？</span><br><span class="line"></span><br><span class="line">                                       //因为该方法不一定是从上层方法addAll(size, c)过来的，还有可能是直接调用了addAll(int index, Collection&lt;? extends E&gt; c)</span><br><span class="line">                                        方法，从上层addAll(size, c)跳转过来的，size=index也就从尾部插入，但是直接调用的该方法，则从传进来的参数index这个位置（肯能是任何位置）插入</span><br><span class="line"></span><br><span class="line">    if (index == size) &#123;             //表明是从尾部插入</span><br><span class="line">        succ = null;                 //从尾部插入，后置节点为null</span><br><span class="line">        pred = last;                 //从尾部插入，前置节点为当前LinkedList中的最后一个节点</span><br><span class="line">    &#125; else &#123;                         //表明不是从尾部插入</span><br><span class="line">        succ = node(index);          //查到当前LinkedList中位置为index的节点并把它赋给要插入元素的后置节点</span><br><span class="line">        pred = succ.prev;            //把上一步得到的节点的前置节点赋值给要插入元素的后置节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Object o : a) &#123;             //变量集合参数</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">        if (pred == null)            //说明插入之前当前链表是空链表</span><br><span class="line">            first = newNode;         //新节点是第一个节点</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;    //设置插入元素的的前置节点的后置节点为新节点</span><br><span class="line">        pred = newNode;             //更改指向后将新节点对象赋给pred作为下次循环中新插入节点的前一个对象节点，依次循环</span><br><span class="line">    &#125;</span><br><span class="line">                                   //此时pred代表集合元素的插入完后的最后一个节点对象</span><br><span class="line">    if (succ == null) &#123;           //结尾添加的话在添加完集合元素后将最后一个集合的节点对象pred作为last</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pred.next = succ;         //将集合元素的最后一个节点对象的next指针指向原index位置上的Node对象</span><br><span class="line">        succ.prev = pred;         //将原index位置上的pred指针对象指向集合的最后一个对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;              //修改当前元素的数量</span><br><span class="line">    modCount++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Returns the (non-null) Node at the specified element index.</span><br><span class="line"> * 返回index位置的非空节点</span><br><span class="line"> * 折半查询</span><br><span class="line"> */</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 如果index小于当前元素个数的一半，则从前向后遍历查询 ，否则从后向前遍历查询</span><br><span class="line">     */</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>这里面主要用了两个方法：</strong></p>
<p><strong>1.addAll(int index,Collection&lt;? extends E&gt; c),这里面首先是会判断是否会出现索引越界，然后定义pred和succ两个Node对象，用于标识要插入元素的前置节点和后置节点</strong><br><strong>2.node(int index):这个方法的主要功能是找到index位置的Node节点，源码上利用责办查询进行优化，即使这样，遍历和查询效率还是比较差</strong></p>
<ol start="2">
<li>add方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line"></span><br><span class="line">	  // 获取当前链表的最后一个节点</span><br><span class="line"></span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line"></span><br><span class="line">   // 创建一个以当前最后一个节点为之前节点的节点</span><br><span class="line"></span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line"></span><br><span class="line">     // 空表，首次插入</span><br><span class="line"></span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;//不是首次插入，则最后一个节点的后置节点地址赋值给新节点</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到add方法每次都会把新增节点放在链表的最后一位，正因为放在链表的末位，所以链表的添加性能可以看成O(1)操作</strong></p>
<ol start="3">
<li>remove方法<br>移除方法主要有两个：</li>
</ol>
<p>(1). 根据元素移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 从第一个节点循环指针查找</span><br><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    //如果移除的数据为Null</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        //遍历找到第一个为null的节点，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //遍历找到第一条不为null与参数相等的数据，然后移除掉</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    // assert x != null;</span><br><span class="line">	  // 移除的数据</span><br><span class="line">    final E element = x.item;</span><br><span class="line">    //移除节点的后置节点</span><br><span class="line">    final Node&lt;E&gt; next = x.next;</span><br><span class="line">    //移除节点的前置节点</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    if (prev == null) &#123;  //前一个节点为null  说明要删除的节点就是 头结点</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next == null) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）. 根据索引移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>从上面的源码可以看出根据index移除 里面调用了node(index)方法来查找需要移除的节点，而根据Object移除的时候，则是进行了整个链表的遍历，然后再卸载节点。</strong><br><strong>除此之外链表还有没有任何参数的remove，removeFirst，removeLast方法，其中remove方法本质是调用了removeFirst方法</strong><br><strong>这里能够总结出链表基于首尾节点的删除可以看成O(1)操作，而非首尾的删除最坏的情况下能够达到O(n)操作，因为要遍历查询指定节点，所以性能较差</strong></p>
<ol start="4">
<li>get方法<br>get系的方法有三个：分别是get(index),getFirst(),getLast()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);//是否越界</span><br><span class="line">        return node(index).item;//折半遍历查询</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>get(index)方法本质调用了node(index),这个方法的性能O(n),其他的getFirst和getLast为O(1)</strong></p>
<ol start="5">
<li>set方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index);   //检查是否越界</span><br><span class="line">    Node&lt;E&gt; x = node(index);    //折半查询索引为index的节点</span><br><span class="line">    E oldVal = x.item;          //查询index节点原来的数据值</span><br><span class="line">    x.item = element;           //将新值插入</span><br><span class="line">    return oldVal;              //返回旧值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>set方法依旧是调用的node方法，所以链表在指定位置更新数据，性能也一般</strong></p>
<ol start="6">
<li>clear()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">         //遍历所有的数据，置位null      </span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = null;</span><br><span class="line">            x.next = null;</span><br><span class="line">            x.prev = null;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = null;</span><br><span class="line">        size = 0;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>clear方法比较简单，就是所有的节点的数据置位null，方便垃圾回收</strong></p>
<ol start="7">
<li>toArray方法分析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">      //声明长度一样的数组</span><br><span class="line">        Object[] result = new Object[size];</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            result[i++] = x.item;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>声明一个长度一样的数组，依次遍历所有数据放入数组</strong></p>
<ol start="8">
<li>序列化和反序列化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//序列化</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        //先写入大小</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        //再依次遍历链表写入字节流中</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">            s.writeObject(x.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反序列化</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in any hidden serialization magic</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">         //先读取大小</span><br><span class="line">        int size = s.readInt();</span><br><span class="line">        //再依次读取元素，每次都追加到链表末尾</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            linkLast((E)s.readObject());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>这里我们看到链表中也自定义了序列化和反序列化的方法，在序列化时只写入x.item而并不是整个Node，这样做避免java自带的序列化机制会把整个Node的数据给写入序列化，并且如果Node还是双端链表的数据结构，那么无疑会导致重复两倍的空间浪费。</strong></p>
<p><strong>在反序列化时我们看到先读取size，然后根据size依次循环读取item，并重新生成双端链表的数据结构，依次追加到链表的尾部。</strong></p>
<p>#ArrayList和LinkedList的区别</p>
<ol>
<li>ArrayList是基于动态数组的数据结构，每个元素在内存中存储地址时连续的；LinkedList是是基于链表的额数据结构，每个元素内容包括 上一个节点，当前节点的值，下一个节点，也是由于这一性质支持了每个元素在内存中的分布存储。</li>
<li>为了使得突破动态长度数组而衍生的ArrayList初始容量为10，每次扩容会固定为之前的1.5倍，所以当你ArrayList达到一定量之后回事一种很大的浪费，并且每次扩容的过程是内部数组复制到新数组；LinkedList的每一个元素都需要消耗一定的空间</li>
<li>对于每个元素的检索，ArrayList要优于LinkedList。因为ArrayList从一定意义上来说，就是复杂的数组，所以基于数组index的检索性能显然要高于通过for循环来查找每个元素的LinkedList。</li>
<li><p>元素的插入删除的效率对比，要视插入删除的位置来分析，各有优劣</p>
<pre><code>在列表首位添加（删除）元素，LinkedList性能远远优于ArrayList，原因在于ArrayList要后移（前移）每个元素的索引和数组扩容（删除元素时则不需要扩容）
而LinkedList则直接增加元素，修改原第一个元素节点的上一个节点即可，删除同理。
</code></pre></li>
</ol>
<p>在列表中间删除（添加）元素，总的来说位置越靠前LinkedList性能优于ArrayList。</p>
<p>在列表末位删除（添加）元素，新歌能相差不大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/02/ArrayList与LInkedlist/" data-id="cjuajt8rx000hfcamz2wjhncb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JDK8新特性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/01/JDK8新特性/" class="article-date">
  <time datetime="2019-03-01T08:26:38.031Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h2 id="1-接口新特性"><a href="#1-接口新特性" class="headerlink" title="1.接口新特性"></a>1.接口新特性</h2><p>在jdk8环境中，接口中的方法不再只能有抽象方法，他可以有静态方法和default方法，所谓default方法即是使用default关键字来修饰的方法，一个接口中可以有多个静态方法和default方法，没有个数限制。实现类只需要实现接口的抽象方法。</p>
<p><strong>示例代码：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface DefalutTest &#123;</span><br><span class="line">    static int a =5;</span><br><span class="line">    default void defaultMethod()&#123;</span><br><span class="line">        System.out.println(&quot;DefalutTest defalut 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sub(int a,int b);</span><br><span class="line"></span><br><span class="line">    static void staticMethod() &#123;</span><br><span class="line">        System.out.println(&quot;DefalutTest static 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><kbd>接口里的静态方法，即static修饰的有方法体的方法不会被继承或则实现，但是静态变量会被继承。default方法可以被子接口继承，也可以被其实现类所调用，当default方法被继承时，可以被子接口覆写</kbd></p>
<p><strong>关于静态方法和default的调用</strong></p>
<ol>
<li>对于静态方法，没有什么特殊的地方，此方法既不能被其子接口调用，也不能被其实现类调用，静态方法只能被自身调用。</li>
<li>对于default方法，需要有实例的对象来调用，但是要注意的是：java中是单继承的，但可以实现多个接口，当一个类实现了多个接口之后，如果多个没有继承关系接口有着相同的default方法，即方法名和参数列表相同，这个时候就需要在实现类里面显示重写default方法，且必须通过特殊语法指定实现类要实现哪个接口中的default方法<br><strong>特殊语法：&lt;接口&gt;.super.&lt;方法名&gt;([参数])</strong></li>
</ol>
<p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SubTestImp implements SubTest,DefalutTest&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int sub(int a, int b) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return a-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void defaultMethod() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        DefalutTest.super.defaultMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>重写的default方法必须的访问权限是public，因为default方法畜类没有显示的访问修饰符外，只能用public访问限定符来修饰，而在java中，要重写一个方法，访问限定符一定要大于父类或则接口指定的访问限定符范围，而且方法声明处抛出的异常也要大于后者，所以访问权限必须是public。左后当default方法和实现类继承的父类的方法名相同时，优先调用父类方法。</strong></p>
<p><strong>默认方法的优势</strong></p>
<ol>
<li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。假如我们有一个已经投入使用接口需要拓展一个新的方法，在jdk8以前，如果我们使用接口增加一个方法，则我们必须在所有实现类中添加该方法的实现，否则编译器会出现异常。如果实现类数量少并且我们有权限修改，可能会工作量较少。如果实现类或则我们没有权限修改实现类源代码，这样可能就比较麻烦。而默认方法则解决了这个问题，它提供了一个实现，当没有秀按时提供其他实现时就采用这个实现。这样新添加的方法就不会破坏现有代码。</li>
<li>默认方法的另一个优势是该方法是可选的，子类可以根据不同的需求Override默认方法</li>
</ol>
<h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h2><p>Lambda表达式可以看成是匿名内部类，使用Lambda表达式时，接口必须是函数式接口</p>
<p><strong>函数式接口</strong></p>
<p>能够接收Lambda表达式的参数类型，是一个只包含一个方法的接口。</p>
<p><strong>基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数式接口&gt;  &lt;变量名&gt; = (参数1，参数2...) -&gt; &#123;</span><br><span class="line">                  //方法体</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>（参数1，参数2）表示参数列表；–&gt;表示连接符；{}内部是方法体</p>
<ol>
<li>=右边的类型会根据左边函数式接口类型自行推断</li>
<li>如果形参列表为空，只保留()</li>
<li>如果形参只有一个，（）可以省略，只需要参数名称即可</li>
<li>如果执行语句只有1句，且无返回值，{}可以省略，若有返回值，则若想省去{}，则必须同时省略return，且执行语句也只保证只有一句</li>
<li>形参列表的数据类型会自动推断</li>
<li>Lambda不会生成一个单独的内部类文件</li>
<li>lambda表达式若访问局部变量，则局部变量必须是final的，若是局部变量没有加final，系统会自动添加，此后在修改该局部变量，会报错。</li>
</ol>
<p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public interface LambdaTest &#123;</span><br><span class="line"></span><br><span class="line">    abstract void print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface LambdaTest2 &#123;</span><br><span class="line"></span><br><span class="line">    abstract void print(String a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface DefalutTest &#123;</span><br><span class="line"></span><br><span class="line">    static int a =5;</span><br><span class="line">    default void defaultMethod()&#123;</span><br><span class="line">        System.out.println(&quot;DefalutTest defalut 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sub(int a,int b);</span><br><span class="line"></span><br><span class="line">    static void staticMethod() &#123;</span><br><span class="line">        System.out.println(&quot;DefalutTest static 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //匿名内部类--java8之前的实现方式</span><br><span class="line">        DefalutTest dt = new DefalutTest()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int sub(int a, int b) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                return a-b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //lambda表达式--实现方式1</span><br><span class="line">        DefalutTest dt2 =(a,b)-&gt;&#123;</span><br><span class="line">            return a-b;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(dt2.sub(2, 1));</span><br><span class="line"></span><br><span class="line">        //lambda表达式--实现方式2，省略花括号</span><br><span class="line">        DefalutTest dt3 =(a,b)-&gt;a-b;</span><br><span class="line">        System.out.println(dt3.sub(5, 6));</span><br><span class="line"></span><br><span class="line">        //测试final</span><br><span class="line">        int c = 5;</span><br><span class="line">        DefalutTest dt4 =(a,b)-&gt;a-c;</span><br><span class="line">        System.out.println(dt4.sub(5, 6));</span><br><span class="line"></span><br><span class="line">        //无参方法，并且执行语句只有1条</span><br><span class="line">        LambdaTest lt = ()-&gt; System.out.println(&quot;测试无参&quot;);</span><br><span class="line">        lt.print();</span><br><span class="line">        //只有一个参数方法</span><br><span class="line">        LambdaTest2 lt1 = s-&gt; System.out.println(s);</span><br><span class="line">        lt1.print(&quot;有一个参数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda表达式的其他特性"><a href="#Lambda表达式的其他特性" class="headerlink" title="Lambda表达式的其他特性"></a>Lambda表达式的其他特性</h3><p><strong>1.引用实例方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数式接口&gt;  &lt;变量名&gt; = &lt;实例&gt;::&lt;实例方法名&gt;</span><br><span class="line">    //调用</span><br><span class="line">    &lt;变量名&gt;.接口方法([实际参数...])</span><br></pre></td></tr></table></figure></p>
<p>将调用方法时传递的实际参数，全部传递给应用的方法，执行引用的方法</p>
<p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LambdaTest2 lt1 = s-&gt; System.out.println(s);</span><br><span class="line">        lt1.print(&quot;有一个参数&quot;);</span><br><span class="line"></span><br><span class="line">        //改写为：</span><br><span class="line">        LambdaTest2 lt2 = System.out::println;</span><br><span class="line">        lt2.print(&quot;实例引用方式调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>引用类方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数式接口&gt;  &lt;变量名&gt; = &lt;类&gt;::&lt;类方法名称&gt;</span><br><span class="line">    //调用</span><br><span class="line">    &lt;变量名&gt;.接口方法([实际参数...])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface LambdaTest3 &#123;</span><br><span class="line"></span><br><span class="line">     abstract void sort(List&lt;Integer&gt; list,Comparator&lt;Integer&gt; c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt;  list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(50);</span><br><span class="line">        list.add(18);</span><br><span class="line">        list.add(6);</span><br><span class="line">        list.add(99);</span><br><span class="line">        list.add(32);</span><br><span class="line">        System.out.println(list.toString()+&quot;排序之前&quot;);</span><br><span class="line">        LambdaTest3 lt3 = Collections::sort;</span><br><span class="line">        lt3.sort(list, (a,b) -&gt; &#123;</span><br><span class="line">            return a-b;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list.toString()+&quot;排序之后&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>引用类的实例方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义接口</span><br><span class="line">   interface &lt;函数式接口&gt;&#123;</span><br><span class="line">       &lt;返回值&gt; &lt;方法名&gt;(&lt;类&gt;&lt;类名称&gt;,[其他参数...]);</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;函数式接口&gt;  &lt;变量名&gt; = &lt;类&gt;::&lt;类实例方法名&gt;</span><br><span class="line">   //调用</span><br><span class="line">   &lt;变量名&gt;.接口方法(类的实例,[实际参数...])</span><br></pre></td></tr></table></figure></p>
<p><strong>示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaClassTest &#123;</span><br><span class="line"></span><br><span class="line">    public int add(int a, int b)&#123;</span><br><span class="line">        System.out.println(&quot;LambdaClassTest类的add方法&quot;);</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface LambdaTest4 &#123;</span><br><span class="line"></span><br><span class="line">    abstract int add(LambdaClassTest lt,int a,int b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LambdaTest4 lt4 = LambdaClassTest::add;</span><br><span class="line">        LambdaClassTest lct = new LambdaClassTest();</span><br><span class="line">        System.out.println(lt4.add(lct, 5, 8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>如果一个接口只有一个抽象方法，则该接口称之为函数式接口，因为默认方法不算抽象方法，所以可以给函数式接口添加默认方法。</p>
<p>函数式接口可与使用Lambda表达式，Lambda表达式会被匹配到这个抽象方法上，我们可以你讲lambda表达式当做任意只包含一个抽象方法的接口类型，确保你的接口一定要达到这个要求，你只需要给你的额借口添加@FunctionalInterface注解，编译器如果发现你标注了这个注解的接口有多余一个抽象方法的时候就会报错。</p>
<h2 id="Lambda作用域"><a href="#Lambda作用域" class="headerlink" title="Lambda作用域"></a>Lambda作用域</h2><p>在Lambda表达式中访问外层作用域和匿名内部类对象的方式很相似。你可以直接访问标记了final的外部局部变量，或则实例的字段以及静态变量。</p>
<p>我们可以直接在lambda表达式中访问外层的局部变量，但是该局部变量必须是final的，即使没有加final关键字，之后我们无论在哪（lambda表达式内部或外部）修改该变量，均报错。</p>
<h2 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h2><p> <strong>Predicate接口</strong></p>
<p> Predicate接口只有一个参数，返回boolean类型。该接口包含多种默认方法来讲Predicate组合成其他复杂的逻辑（比如：与，或，非）。该接口包含一个抽象方法，3个默认方法以及一个静态方法，抽象方法为test。</p>
<p> <strong>示例代码</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line">        System.out.println(predicate.test(&quot;foo&quot;));              // true</span><br><span class="line">        System.out.println(predicate.negate().test(&quot;foo&quot;));     // false</span><br><span class="line">        Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">        Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line">        Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">        Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line">        System.out.println(nonNull.test(null));</span><br><span class="line">        System.out.println(isNull.test(null));</span><br><span class="line">        System.out.println(isEmpty.test(&quot;sss&quot;));</span><br><span class="line">        System.out.println(isNotEmpty.test(&quot;&quot;));</span><br></pre></td></tr></table></figure></p>
<p><strong>Function接口</strong><br>Function接口有一个参数并返回一个结果，并附带了一些可以和其他函数组合的默认方法</p>
<p><strong>示例方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">        System.out.println(toInteger.apply(&quot;123&quot;).getClass());</span><br><span class="line">        Function&lt;String, Object&gt; toInteger2 = toInteger.andThen(String::valueOf);</span><br><span class="line">        System.out.println(toInteger2.apply(&quot;123&quot;).getClass());</span><br></pre></td></tr></table></figure></p>
<p><strong>Consumer消费型函数式接口</strong><br>代表了接受一个输入参数并且无返回的操作</p>
<p><strong>accept方法使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void modifyTheValue3(int value, Consumer&lt;Integer&gt; consumer) &#123;</span><br><span class="line">       consumer.accept(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       // (x) -&gt; System.out.println(x * 2)接受一个输入参数x</span><br><span class="line">       // 直接输出，并没有返回结果</span><br><span class="line">       // 所以该lambda表达式可以实现Consumer接口</span><br><span class="line">       modifyTheValue3(3, (x) -&gt; System.out.println(x * 2));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Comparator接口</strong></p>
<p>Comparator是java中的经典接口，java8在此之上添加了多种默认方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</span><br><span class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</span><br><span class="line">comparator.compare(p1, p2);                    // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);         // &lt; 0</span><br></pre></td></tr></table></figure></p>
<p><strong>Optional接口</strong></p>
<p>Optional不是函数式接口，这个是用来防止NullPointerException异常的辅助类型。<br>Optional被定义为一个简单的容器，其值可能是null或则不是null。在java8之前一般某个函数应该返回非空对象但是偶尔却可能返回null，而在java 8，不推荐使用null而是返回Optional<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</span><br><span class="line">optional.isPresent();           // true</span><br><span class="line">optional.get();                 // &quot;bam&quot;</span><br><span class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>Stream 接口                          重要</strong></p>
<p><strong>什么是Stream？</strong></p>
<p>Stream是元素的集合，这点让Stream看起来类似Iterator。可以把Stream当成是一个高级版本的IT二胺投入。原始的Iterator，用户只能一个一个的遍历元素并对其执行某些操作，高级版本的Stream，用户只要给出其包含的元素执行什么操作比如“过滤掉大于10的字符串等”，具体这些操作如何应用到每个元素上，Stream可以完成。</p>
<p>首先对Stream的操作可以分为两类，中间操作和结束操作</p>
<ol>
<li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream。</li>
<li>结束操作触发实际计算，计算发生时会把所有的中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>
</ol>
<p>虽然大部分情况下stream是容器动用Collection.stream()方法得到的，但stream和collections有以下不同：</p>
<ol>
<li>无存储。stream不是一种数据结构，它只是某种数据结构的视图，数据源可以使一个数组，java容器或I/O channel等。</li>
<li>为函数式编程而生，对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新的stream</li>
<li>惰式执行。stream上的操作并不会立即执行，只有等到用户正宗需要结果的时候才会执行。</li>
<li>可消费性 stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ol>
<p>java.util.Stream表示能应用在一组元素上一次执行的操作序列</p>
<p>java 8 扩展了集合类，可以通过Collection.stream()或则Collection.parallelStream()来创建一个Stream。Stream有串行和并行两种，串行Stream上的操作是在一个线程中一次完成的，而并行Stream则是在多个线程上同时执行的。</p>
<p>利用串行的Stream可以提升性能</p>
<p><strong>1.Stream方法的使用</strong></p>
<p><strong>获取Stream</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、数组</span><br><span class="line">    String[] arr = new String[]&#123;&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;&#125;;</span><br><span class="line">    Stream&lt;String&gt; arrStream = Arrays.stream(arr);</span><br><span class="line">    // 2、集合</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;);</span><br><span class="line">    Stream&lt;String&gt; colStream = list.stream();</span><br><span class="line">    // 3、值</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>Stream方法的使用</strong></p>
<ol>
<li><p>forEach()使用该方法迭代流中的每个数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testForEach()&#123;</span><br><span class="line">  // java 8 前</span><br><span class="line">  System.out.println(&quot;java 8 前&quot;);</span><br><span class="line">  for(User user: list)&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">  &#125;</span><br><span class="line">  // java 8 lambda</span><br><span class="line">  System.out.println(&quot;java 8 lambda&quot;);</span><br><span class="line">  list.forEach(user -&gt; System.out.println(user));</span><br><span class="line"></span><br><span class="line">  // java 8 stream lambda</span><br><span class="line">  System.out.println(&quot;java 8 stream lambda&quot;);</span><br><span class="line">  list.stream().forEach(user -&gt; System.out.println(user));</span><br></pre></td></tr></table></figure>
</li>
<li><p>sorted()使用该方法排序数据<br>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void testSort() &#123;</span><br><span class="line">    System.out.println(&quot;-----排序前-----&quot;);</span><br><span class="line">    list.forEach(user -&gt; System.out.println(user));</span><br><span class="line">    System.out.println(&quot;-----排序后-----&quot;);</span><br><span class="line">    // java 8 前</span><br><span class="line">    System.out.println(&quot;java 8 前&quot;);</span><br><span class="line">    Collections.sort(list, new Comparator&lt;User&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public int compare(User o1, User o2) &#123;</span><br><span class="line">        return o1.getAge().compareTo(o2.getAge());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (User user : list) &#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    // java 8 stream 方法引用</span><br><span class="line">    System.out.println(&quot;java 8 stream 方法引用&quot;);</span><br><span class="line">    list.stream().sorted(Comparator.comparing(User::getAge)).forEach(user -&gt; System.out.println(user));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter():使用该方法过滤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFilter() &#123;</span><br><span class="line">  // 输出年龄大于50的人</span><br><span class="line">  System.out.println(&quot;-----过滤前-----&quot;);</span><br><span class="line">  list.forEach(user -&gt; System.out.println(user));</span><br><span class="line">  System.out.println(&quot;-----过滤后-----&quot;);</span><br><span class="line">  // java 8 前</span><br><span class="line">  System.out.println(&quot;java 8 前&quot;);</span><br><span class="line">  for(User user: list)&#123;</span><br><span class="line">    if (user.getAge() &gt; 50) &#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // java 8 stream</span><br><span class="line">  System.out.println(&quot;java 8 stream&quot;);</span><br><span class="line">  list.stream().filter((User user) -&gt; user.getAge() &gt; 50).forEach(user -&gt; System.out.println(user));</span><br></pre></td></tr></table></figure>
</li>
<li><p>limit():使用该方法截断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void testLimit() &#123;</span><br><span class="line">    // 从第三个开始截断，只输出前三个</span><br><span class="line">    System.out.println(&quot;-----截断前-----&quot;);</span><br><span class="line">    list.forEach(user -&gt; System.out.println(user));</span><br><span class="line">    System.out.println(&quot;-----截断后-----&quot;);</span><br><span class="line">    // java 8 前</span><br><span class="line">    System.out.println(&quot;java 8 前&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">      System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    // java 8 stream</span><br><span class="line">    System.out.println(&quot;java 8 stream&quot;);</span><br><span class="line">    list.stream().limit(3).forEach(user -&gt; System.out.println(user));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ship():与limit互斥，使用该方法跳过元素</p>
</li>
<li>distinct():使用该方法去重，注意：必须重写对应泛型的hashCode()和equals()方法</li>
<li><p>map():接受一个方法作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">  public void testMap() &#123;</span><br><span class="line">    // 只输出所有人的年龄</span><br><span class="line">    list.stream().forEach(user -&gt; System.out.println(user));</span><br><span class="line">    System.out.println(&quot;映射后-----&gt;&quot;);</span><br><span class="line">    List&lt;Integer&gt; ages = list.stream().map(user -&gt; user.getAge()).collect(toList());</span><br><span class="line">    ages.forEach(age -&gt; System.out.println(age));</span><br><span class="line"></span><br><span class="line">    // 小写转大写</span><br><span class="line">    List&lt;String&gt; words = Arrays.asList(&quot;aaa&quot;, &quot;vvvv&quot;, &quot;cccc&quot;);</span><br><span class="line">    System.out.println(&quot;全部大写----&gt;&quot;);</span><br><span class="line">    List&lt;String&gt; collect = words.stream().map(s -&gt; s.toUpperCase()).collect(toList());</span><br><span class="line">    collect.forEach(s -&gt; System.out.println(s));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flatMap():对每个元素执行mapper指定的操作，并将所有mapper返回的Stream中的元素组成一个新的Stream作为最终的返回结果，通俗易懂就是讲原来的stream中的所有元素都展开组成一个新的stream</p>
</li>
<li>reduce规约</li>
</ol>
<p>这时一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，郭跃后的结果通过Optional接口表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="Date-API"><a href="#Date-API" class="headerlink" title="Date API"></a>Date API</h2><p>java 8在包java.time下包含了一组全新的时间日期API</p>
<p><strong>Clock时钟</strong><br>clock类提供了当前日期和时间的方法，clock是是时区敏感的</p>
<h2 id="java8-支持多重注解"><a href="#java8-支持多重注解" class="headerlink" title="java8 支持多重注解"></a>java8 支持多重注解</h2><p>####内部迭代与外部迭代的区别<br>使用for循环等利用Iterator进行迭代操作，叫做外部迭代，而使用stream流进行的迭代操作叫做内部迭代。内部迭代最明显的好处就是当数据凉很大的情况下，我们不需要对数据进行拆分，并可以调用指定的函数实现并行遍历。</p>
<ol>
<li>首先冲代码复杂度上看，外部迭代将业务条件跟具体遍历的代码混在一起，不如stream方式的迭代容易理解。</li>
<li>外部迭代是串行的而且必须按照集合中的元素的顺序依次进行处理，集合框架无法对控制流进行优化，例如通过排序，并行，短路求值以及惰性求值改善性能。</li>
<li>内部迭代：用户把对操作对象的控制权交还给类库，从而允许类库进行各种各样的优化（乱序执行，惰性求值和并行等等），内部迭代使得外部迭代中不可能实现的优化成为可能。</li>
</ol>
<p>####使用函数式编程的好处</p>
<ol>
<li>减少了（中间）可变量的声明。</li>
<li>能够更好的利用并行</li>
<li>代码更加简洁和可读</li>
</ol>
<p><strong>函数式接口</strong></p>
<p>函数式接口可以为接口添加新方法并且无须考虑向后兼容性问题</p>
<p><strong>Lambda表达式</strong></p>
<p>是一段没有函数名的函数体，可以作为参数直接传递给相关的调用者</p>
<p><strong>Lambda表达式和匿名内部类的区别</strong></p>
<p>使用匿名类与Lambda表达式的一大区别在于关键词的使用。对于匿名内部类，关键词this解读为匿名类，而对于Lambda表达式，关键词this解读为写就Lambda的外部类。<br> Lambda表达式与匿名内部类的另一不同在于两者的变异方法。java编译器编译Lambda表达式并将它们转化为类里面的私有函数</p>
<p> <strong>接口和抽象类的相似性</strong></p>
<p> 1 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</p>
<p> 2 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</p>
<p><strong>接口和抽象类的区别</strong></p>
<p>虽然java 8的接口的默认方法就像抽象类，能够提供方法的实现，但是他们俩仍然是不可相互替代的：</p>
<ol>
<li>接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现，抽象类则完全可以包含普通方法</li>
<li>接口里只能定义静态常量，不能定义普通成员变量，抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li>
<li>接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li>
<li>从设计理念上，接口反映的是“like-a”关系，抽象类反映的是“is-a”关系。</li>
<li>接口里不能包含初始化块，但抽象类里完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类，但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承不足</li>
</ol>
<p><strong>函数式编程是指函数可以作为参数的编程方法，这种编程是以函数思维作为核心，在这种思维的角度去思考问题，这猴子那个编程最重要的基础是Lambda演算，接受函数当做输入和输出</strong><br>优点：</p>
<p>函数式编程：支持闭包和高阶函数，闭包是一种可以起函数的作用并可以如对象般操作的对象；而高阶函数是可以以另一个函数作为输入值来进行编程。支持惰性计算，这就可以在求值需要表达式的值得时候进行计算，而不是固定在变量时计算。还有就是可以用递归作为控制流程。函数式编程所编程出来的代码相对而言少很多，而且更加简洁明了。</p>
<p>缺点：<br>所有的数据都是不可以改变的，严重占据运行资源，导致运行速度也不够快。</p>
<p><strong>面向对象编程，这种编程是把问题看做由对象的属性和对象所进行的行为组成。基于对象的概念，以类作为对象的模板，把类和继承作为构造机制，以对象为中心，来思考并解决问题</strong></p>
<p>面向对象编程：面向对象有三个主要特征，分别是封装性、继承性和多态性。类的说明展现了封装性，类作为对象的模板，含有私有数据和公有数据，封装性能使数据更加安全依赖的就是类的特性，使得用户只能看到对象的外在特性，不能看到对象的内在属性，用户只能访问公有数据不能直接访问到私有数据。类的派生功能展现了继承性，继承性是子类共享父类的机制，但是由于封装性，继承性也只限于公有数据的继承（还有保护数据的继承），子类在继承的同时还可以进行派生。而多态性是指对象根据接收的信息作出的行为的多态，不同对象接收同一信息会形成多种行为。</p>
<p>缺点：为了编写可以重用的代码导致许多无用代码的产生，并且许多人为了面向对象而面向对象导致代码给后期维护带来很多麻烦。</p>
<p><strong>面向接口编程</strong></p>
<p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不难么重要了；而各个对象之间的协作关系则成为系统设计的关键。小道不同类之间的通信，达到各个模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要内容。</p>
<p>接口：应是定义与实现的分离。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/01/JDK8新特性/" data-id="cjuajt8ry000ifcamdtj5wrns" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-‘HashMap底层源码解析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/22/‘HashMap底层源码解析/" class="article-date">
  <time datetime="2019-01-22T08:20:57.000Z" itemprop="datePublished">2019-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/22/‘HashMap底层源码解析/">‘HashMap底层源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HashMap底层源码解析（JDK1-8）"><a href="#HashMap底层源码解析（JDK1-8）" class="headerlink" title="HashMap底层源码解析（JDK1.8）"></a>HashMap底层源码解析（JDK1.8）</h1><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>在讨论哈希表之前，我们先大概了解下其他数据结构的性能</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><pre><code>采用一段连续的存储单元来存储数据。对于指定的下标查找，时间复杂度为O(1);通过给定值进行查找，需要遍历数组，
逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然对于有序数组，则可采用二分查找，可将查找复杂度提高为O(log n)；对于一般的插入删除操作，涉及到数组元素的移动，器平均复杂度为O(n);
</code></pre><h5 id="线性链表："><a href="#线性链表：" class="headerlink" title="线性链表："></a>线性链表：</h5><pre><code>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理节点间的引用即可，时间复杂度为O(1)，而查找
操作需要遍历链表逐一进行比对，复杂度为O(n);
</code></pre><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><pre><code>对一颗相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(log n);
</code></pre><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><pre><code>相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能很高，不考虑哈希冲突的情况下，仅需一次
定位即可完成，时间复杂度为O(1)。
</code></pre><p>数据结构的物理存储结构只有两种：顺序存储结构  和  链式存储结构，在上面讲的，在数组中根据下标查找某个元素，<br>一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组</p>
<p>我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><pre><code>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得
到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。
前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们
需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。
那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）
，再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式
</code></pre><h1 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h1><pre><code>在JDK1.6，JDK1.7中，HashMap采用位桶+链表实现，即使用链表处理冲突，同一hash值的值都存储在一个链表里。
但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，
hashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样就大大减少
了查找时间。
</code></pre><p>首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素Key的hash值，以此确定插入数<br>组中的位置，但是可能存在同一hash值的元素已经被放在数组的同一位置，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一个链表上的Hash值是相同的，所以说shuz存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样就大大提高了查找效率。</p>
<h6 id="当链表数组的容量超过初始容量的0-75时，再散列将链表数组扩大2倍，把原链表数组搬移到新数组中。"><a href="#当链表数组的容量超过初始容量的0-75时，再散列将链表数组扩大2倍，把原链表数组搬移到新数组中。" class="headerlink" title="当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组搬移到新数组中。"></a>当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组搬移到新数组中。</h6><p><strong>HashMap原理图</strong></p>
<p><img src="pictures/HashMap原理图.png" alt="HashMap原理图"></p>
<h1 id="JDK1-8中涉及的相关的数据结构"><a href="#JDK1-8中涉及的相关的数据结构" class="headerlink" title="JDK1.8中涉及的相关的数据结构"></a>JDK1.8中涉及的相关的数据结构</h1><ol>
<li><p>基本的哈希节点<br>其是hashMap中的静态类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static  class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123;</span><br><span class="line">      final int hash;                           //对key的hashCode值进行hash运算后的到的值，存储在Node中，避免重复计算</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;                           //存储指向下一个Node的引用</span><br><span class="line"></span><br><span class="line">      Node(int hash,K key, V value,Node&lt;K,V&gt; next)&#123;</span><br><span class="line">        this.hash=hash;</span><br><span class="line">        this.key=key;</span><br><span class="line">        this.value=value;</span><br><span class="line">        this.next=next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final K getKey()&#123; return key;&#125;</span><br><span class="line">      public final V getValue()&#123;return value;&#125;</span><br><span class="line">      public final String toString()&#123;return key+&quot;=&quot;+value;&#125;</span><br><span class="line"></span><br><span class="line">      public final int hashCode()&#123;            //计算每个节点的哈希值</span><br><span class="line">        return Objects.hashCode(key)^objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final V setValue(V newValue)&#123;   //更新当前节点的值，并返回更新以前的值</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final boolean equals(Object o)&#123; //判断两个节点是否相等</span><br><span class="line">        if(o == this)</span><br><span class="line">          return true;</span><br><span class="line">        if(o instanceof Map.Entry)&#123;</span><br><span class="line">          Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">          if(Objects.equals(key,e.getKey()) &amp;&amp; Objects.equals(value,e.getValue()))</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static final class TreeNode&lt;K,N&gt; extends LinkedHashMap.Entry&lt;K,V&gt;&#123;</span><br><span class="line">   TreeNode&lt;K,V&gt; parent;       //父节点</span><br><span class="line">   TreeNode&lt;K,V&gt; left;         //左子节点</span><br><span class="line">   TreeNode&lt;K,V&gt; right;        //右子节点</span><br><span class="line">   TreeNode&lt;K,V&gt; prev;         //</span><br><span class="line">   boolean red;                //红黑节点</span><br><span class="line"></span><br><span class="line">   final TreeNode&lt;K,V&gt; root()&#123;    //返回当前节点的根节点</span><br><span class="line">      for(TreeNode&lt;K,V&gt; r=this，p;;)&#123;</span><br><span class="line">        if((p=r.parent)==null)&#123;</span><br><span class="line">          return r;</span><br><span class="line">        &#125;</span><br><span class="line">        r=p</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="一-源码中的数据域"><a href="#一-源码中的数据域" class="headerlink" title="一.源码中的数据域"></a>一.源码中的数据域</h1><p><strong>加载因子（默认0.75）：为什么需要使用加载因子，为什么扩展容量呢？</strong><br>因为如果填充比很大，说明空间利用率很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率。</p>
<pre><code>HashMap本来是以空间换时间，所以填充比每必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充可以稍大，如果主要关注查找性能，填充比可以稍小。
</code></pre><p><strong>源码中的基础数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static final int  DEFAULT_INITIAL_CAPACITY = 1&lt;&lt;4;   //数组的默认大小</span><br><span class="line">static final int  MAXIMUM_CAPACITY  = 1 &lt;&lt; 30;       //最大容量</span><br><span class="line">static final float  DEFAULT_LOAD_FACTOR = 0.75f;     //加载因子，代表了table的填充度，默认是0.75</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;              //当每个散列位置上的链表长度超过8时，将其链表转为红黑树</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;      </span><br><span class="line"></span><br><span class="line">static  final int MIN_TREEIFY_CAPACITY = 64;      //只有桶位数组大小达到64时，才允许桶位树化，否则只是扩容</span><br><span class="line">                                                  // 至少为4 * TREEIFY_THRESHOLD以避免resize和树化的冲突</span><br><span class="line"></span><br><span class="line">transient Node&lt;K,V&gt;[] table;                      //存储元素的数组</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet;</span><br><span class="line">transient int size;                               //存放元素的个数，实际存储的key-value键值对的个数</span><br><span class="line">transient int modCount；                          //用于快速失败，由于hashMap是非线程安全的，在对hashMap进行迭代时，如果期间其他线程的参</span><br><span class="line">                                                   与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常</span><br><span class="line">int threshold;                                    //阈值，当table==&#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空</span><br><span class="line">                                                  间后，threshold一般为capacity*loadFactory。hashMap进行扩容时需要参考threshold</span><br><span class="line">final float loadFactor;                           //填充比（......后面略）</span><br></pre></td></tr></table></figure></p>
<h1 id="二-HashMap的构造函数"><a href="#二-HashMap的构造函数" class="headerlink" title="二.HashMap的构造函数"></a>二.HashMap的构造函数</h1><p>HashMap的构造方法有4种，主要涉及到的参数有，指定初始容量，指定填充比和用来初始化的Map：<br><strong>构造函数1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public  HashMap(int initialCapacity,float loadFactory)&#123;</span><br><span class="line">  if(initialCapacity &lt; 0)</span><br><span class="line">    throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;+initialCapacity);</span><br><span class="line">  if(initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  if(loadFactory &lt;= 0|| Float.isNAN(loadFactory))</span><br><span class="line">    throw new IllegalArgumentException(&quot;Illegal load factory:&quot;+loadFactor);</span><br><span class="line">  this.loadFactor=loadFactor;</span><br><span class="line">  this.threshold=tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中的tableSizeFor（int cap）函数：</span><br><span class="line">static final int tableSizeFor(int cap) &#123;//该方法用来返回大于等于该给定整数的最小2^次幂值；</span><br><span class="line">                                          首先需要了解一下，7=0111，其最小2^次幂为1000=0111+1；</span><br><span class="line">                                          11=1011，其最小2^次幂为10000=01111+1；</span><br><span class="line">                                          29=011101，其最效2^次幂为100000=011111+1；</span><br><span class="line">                                          由上面可以看出来对于给定整数m，其二进制第一次出现1的位数为n，那么其最小2^次幂值为：2的(n+1)次幂或者2的n次幂；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int n = cap - 1;                     //n=cap-1;避免n=2^m这种情况，经过下面运算后导致结果比n本身大一倍</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;                        //n|=n&gt;&gt;&gt;1;确保第一次出现1的位及其后一位都是1；</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;                        //n|=n&gt;&gt;&gt;2;确保第一次出现1的位及其后三位都是1；</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;                        //n|=n&gt;&gt;&gt;4;确保第一次出现1的位及其后7位都是1；</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;                        //n|=n&gt;&gt;&gt;8;确保第一次出现1的位及其后15位都是1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;                       //n|=n&gt;&gt;&gt;16;确保第一次出现1的位及其后面所有位都是1；</span><br><span class="line">                                        //此时将n=0x00111111...11；</span><br><span class="line">                                        // n+1即为0x0100000......00就是大于等于n的最小2^次幂</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造方法2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap（int initialCapacity）&#123;</span><br><span class="line">  this(initialCapacity,DEFAULT_LOAD_FACTOR);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造函数3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap（）&#123;</span><br><span class="line">  this.loadFactor=DEFAULT_LOAD_FACTOR;  //其他字段都是默认值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>构造函数4</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public HashMap（Map&lt;? extends K,? extends V&gt; m）&#123;</span><br><span class="line">  this.loadFactor=DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其中的putMapEntries()函数如下：</span><br><span class="line">final void putMapEntries(Map&lt;? extends K,? extends V&gt; m,boolean  evict)&#123;</span><br><span class="line"></span><br><span class="line">  //获取该map的实际长度</span><br><span class="line"></span><br><span class="line">  int s=m.size();</span><br><span class="line">  if(s&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">    //判断table是否初始化，如果没有初始化</span><br><span class="line"></span><br><span class="line">    if（table == null）&#123;</span><br><span class="line"></span><br><span class="line">      //求出需要的容量，因为实际的使用长度 = 容量*0.75得来的，+1是因为小数相除，基本都不会是整数，容量大小不能为小数，后面转换为int，多余的小数就要</span><br><span class="line">      //被丢弃掉，所以+1</span><br><span class="line"></span><br><span class="line">      float  ft=((float) s/loadFactor)+1.0f;</span><br><span class="line"></span><br><span class="line">      //判断该容量大小是否超出上限</span><br><span class="line"></span><br><span class="line">      int t=（（ft&lt;(float)MAXIMUM_CAPACITY）? int(ft):MAXIMUM_CAPACITY）;</span><br><span class="line"></span><br><span class="line">      //对临界值进行初始化，tableSizeFor（）这个方法会返回大于t值的，且离其最近的2次幂</span><br><span class="line"></span><br><span class="line">      if（t&gt;threshold）</span><br><span class="line">        threshold=tableSizeFor(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果table已经初始化，则进行扩容操作，resize()就是扩容。</span><br><span class="line"></span><br><span class="line">    else if(s&gt;threshold)</span><br><span class="line">      resize();</span><br><span class="line"></span><br><span class="line">    //遍历，把map中的数据转存到hashMap中</span><br><span class="line"></span><br><span class="line">    for（Map.Entry&lt;? extends K,? extends V&gt;e : m.entrySet()）&#123;</span><br><span class="line">      K key=e.getKey();</span><br><span class="line">      V value=e.getValue();</span><br><span class="line">      putVal(hash(key),key,value,false,evict);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>该构造函数，传入一个Map，然后把该Map转为hashMap，resize方法是进行扩容的函数，在上面中entrySet方法会返回Set&lt;Map.Entry&lt;K,V&gt;&gt;,泛型为Map的内部类Entry，它是一个存放key-value的实例，也就是Map中的每一个key-value 就是一个Entry实例，为什么使用这个方式进行遍历，因为效率高。<br>有两种遍历方式：第一种是先利用keySet方法获取所有的Key的集合，然后再利用get方法获取值。<br>第二种是直接获取Entry&lt;K,V&gt;的集合，可以直接从Entry中取得key和value值。<br>而get方法中其实也是从Entry中取值。这样第一种方法和第二种方法相比，显然第二种方法的效率更高。</strong></p>
<h1 id="三-HashMap常用的方法-增-删-改-查"><a href="#三-HashMap常用的方法-增-删-改-查" class="headerlink" title="三 HashMap常用的方法  增,删,改,查"></a>三 HashMap常用的方法  增,删,改,查</h1><p>在此之前先看一下怎么计算hash值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key)&#123;</span><br><span class="line">  int h;</span><br><span class="line">  return (key==null) ? 0:(h=key.hashCode())^(h&gt;&gt;&gt;16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>只做一次16位右移异或混合，右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，一次来加大地位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</strong></p>
<h5 id="1-HashMap如何获取getValue的值"><a href="#1-HashMap如何获取getValue的值" class="headerlink" title="1.HashMap如何获取getValue的值"></a>1.HashMap如何获取getValue的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key)&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  return (e=getNode(hash(key),key)) == null ? null :e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash,Object key)&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab;                              //Entry对象数组</span><br><span class="line">  Node&lt;K,V&gt; first,e;                            //在tab数组中经过散列的第一个位置</span><br><span class="line">  int n;                      </span><br><span class="line">  K k;</span><br><span class="line">// 找到插入的第一个Node，方法是hash值与n-1相与，在一条链上的hash值是相同的</span><br><span class="line"></span><br><span class="line">if（( tab = table ) != null &amp;&amp; ( n = tab.length ) &gt; 0 &amp;&amp; ( first = tab[ (n-1) &amp; hash ]) != null）&#123;</span><br><span class="line"></span><br><span class="line">  //检查第一个Node是不是要找的Node</span><br><span class="line"></span><br><span class="line">  if(first.hash == hash &amp;&amp; ((k=first.key)==key || (key != null) &amp;&amp; key.equals(k)))</span><br><span class="line">    return first;</span><br><span class="line"></span><br><span class="line">  //检查first后面的节点</span><br><span class="line"></span><br><span class="line">  if((e=first.next) != null)&#123;</span><br><span class="line">    if(first instanceof TreeNode)</span><br><span class="line">      return ((TreeNode&lt;K,V&gt;) first).getTreeNode(hash,key);</span><br><span class="line">    do&#123;</span><br><span class="line">      if(e.hash == hash &amp;&amp; ((k = e.key) == key ||(key !=null &amp;&amp; key.equals(k))))</span><br><span class="line">        return e;</span><br><span class="line">    &#125;while((e=e.next) != null)</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可</strong></p>
<h5 id="2-put-K-key-V-value-方法"><a href="#2-put-K-key-V-value-方法" class="headerlink" title="2.put(K key,V value)方法"></a>2.put(K key,V value)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key,V Value)&#123;</span><br><span class="line">  return putVal(hash(key),key,value,false,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final  V putVal(int hash,K key,V value, boolean onlyIfAbsent, boolean evict)&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab;                        //哈希数组</span><br><span class="line">  Node&lt;K,V&gt; p;                            //该哈希数组的首节点</span><br><span class="line">  int n,i;                                //n表示该HashMap的首节点，i表示计算出的数组下标</span><br><span class="line">  if((tab=table)==null || (n = tab.length) == 0)  //获取数组长度并进行扩容，使用的是懒加载，table一开始是没有加载的，等put后才开始加载</span><br><span class="line">    n=(tab=resize()).length;</span><br><span class="line">  if((p = tab[i = (n-1)&amp;hash]) == null)  //如果计算出的哈希表的位置没有值，则把新插入的key-value放到此处，此处就算没有插入成功，也就是发生哈希冲突时</span><br><span class="line">                                         //也会把哈希表的首节点赋予p</span><br><span class="line">    tab[i] = newNode(hash,key,value,null);</span><br><span class="line">  else&#123;                                   //发生哈希冲突的几种情况</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     K k;                                 //e 临时节点的作用，K存放该当前节点</span><br><span class="line"></span><br><span class="line">     //第一种情况，插入的key-value的hash值，key都与当前节点相等，e=p，则表示为首节点</span><br><span class="line"></span><br><span class="line">     if(p.hash == hash &amp;&amp; ((k = p.key)==key || (key !=null &amp;&amp; key.equals(k))))</span><br><span class="line">        e=p;</span><br><span class="line">     else  if （p  instanceof  TreeNode）  //第二种  hash值的key-value不等于首节点，判断p是否等于红黑树的节点</span><br><span class="line"></span><br><span class="line">              //如果为红黑树的节点，则在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），该值很重要，用来判断put操作是否成功</span><br><span class="line">              //如果添加成功返回null</span><br><span class="line"></span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeNode(this,tab,hash,key,value)</span><br><span class="line">          else &#123;   //第三种，hash值不等于首节点，不为红黑树节点，则为链表的节点</span><br><span class="line">               for(int binCount = 0;;++binCount)&#123;</span><br><span class="line">                 if((e = p.next) == null)&#123;</span><br><span class="line">                   p.next = newNode(hash,key,value,null); //如果找到尾部，则表明添加的key-value没有重复，在尾部进行添加</span><br><span class="line"></span><br><span class="line">                   if(binCount &gt;= TREEIFY_THRESHOLD - 1)   //判断是否要转换为红黑树</span><br><span class="line">                        treeifyBin(tab,hash);</span><br><span class="line">                  break;</span><br><span class="line">                 &#125;</span><br><span class="line">                if(e.hash == hash &amp;&amp;((k=e.key)==key || (key != null &amp;&amp; key.equals(k))))  //如果链表中有重复的key，e则为当前重复的节点，结束循环</span><br><span class="line">                      break;</span><br><span class="line">                p = e;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if(e !=null)&#123;             //用重复的key，则用带插入值进行覆盖，返回旧值</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if(!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value=value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line"></span><br><span class="line">            return oldValue;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // 到了此步，则表明带插入的key-value是没有重复的，因为插入成功e节点的值为null。若有重复 则已经在上面返回了，</span><br><span class="line">    //修改次数+1</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    //实际长度+1，判断是否大于临界值，大于则扩容</span><br><span class="line"></span><br><span class="line">    if(++size &gt; threshold)</span><br><span class="line">       resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line"></span><br><span class="line">    return null;   //添加成功</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>下面简单说下添加键值对put(key,value)的过程：</strong>                                                                                                      </p>
<ol>
<li>判断键值对数值tab[]是否为空或为null，否则以默认大小resize();</li>
<li>根据键值对key计算hash值得到插入的数组索引i，如果tab[i] == null，直接新建节点添加，否则转入3</li>
<li>判断当前数组中处理处理hash冲突的方式为链表还是红黑树(检查第一个节点类型即可)，分别处理</li>
</ol>
<h5 id="3-HashMap的扩容机制"><a href="#3-HashMap的扩容机制" class="headerlink" title="3.HashMap的扩容机制"></a>3.HashMap的扩容机制</h5><p>构造hash表示，如果不指名初始大小，默认大小为16(即Node数组大小16)，如果Node[]数组中的元素达到（填充比*Node.length）重新调整HashMap大小变为原来的2倍大小，扩容很耗时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">final  Node&lt;K,V&gt;[] resize()&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;             //把没插入之前的哈希数组叫做oldTab</span><br><span class="line">  int oldCap = ( oldTab == null) ? 0 :oldTab.length;    //old的长度</span><br><span class="line">  int oldThr = threshold;                               //old的临界值</span><br><span class="line">  int newCap,newThr=0                                   //初始化new的长度和临界值</span><br><span class="line">  if(oldCap &gt; 0) &#123;                                      //oldCap &gt; 0 也就是说不是首次初始化，因为hashMap用的是懒加载</span><br><span class="line"></span><br><span class="line">        if(oldCap &gt;= MAXIMUM_CAPACITY)&#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;           //临界值为整数的最大值</span><br><span class="line">             return  oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">      else if((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;=DEFAULT_INITIAL_CAPACITY)//扩容两倍，并且扩容后的长度也要小于最大值 ，大于默认值</span><br><span class="line">            newThr=oldThr &lt;&lt; 1;              临界值也扩容为就得临界值的2倍</span><br><span class="line">  &#125;</span><br><span class="line">  //如果oldCap&lt;0,但是已经初始化了，像把元素删除完之后的情况，那么它的临界肯定还存在。如果是首次初始化话，它的临界值则为0</span><br><span class="line">  else  if(oldThr &gt; 0)</span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       else&#123;                                        首次初始化，给与默认值</span><br><span class="line">           newCap =DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr=(int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">       &#125;</span><br><span class="line">  if(newThr == 0) &#123;                                 //此处的临界值为0，也就是初始化时容量小于默认16，此时newtThr没有赋值</span><br><span class="line">    float ft =（float）newCap*loadFactor;           //new的临界值</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  //把上面各种情况分析出的临界值，在此处真正进行改变，也就是容量和临界值都改变了。</span><br><span class="line">  threshold = newThr;</span><br><span class="line"></span><br><span class="line">  //初始化</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">  table  = newTab;                                //赋予当前table</span><br><span class="line"></span><br><span class="line">  if(oldTab != null)&#123;                             //此处自然是把old中的元素。遍历到new中</span><br><span class="line">      for（int j=0;j &lt; oldCap; j++）&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;                              //临时变量</span><br><span class="line">        if((e = oldTab[j]) !=null)&#123;               //当前哈希表的位置不为null，也就是数组下标处有值，因为有值表示有可能会发生冲突</span><br><span class="line">             oldTab[j]=null;                      //把已赋值后的位置置null，当然是为了好回收，释放内存</span><br><span class="line">             if(e.next == null)                   //如果下标处的节点没有下一个元素</span><br><span class="line">                   newTab[e.hash&amp;(newCap -1)]=e;</span><br><span class="line">            else if(e instanceof TreeNode)        //该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span><br><span class="line">                 ((TreeNode&lt;K,V&gt;)e).split(this,newTab,j,oldCap);   //把此树转移到newCap中</span><br><span class="line">            else&#123;                                //此处为链表结构，就是遍历链表，把链表转移到newCap中，并把原来的链表置null</span><br><span class="line">                 Node&lt;K,V&gt; loHead = null,loTail = null;</span><br><span class="line">                 Node&lt;K,V&gt; hiHead = null,hiTail = null;</span><br><span class="line">                 Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                 do &#123;</span><br><span class="line">              next = e.next;                               //记录下一个结点</span><br><span class="line">                                                           //新表是旧表的两倍容量，实例上就把单链表拆分为两队，</span><br><span class="line">　　　　　　　　　　　　　                                  　//e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对</span><br><span class="line">            if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                  if (loTail == null)</span><br><span class="line">                          loHead = e;</span><br><span class="line">                  else</span><br><span class="line">                          loTail.next = e;</span><br><span class="line">                  loTail = e;</span><br><span class="line">                   &#125;</span><br><span class="line">                  else &#123;</span><br><span class="line">                  if (hiTail == null)</span><br><span class="line">                         hiHead = e;</span><br><span class="line">                  else</span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                  hiTail = e;</span><br><span class="line">                   &#125;</span><br><span class="line">                  &#125; while ((e = next) != null);</span><br><span class="line"></span><br><span class="line">                  if (loTail != null) &#123;    //lo队不为null，放在新表原位置</span><br><span class="line"></span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (hiTail != null) &#123;    ////hi队不为null，放在新表j+oldCap位置</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return  newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-删除元素remove"><a href="#4-删除元素remove" class="headerlink" title="4.删除元素remove()"></a>4.删除元素remove()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public V remove(Object key)&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;                //临时变量</span><br><span class="line">  return (e = removeNode(hash(key),key,null,false,true))== null ? null:e.value;//第一个参数为哈希值，第二个为key，第三个为value,第四个为true的话，</span><br><span class="line">                                                                              //则表示删除key对应的value，不删除key，第四个如果为false，表示删除后，</span><br><span class="line">                                                                              //不移动节点。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash,Object key,Object value,boolean matchValue,boolean movable)&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab;Node&lt;K,V&gt; p; int n,index;        //tab 哈希数组，p数组下标的节点，n长度，index当前数组下标</span><br><span class="line">  if((tab=table)!=null &amp;&amp; (n=tab.length)&gt; 0 &amp;&amp; (p= tab[index=(n-1)&amp;hash]) != null)&#123; //哈希数组不为null，且长度大于0，然后获得要删除key的节点所在</span><br><span class="line">                                                                                    //是数组下标位置</span><br><span class="line">       Node&lt;K,V&gt; node = null,e; K k; V v;                                   //node存储要删除的节点，e临时变量，k当前节点的key，v表示当前节点的value</span><br><span class="line">       if(p.hash == hash &amp;&amp; ((k = p.key)== key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;                                                       //如果数组下标的节点正好是要删除的节点，把值赋给临时变量node</span><br><span class="line">       else  if((e.p.next) != null)&#123;                                        //要删除的节点，在链表或则红黑树上，先判断是否为红黑树节点</span><br><span class="line">             if(p instanceof TreeNode)</span><br><span class="line">                  node =((TreeNode&lt;K,V&gt;)p).getTreeNode(hash,key);           //遍历红黑树，找到该节点并返回</span><br><span class="line">             else&#123;                                                          //表示为链表节点，一样的遍历找到该节点</span><br><span class="line">                 do&#123;</span><br><span class="line">                     if(e.hash == hash &amp;&amp; ((k = e.key)== key ||(key != null &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       node =e; break;</span><br><span class="line">                     &#125;</span><br><span class="line">                     p=e;                                                  //如果进入了链表中的遍历，name此处的p不再是数组下标的节点，而是要删除的节点</span><br><span class="line">                 &#125;while((e. e.next) !=null);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       if(node != null &amp;&amp; (!matchValue || (v = node.value)==value ||(value !=null &amp;&amp; value.equals(v))))&#123;  //找到要删除的节点，判断！matchValue,正常</span><br><span class="line">                                                                                                          //的 remove删除，！matchValue都为true</span><br><span class="line">                  if(node instanceof TreeNode)                           //如果删除的节点是红黑树节点，则去红黑树除</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this,tab,movable);</span><br><span class="line">                  else  if(node==p)                                      //如果是链表结构，且删除的节点为数组下标节点，也就是头结点，直接让下一个作为头</span><br><span class="line">                            tab[index] = node.next;</span><br><span class="line">                        else                                          ///为链表结构，删除的节点在链表中，把要删除的下一个节点设为上一个结点的下一个节点</span><br><span class="line">                            p.next = node.next;</span><br><span class="line">                  ++modCount;                                  //修改计数器</span><br><span class="line">                  --size；                                     //长度减一</span><br><span class="line">                  afterNodeRemoval(node);                      //此方法在hashMap中是为了让子类去实现，主要是对删除节点后的链表进行处理</span><br><span class="line">                  return node；        </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return  null;  //返回null则表示没有该节点，删除失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##JDK8做的优化<br>JDK8使用的是2次幂的扩展（指长度扩围原来的2倍），所以，元素的位置幺妹是在原位置，幺妹是在原位置再移动2次幂的位置。看下图就明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是可以1对应的哈希与高位运算结果。</p>
<p><img src="pictures/hash算法例图1.png" alt="哈希算法"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：</p>
<p><img src="pictures/hash算法例2.png" alt="哈希算法"></p>
<p>因此，我们在扩充HashMap的时候,不需要像JDK1.7的实现那样重新计算hash ,只需要看看原来的hash值新增的那个bit是1还是0就好了,是0的话索引没变,是1的话索引变成“原索引+oldCap”,可以看看下图为16扩充为32的resize示意图:</p>
<p><img src="pictures/hashMap扩容例图.png" alt="hashMap扩容例图"></p>
<p>有一点注意区别, JDK1.7中rehash的时候，旧链表迁移新链表的时候,如果在新表的数组索引|位置相同,则链表元素会倒置,但是从上图可以看出，JDK1.8不会倒置，JDK1.8是从链表的尾部插入。</p>
<h1 id="JDK1-8-使用红黑树改进hashMap"><a href="#JDK1-8-使用红黑树改进hashMap" class="headerlink" title="JDK1.8 使用红黑树改进hashMap"></a>JDK1.8 使用红黑树改进hashMap</h1><p>在java JDK8以前HashMap处理碰撞的时候，都是采用链表来存储，当碰撞的节点很多时，查询时间O(n).在JDK1.8中，HashMap处理”碰撞”增加了红黑树这种数据结构，当碰撞节点较少时，采用链表存储，当较大时(&gt; 8个)，采用红黑树(特点是查询时间O(log n))存储(有一个阈值控制，大于阈值(8个)，将链表存储转换成红黑树存储)</p>
<h1 id="JDK8线程安全性问题"><a href="#JDK8线程安全性问题" class="headerlink" title="JDK8线程安全性问题"></a>JDK8线程安全性问题</h1><p><strong>在 JDK1.7 中并发扩容操作可能会导致哈希碰撞的链表结构为循环链表，从而导致在后续 put、get 操作时发生死循环。而对于 JDK1.8 中扩容链表的顺序是不会发生逆向的，所以自然怎么遍历都不会出现循环链表的情况，故 JDK1.8 中不会出现并发循环链表，但由于 JDK1.7 与 JDK1.8 中都是无锁保护的，所以依然是并发不安全的</strong>              </p>
<p><img src="pictures/红黑树.png" alt="红黑树"></p>
<h3 id="JDK1-8HashMap的红黑树是这样的解决查询时间慢的问题："><a href="#JDK1-8HashMap的红黑树是这样的解决查询时间慢的问题：" class="headerlink" title="JDK1.8HashMap的红黑树是这样的解决查询时间慢的问题："></a>JDK1.8HashMap的红黑树是这样的解决查询时间慢的问题：</h3><p><strong>如果某个桶中的记录过大(当前是TREEIFY_THRESHOLD = 8),HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好是O(log n),而不是糟糕的O(n);<br>当桶中链表中的个数超过这个阈值后，HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果哈希值不相等，但指向同一个桶的话，较大的那个会插入到右子树。如果哈希值相等，HashMap希望key值最好是实现Comparable接口的，这样它可以按顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，性能就不会有太多提升。</strong></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种特殊的二叉查找树，在满足二叉查找树的特性外，在每个节点上增加了存储颜色的标识，颜色要么是红色，要么是黑色，定义：</p>
<ol>
<li>每个节点要么是黑色，要么是红色</li>
<li>根节点是黑色</li>
<li>所有的叶子节点是黑色，即空节点（NIL）</li>
<li>如果一个节点是红色的，则它的两个子节点补习是黑色的，也就是父子节点不能都为红</li>
<li>从一个节点到其所有叶子节点的所有路径上包含相同数目的黑色节点</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>特性3中的叶子节点，只是为空（NIL或null）的节点</li>
<li>特性5，确保没有一条路径回避其他路径长出两倍，因为，红黑树是相对接近平衡的二叉树。因此在最坏情况下，红黑树能保证时间复杂度为O（log n  ）</li>
</ol>
<h4 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h4><p><strong>规则约定</strong></p>
<ol>
<li>在红黑树中插入节点时，节点的初始颜色都是红色。因为这样可以在插入过程中尽量避免对树的结构进行调整</li>
<li>初始插入按照二叉树的性质插入，即找到合适大小的节点，在其左边或右边插入子节点</li>
</ol>
<p><strong>我们插入一个节点后，可能会使原树的那些性子改变呢</strong></p>
<ol>
<li>由于是以二叉树的性质插入，因此节点的查找性质不会破坏</li>
<li>如果插入空树中，称为根节点，则性质2会被破坏，需要重新涂色。</li>
<li>如果插入节点的父节点是红色，则性质4会被破坏，需要以插入的当前节点为中心进行旋转或则重新涂色来恢复红黑树的性质。执行旋转或重新涂色来恢复红黑树的性质。 。执行旋转或重新涂色后有可能红黑树仍不满住性质，则需要将当前节点变换回溯到其父节点或祖父节点，以父节点或祖父节点为中心继续旋转或重新涂色，如此循环到根节点知道瞒住红黑树的性质</li>
</ol>
<p><strong>恢复红黑树性质的策略</strong></p>
<ol>
<li>把出现违背红黑树性质的节点向上移（通过旋转操作或变换当前节点到父节点或祖父节点后再旋转达到向上移动的目的），如果能够到根节点，那么很容易就能通过直接修改根节点的颜色，或旋转根节点来恢复红黑树的性质。</li>
<li>旋转或涂色处理可分为5中情况处理</li>
</ol>
<p><strong>情况1：空树中插入跟节点</strong><br>  违反性质2</p>
<p>  恢复策略： 初始插入的节点均为红色，因此简单讲红色重涂为黑色即可。</p>
<p><strong>情况2：插入节点的父节点是黑色</strong></p>
<p>没有违反任何性质，无须做调整</p>
<p><strong>情况3：当前节点的父节点是红色，且叔叔节点也是红色</strong></p>
<p>违反：性质2</p>
<p>此时祖父节点一定存在，否则插入前就已经不是红黑树了</p>
<p>与此同时，又分为父节点是祖父的左子还是右子，由于对称性，只要解开一个方向就可以了，这里只考虑父节点为祖父的左子节点。<br>同时还可分为当前节点是其父节点的左子还是右子，但处理方式都是一样的，我们将此归为一类。</p>
<p>恢复策略：将当前节点的父节点和叔叔节点涂黑，祖父节点涂红，把当前节点指向祖父节点，以祖父节点为中心开始新一轮的旋转或涂色</p>
<p><img src="pictures/红黑树-情况3.png" alt="情况3"></p>
<p>以插入节点4位当前节点，判断父节点和叔叔节点是否都为红，如果为红色，则将祝福节点7的颜色改为红色，父节点5和叔叔节点8的颜色改为黑色。同时当前节点移动到祖父节点7.此时，当前节点7的父节点也为红色，出现父节点都为红色的情况，且叔叔节点为黑色，这是情况4，需要按照情况4的策略调整。</p>
<p><strong>情况4：当前节点的父节点为红色，叔叔节点是黑色，且当前节点是右子节点</strong></p>
<p> 违反：性质4</p>
<p> 恢复策略：以当前节点的父节点作为新的当前节点，以当前节点为支撑点，进行左旋操作。旋转操作后再按新的情况进行旋转或涂色</p>
<p><img src="pictures/情况4-红黑树.png" alt=" 情况4"></p>
<p>这里的操作为：当前节点由原来的7变换为其父节点2，以新的当前节点2，做左旋操作如上图。操作完成后，发现父节点仍然都是红色，继续进行旋转或涂色。这里的情况使用情况5.</p>
<p><strong>情况5：当前节点的父节点是红色，叔叔节点是黑色，当前节点是左子节点</strong></p>
<p>违反：则性质4</p>
<p>恢复策略：父节点改变为黑色祖父节点变为红色，然后再以祖父节点为新的当前节点，左右旋操作。</p>
<p><img src="pictures/情况5-红黑树.png" alt="情况5"></p>
<p>此时已满足红黑树的性质，如果仍不满足，则仍按照情况1-情况5的方式进行旋转和涂色。</p>
<p>##为什么不用平衡二叉树作为底层实现</p>
<p>那是因为平衡二叉是高度平衡的树，而每一次对树的修改，都要重新平衡，这里的开销回避红黑树大。如果插入一个node引起了树的不平衡，平衡二叉树和红黑树都是最多需要2次旋转操作，即两者都是O（1）；但是在删除node引起的不平衡时，最坏的情况下，平衡二叉树需要维护从被删除node到root这条路径上所有node的平衡性，因此需要旋转的良机O（logN），而红黑树最多只需要三次旋转，只需要O（1）的复杂度，所以平衡二叉树需要 rebalance的频率会更高，因此红黑树在大量插入和删除的场景下效率更高</p>
<h3 id="hashMap-红黑树的具体实现"><a href="#hashMap-红黑树的具体实现" class="headerlink" title="hashMap 红黑树的具体实现"></a>hashMap 红黑树的具体实现</h3><p>分为三个节点：<br><strong>第一阶段：将链表转化为二叉树</strong><br><strong>第二阶段：验证是否满足红黑树的五大特征</strong><br><strong>第三阶段：对二叉树进行左右旋转。</strong></p>
<p>一开始并非直接转换为红黑树，而是通过扩容table到2倍的方式，只有table的长度大于64之后，才会将超过8个元素的链表转红黑树。红黑树的构造过程是在TreeBin的构造方法中完成的。</p>
<h3 id="将链表转化为二叉树"><a href="#将链表转化为二叉树" class="headerlink" title="将链表转化为二叉树"></a>将链表转化为二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        // 重新计算 hash段位，及table的索引位，第一个节点</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line"></span><br><span class="line">            /************　双向链表　start***************/</span><br><span class="line">            //　hd头节点, tl尾节点</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                // 循环所有节点</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; while ((e = e.next) != null);// 循环下一个节点</span><br><span class="line">            /************　双向链表　end***************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 前面仅仅转换为双向链表，treeify才是转换红黑树的处理方法入口　</span><br><span class="line">            // 第一个节点赋值为头节点,也就是根节点</span><br><span class="line">            if ((tab[index] = hd) != null)</span><br><span class="line">                // 将二叉树转换为红黑树</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证是否满足红黑树的五大特征"><a href="#验证是否满足红黑树的五大特征" class="headerlink" title="验证是否满足红黑树的五大特征"></a>验证是否满足红黑树的五大特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">* 调用这个方法之前　也就是一个双向链表</span><br><span class="line">         * 初始进入值为　this头节点</span><br><span class="line">         * 将双向链表转换为红黑树</span><br><span class="line">         * 目标：查询　root　节点</span><br><span class="line">         * @param tab</span><br><span class="line">         */</span><br><span class="line">        final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = null;//root节点</span><br><span class="line">            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next; //next　下一个节点</span><br><span class="line">                x.left = x.right = null;//设置左右节点为空</span><br><span class="line">                if (root == null) &#123;//首次循环　root　== null</span><br><span class="line">                    x.parent = null; // 将根节点的父节点设置位空</span><br><span class="line">                    x.red = false; // 将根节点设置为 black</span><br><span class="line">                    root = x; //将x 设置为根节点</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;// 非根节点</span><br><span class="line">                    K k = x.key;//　获取当前循环节点ｋｅy</span><br><span class="line">                    int h = x.hash;// 获取当前节点ｈａｓｈ</span><br><span class="line">                    Class&lt;?&gt; kc = null;</span><br><span class="line">                    // 从根节点开始验证</span><br><span class="line">                    for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        int dir, ph;</span><br><span class="line">                        K pk = p.key;// 每个节点的ｋｅｙ</span><br><span class="line">                        if ((ph = p.hash) &gt; h) //每个节点的ｈａｓh 与　外层循环的ｘ.hash做比较</span><br><span class="line">                            dir = -1;// &lt;0 ,沿左路径查找　-１</span><br><span class="line">                        else if (ph &lt; h)// &gt;0, 沿右路径查找　１</span><br><span class="line">                            dir = 1;</span><br><span class="line"></span><br><span class="line">                        // 如果存在比较对象，则根据比较对象定义的comparable进行比较</span><br><span class="line">                        // 比较之后返回查询节点路径（左或右）</span><br><span class="line">                        else if ((kc == null &amp;&amp;</span><br><span class="line">                                (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                                (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        // p设置位ｘ的父节点　xp</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line"></span><br><span class="line">                        //　如果父节点的左节点或右节点为空时，才进行插入操作</span><br><span class="line">                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                            // 将px设置为ｘ的父节点</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            if (dir &lt;= 0)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            else</span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            // 将二叉树转换位红黑树－正式转换红黑树</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的基本操作（删除）"><a href="#红黑树的基本操作（删除）" class="headerlink" title="红黑树的基本操作（删除）"></a>红黑树的基本操作（删除）</h3><p>将红黑树的某一个节点删除。需要执行的操作一次是：首先，将红黑树当做一颗二叉树，将该节点从二叉树中删除；然后，通过“旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p>
<p><strong>第一步：将红黑树当做一颗二叉查找树，将节点删除</strong></p>
<p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p>
<p>  ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</p>
<p>  ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p>
<p>  ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。<br><strong>第二步：通过“旋转和重新着色”等一系列来修正树，使之重新成为一颗红黑树。</strong><br>我们再次温习一下红黑树的几个特性：</p>
<p>(1) 每个节点或者是黑色，或者是红色。</p>
<p>(2) 根节点是黑色。</p>
<p>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</p>
<p>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p><strong>为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？</strong></p>
<p>通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。</p>
<p> 现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”</p>
<p> <strong>解决思路</strong></p>
<p> 将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：</p>
<p>(1)x指向一个“红+黑”节点时。此时，将x设为一个 黑色 节点。</p>
<p>(2)x指向跟。此时，将 想设为一个 黑色  节点</p>
<p>(3)非前面两种姿态</p>
<p>将上面的姿态，可以概括为3中情况</p>
<ol>
<li>情况说明：x是“红+黑”节点</li>
</ol>
<p>处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。</p>
<ol start="2">
<li>情况说明：想是“黑+黑”节点，且x是根</li>
</ol>
<p>处理方法：什么都不做，结束。此时红黑树的性质全部恢复。</p>
<p>3.情况说明： x是“黑+黑”节点，且x不是根</p>
<p>处理方法：这种情况又可以划分为4中情况：</p>
<p><strong>第一种：x是“黑+黑”节点，x的兄弟节点是红色</strong></p>
<p><strong>处理策略</strong></p>
<ol>
<li>将x的兄弟节点设为“黑色”</li>
<li>将x的父节点设置为“红色”</li>
<li>对x的父节点进行左旋</li>
<li>左旋后，重新设置x的兄弟节点</li>
</ol>
<p><img src="pictures/删除case1.png" alt="红黑树-删除-case1"></p>
<p>这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>第二种：x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></p>
<p><strong>处理策略</strong></p>
<ol>
<li>将x的兄弟节点设为“红色”</li>
<li>设置x的父节点为新的“x”节点</li>
</ol>
<p><img src="pictures/红黑树-删除-case2.png" alt="红黑树——删除-case2"></p>
<p>这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。</p>
<p>经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p>
<p><strong>第三种：x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></p>
<p><strong>处理策略</strong></p>
<ol>
<li>将x兄弟节点的左孩子设为“黑色”。</li>
<li>将x兄弟节点设为“红色”。</li>
<li>将x的兄弟节点进行右旋</li>
<li>右旋后，重新设置x的兄弟节点</li>
</ol>
<p><img src="pictures/红黑树—删除-case3.png" alt="红黑树——删除-case3"></p>
<p>我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>第四种x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></p>
<p><strong>恢复策略：</strong></p>
<ol>
<li>将x父节点颜色赋值给x的兄弟节点。</li>
<li>将x父节点设置为“黑色”</li>
<li>将x兄弟节点的右子节点设为“黑色”</li>
<li>对x的父节点进行左旋</li>
<li>设置x为根节点</li>
</ol>
<p><img src="pictures/红黑树—删除-case 4.png" alt="红黑树-删除-case4"></p>
<p> 我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的</p>
<p> 为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)</p>
<p> 我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：</p>
<pre><code> 第一，“同时经过根节点和S的分支的黑色节点个数不变”。
     若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。

第二，“同时经过根节点和BLS的分支的黑色节点数不变”。
       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色&quot;黑色&quot;，赋值给了F)。至此，我们算是调换了F和B的颜色。
第三，“同时经过根节点和BRS的分支的黑色节点数不变”。
       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。
</code></pre><p>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/22/‘HashMap底层源码解析/" data-id="cjuajt99g000qfcamj4tjp2d2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>

  
    
  <h5>RECENT POSTS
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2019/04/08/动态代理/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/04/08/springAOP/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/25/dubbo/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/22/操作系统_存储器管理和虚拟存储器/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/21/操作系统_处理机的调度与死锁/">(no title)</a>
        </li>
      
    </ul>
  </div>
</h5>
  
    <!-- Friends Blog -->

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>