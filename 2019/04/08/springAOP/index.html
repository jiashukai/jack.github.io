<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一.什么是AOPAOP(面向切面编程)，可以说是OOP的补充和完善。OOP引入封装，继承和多态等概念来监利一中对象层次结构，用以公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显的无能为力。OOP允许你从上到下的关系，但是并不适合定义从左到右。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/04/08/springAOP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一.什么是AOPAOP(面向切面编程)，可以说是OOP的补充和完善。OOP引入封装，继承和多态等概念来监利一中对象层次结构，用以公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显的无能为力。OOP允许你从上到下的关系，但是并不适合定义从左到右。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/04/08/springAOP/pictures/AOP代理方法.png">
<meta property="og:image" content="http://yoursite.com/2019/04/08/springAOP/pictures/AOP切面接口.png">
<meta property="og:updated_time" content="2019-04-09T09:51:34.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="一.什么是AOPAOP(面向切面编程)，可以说是OOP的补充和完善。OOP引入封装，继承和多态等概念来监利一中对象层次结构，用以公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显的无能为力。OOP允许你从上到下的关系，但是并不适合定义从左到右。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和">
<meta name="twitter:image" content="http://yoursite.com/2019/04/08/springAOP/pictures/AOP代理方法.png">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-springAOP" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/springAOP/" class="article-date">
  <time datetime="2019-04-08T02:46:35.436Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-什么是AOP"><a href="#一-什么是AOP" class="headerlink" title="一.什么是AOP"></a>一.什么是AOP</h2><p>AOP(面向切面编程)，可以说是OOP的补充和完善。OOP引入封装，继承和多态等概念来监利一中对象层次结构，用以公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显的无能为力。OOP允许你从上到下的关系，但是并不适合定义从左到右。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，模块间的藕合度高，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心业务逻辑组件和横切关注点。横切关注点模块化为特殊的类，这些类被称为“切面”，好处：1.横切关注点都集中于一块，不会出现大量重复代码；2.核心模块只关注核心功能的代码，模块间藕合度降低。</p>
<h2 id="二-AOP实现原理"><a href="#二-AOP实现原理" class="headerlink" title="二.AOP实现原理"></a>二.AOP实现原理</h2><p><img src="pictures/AOP代理方法.png" alt="AOP代理方法"></p>
<p>AOP 实际上是由目标类的代理类实现的。AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异，AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p>
<h3 id="三-AOP-相关概念"><a href="#三-AOP-相关概念" class="headerlink" title="三.AOP 相关概念"></a>三.AOP 相关概念</h3><p>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。通俗的说就是加入切点的那个点</p>
<p>通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p>
<p>切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p>
<p>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</p>
<p>织入（Weaving）：将切面应用到目标对象来创建新的代理对象的过程。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<p>增强（Advice）：是织入到目标类连接点上的一段程序代码。Spring使用增强类定义横切逻辑，同时由于Spring只支持方法连接点，增强还包括了在方法上的哪一点加入横切代码的方位信息，所以增强既包括横切逻辑、还包含部分连接点的信息。</p>
<p>引介（Introduction）：是一种特殊的增强，为类添加一些属性和方法。</p>
<p>切面（Advisor）：代表一般切面，包含了横切代码和连接点信息，本身是一个简单的切面，横切的连接点是目标类的所有方法。3种类型：一般切面（advisor）、切点切面（PointcutAdvisor）、引介切面（IntroductionAdvisor）。</p>
<p><strong>Spring 采用jdk动态代理模式来实现Aop机制。<br>Spring AOP采用动态代理过程：<br>1.将切面使用动态代理的方式动态织入到目标对象，形成一个代理对象。<br>2.目标对象如果没有实现代理接口，那么spring会采用CGLib来生成代理对象，该代理对象是目标对象的子类。<br>3.目标对象如果是final类，也没有实现接口，就不能运用AOP</strong></p>
<p><strong>AOP的实现包含下面几个方面：</strong></p>
<ol>
<li>根据配置或注解解析切面</li>
<li>生成AOP代理对象，给目标对象生成一个代理类以及代理类实例，根据解析出的切面，生成通知链设置到代理对象，在代理的回调中会执行通知链。</li>
<li>把AOP代理对象注册到容器中代替目标对象，当使用者向容器请求目标bean时，容器会返回代理对象。</li>
</ol>
<p><strong>切面解析</strong><br><img src="pictures/AOP切面接口.png" alt="AOP切面接口"></p>
<ol>
<li>PointCut：描述切点，在进行切点匹配时，使用ClassFilter进行类匹配，MethodMatcher进行执行方法匹配。</li>
<li>Advice：通知，AfterAdvice后通知，BeforeAdvice前通知，DynamicIntroductionAdvice引用通知，环绕通知通过Interceptor实现。</li>
<li>Advisor：通知器，也就是切面，PointcutAdvisor切点通知器，IntroductionAdvisor引用通知器。</li>
</ol>
<p><strong>aop标签解析</strong></p>
<p>aop名称空间的解析器是AopNamespaceHandler：<br>再AopNamespaceHandler中可以看到aop下各个标签对应的解析器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; for the</span><br><span class="line">	 * &apos;&#123;@code config&#125;&apos;, &apos;&#123;@code spring-configured&#125;&apos;, &apos;&#123;@code aspectj-autoproxy&#125;&apos;</span><br><span class="line">	 * and &apos;&#123;@code scoped-proxy&#125;&apos; tags.</span><br><span class="line">	 */</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		// In 2.0 XSD as well as in 2.1 XSD.</span><br><span class="line">		registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">		// Only in 2.0 XSD: moved to context namespace as of 2.1</span><br><span class="line">		registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在init方法中注册了各个标签的解析器，可以看到aop:config标签的解析器是ConfigBeanDefinitionParser。<br>在ConfigBeanDefinitionParser的parse方法中对aop:config下面的三个直接子标签pointcut、advisor、aspect分别进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">for (Element elt: childElts) &#123;</span><br><span class="line">	String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">	if (POINTCUT.equals(localName)) &#123;</span><br><span class="line">		parsePointcut(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (ADVISOR.equals(localName)) &#123;</span><br><span class="line">		parseAdvisor(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (ASPECT.equals(localName)) &#123;</span><br><span class="line">		parseAspect(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>pointcut标签解析</strong><br>解析器会为pointcut标签创建一个切点bean定义，并且把bean定义注册到容器中，代码在ConfigBeanDefinitionParser类的parsePointcut和createPointcutDefinition方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private AbstractBeanDefinition parsePointcut(Element pointcutElement, ParserContext parserContext) &#123;</span><br><span class="line">	String id = pointcutElement.getAttribute(ID);</span><br><span class="line">	String expression = pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line"></span><br><span class="line">	AbstractBeanDefinition pointcutDefinition = null;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		this.parseState.push(new PointcutEntry(id));</span><br><span class="line">		pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line"></span><br><span class="line">		String pointcutBeanName = id;</span><br><span class="line">		if (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.registerComponent(</span><br><span class="line">				new PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return pointcutDefinition;</span><br><span class="line">&#125;</span><br><span class="line">protected AbstractBeanDefinition createPointcutDefinition(String expression) &#123;</span><br><span class="line">	RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(true);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	return beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该切点bean定义的类型是AspectJExpressionPointcut，这个类同时实现了ClassFilter和MethodMatcher接口执行类匹配和方法匹配逻辑。它有一个expression属性设置表达式，AspectJ最终会把该表达式解析成一个PointcutExpression对象执行相关的语义</p>
<p><strong>aspect标签解析</strong><br>aspect标签的解析要相对复杂一些，扫描它下面的所有通知子标签（aop:before、aop:after等标签）。</p>
<p>1、把这些标签都解析成通知类，通知标签的方法属性（method属性）会被解析成一个MethodLocatingFactoryBean类型的bean，把aspect引用的bean名称（aop:aspect标签的ref属性）和method方法通过属性注入到MethodLocatingFactoryBean类型bean中。</p>
<p>2、生成一个SimpleBeanFactoryAwareAspectInstanceFactory类型的bean，这个bean的作用是用来加载aspect引用的bean，把aspect引用的bean名称通过属性注入到该这个bean中。</p>
<p>3、生成一个通知（Advice）bean。</p>
<p>3.1、把aspect bean id和order（指定通知在通知链中的顺序）通过属性注入到该bean。</p>
<p>3.2、把各个通知标签特有属性注入（比如returning，throwing等属性）。</p>
<p>3.3、把上面生成方法MethodLocatingFactoryBean类型bean通过构造器注入。</p>
<p>3.4、构造子注入引用的切点bean，pointcut或pointcut-ref指定，如果是pointcut-ref属性，直接引用这个bean，如果是pointcut属性，生成一个匿名的切点bean。</p>
<p>3.5、构造子注入上面的SimpleBeanFactoryAwareAspectInstanceFactory类型bean。</p>
<p>通知bean的类型根据标签的不同而不同，aop;before对应AspectJMethodBeforeAdvice，aop:after对应AspectJAfterAdvice，aop:aroude对应AspectJAroundAdvice，在通知方法中通过反射调用method属性中设置的方法。通过ConfigBeanDefinitionParser类的getAdviceClass方法可以看出标签和类的对应关系。</p>
<p><strong>如何使用Spring AOP</strong><br>可以通过文件或则编程的方式来使用Spring AOP</p>
<p>配置可以通过xml文件来进行，大概有四种方式：</p>
<ol>
<li><p>配置ProxyFactoryBean，显式地设置advisors, advice, target等</p>
</li>
<li><p>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</p>
</li>
<li><p>通过<a href="aop:config" target="_blank" rel="noopener">aop:config</a>来配置</p>
</li>
<li><p>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</p>
</li>
</ol>
<p><strong>在Spring中使用AOP编程步骤：</strong></p>
<p>1、在Spring配置文件（applicationContext.xml）中配置Spring对AspectJ的支持；以下两种方式任意一种即可</p>
<p>（1）<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a></p>
<p>（2）&lt; bean class=”org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator” /&gt;</p>
<p>2、引入Jar文件（在Spring的根目录下的lib/aspectj下）<br>     aspectjrt.jar  和  aspectjweaver.jar</p>
<p>3、定义连接点(若不使用接口编程，即SimplePersonManager不实现任何接口，此时要实现AOP代理，需要引入CGLIB 包cglib-nodep-2.1_3.jar，但是一旦实现了接口Spring就会使用JDK的动态代理实现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface PersonManager &#123;  </span><br><span class="line"></span><br><span class="line">    public void addPerson(Person person);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimplePersonManager implements PersonManager&#123;  </span><br><span class="line"></span><br><span class="line">    public void addPerson(Person person) &#123;  </span><br><span class="line">        Person.persons.add(person);  </span><br><span class="line">                System.out.println(&quot;添加了一个用户&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义一个切面类，该切面类中定义了一个切入点，连接点为SimplePersonManager类中的addPerson方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.lang.annotation.Aspect;  </span><br><span class="line">import org.aspectj.lang.annotation.Before;  </span><br><span class="line"></span><br><span class="line">@Aspect  </span><br><span class="line">public class SimpleAspect &#123;  </span><br><span class="line"></span><br><span class="line">    @Before (&quot;execution (* rote.spring.aop.service.impl.SimplePersonManager.addPerson(..))&quot;)  </span><br><span class="line">    public void addPersonAop()&#123;  </span><br><span class="line">        System.out.println(&quot;-------------------addPerson-----------------------&quot;);  </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在Spring配置文件中声明切面类<br>    <!-- 切面声明 --><br>    <bean id="simpleAspectj" class="rote.spring.aop.aspectj.SimpleAspect"><br>    </bean></p>
<p>6、在Spring配置文件中配置连接点类<br>     <bean id="personManager" class="rote.spring.aop.service.impl.SimplePersonManager"><br>    </bean></p>
<p><strong>Spring AOP的XML实现方式，先实现一个接口：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    void printHelloWorld();</span><br><span class="line">    void doPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义两个接口实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldImpl1 implements HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    public void printHelloWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl1.printHelloWorld()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doPrint()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl1.doPrint()&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorldImpl2 implements HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    public void printHelloWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl2.printHelloWorld()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doPrint()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl2.doPrint()&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>横切关注点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler</span><br><span class="line">&#123;</span><br><span class="line">    public void printTime()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;CurrentTime = &quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AOP.xml配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt;</span><br><span class="line">        &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt;</span><br><span class="line">        &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:config&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt;</span><br><span class="line">                &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;</span><br><span class="line">                &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>aspect里面有一个order属性，order属性的数字就是横切关注点的顺序，spring默认以aspect的定义顺序作为织如顺序</p>
<p><strong>Spring AOP代理对象的生成</strong></p>
<p>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * &lt;ol&gt;</span><br><span class="line">    * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)</span><br><span class="line">    * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口</span><br><span class="line">    * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象</span><br><span class="line">    * &lt;/ol&gt;</span><br><span class="line">    */</span><br><span class="line">   public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; +this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line">       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面的问题是，代理对象生成了，那切面是如何织入的？</strong></p>
<p>我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123;</span><br><span class="line">       MethodInvocation invocation = null;</span><br><span class="line">       Object oldProxy = null;</span><br><span class="line">       boolean setProxyContext = false;</span><br><span class="line"></span><br><span class="line">       TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">       Class targetClass = null;</span><br><span class="line">       Object target = null;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           //eqauls()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123;</span><br><span class="line">                return (equals(args[0])? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //hashCode()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123;</span><br><span class="line">                return newInteger(hashCode());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">           if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface()</span><br><span class="line">                    &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                // Service invocations onProxyConfig with the proxy config...</span><br><span class="line">                return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Object retVal = null;</span><br><span class="line"></span><br><span class="line">           if (this.advised.exposeProxy) &#123;</span><br><span class="line">                // Make invocation available ifnecessary.</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //获得目标对象的类</span><br><span class="line">           target = targetSource.getTarget();</span><br><span class="line">           if (target != null) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //获取可以应用到此方法上的Interceptor列表</span><br><span class="line">           List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);</span><br><span class="line"></span><br><span class="line">           //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">           if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Massage return value if necessary.</span><br><span class="line">           if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy)</span><br><span class="line">                    &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                // Special case: it returned&quot;this&quot; and the return type of the method</span><br><span class="line">                // is type-compatible. Notethat we can&apos;t help if the target sets</span><br><span class="line">                // a reference to itself inanother returned object.</span><br><span class="line">                retVal = proxy;</span><br><span class="line">           &#125;</span><br><span class="line">           return retVal;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                // Must have come fromTargetSource.</span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line">           if (setProxyContext) &#123;</span><br><span class="line">                // Restore old proxy.</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下：</strong></p>
<p>首先，从上面的代码可以看到，通知链是通过Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看下这个方法的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt;getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;</span><br><span class="line">                   MethodCacheKeycacheKey = new MethodCacheKey(method);</span><br><span class="line">                   List&lt;Object&gt;cached = this.methodCache.get(cacheKey);</span><br><span class="line">                   if(cached == null) &#123;</span><br><span class="line">                            cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                                               this,method, targetClass);</span><br><span class="line">                            this.methodCache.put(cacheKey,cached);</span><br><span class="line">                   &#125;</span><br><span class="line">                   returncached;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。</p>
<p>下面来分析下这个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,</span><br><span class="line">    * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断</span><br><span class="line">    * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.</span><br><span class="line">    */</span><br><span class="line">    publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123;</span><br><span class="line">       // This is somewhat tricky... we have to process introductions first,</span><br><span class="line">       // but we need to preserve order in the ultimate list.</span><br><span class="line">       List interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line"></span><br><span class="line">       //查看是否包含IntroductionAdvisor</span><br><span class="line">       boolean hasIntroductions = hasMatchingIntroductions(config,targetClass);</span><br><span class="line"></span><br><span class="line">       //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor</span><br><span class="line">       AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">       Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        for (int i = 0; i &lt;advisors.length; i++) &#123;</span><br><span class="line">           Advisor advisor = advisors[i];</span><br><span class="line">           if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">                // Add it conditionally.</span><br><span class="line">                PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    //TODO: 这个地方这两个方法的位置可以互换下</span><br><span class="line">                    //将Advisor转化成Interceptor</span><br><span class="line">                    MethodInterceptor[]interceptors = registry.getInterceptors(advisor);</span><br><span class="line"></span><br><span class="line">                    //检查当前advisor的pointcut是否可以匹配当前方法</span><br><span class="line">                    MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"></span><br><span class="line">                    if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">                        if(mm.isRuntime()) &#123;</span><br><span class="line">                            // Creating a newobject instance in the getInterceptors() method</span><br><span class="line">                            // isn&apos;t a problemas we normally cache created chains.</span><br><span class="line">                            for (intj = 0; j &lt; interceptors.length; j++) &#123;</span><br><span class="line">                               interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else if (advisor instanceof IntroductionAdvisor)&#123;</span><br><span class="line">                IntroductionAdvisor ia =(IntroductionAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors= registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                Interceptor[] interceptors =registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor.</p>
<p>接下来我们再看下得到的拦截器链是怎么起作用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">       //  We start with an index of -1and increment early.</span><br><span class="line">       if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123;</span><br><span class="line">           //如果Interceptor执行完了，则执行joinPoint</span><br><span class="line">           return invokeJoinpoint();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Object interceptorOrInterceptionAdvice =</span><br><span class="line">           this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line"></span><br><span class="line">       //如果要动态匹配joinPoint</span><br><span class="line">       if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)&#123;</span><br><span class="line">           // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">           // been evaluated and found to match.</span><br><span class="line">           InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">           //动态匹配：运行时参数是否满足匹配条件</span><br><span class="line">           if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123;</span><br><span class="line">                //执行当前Intercetpor</span><br><span class="line">                returndm.interceptor.invoke(this);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">                //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class="line">                return proceed();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // It&apos;s an interceptor, so we just invoke it: The pointcutwill have</span><br><span class="line">           // been evaluated statically before this object was constructed.</span><br><span class="line">           //执行当前Intercetpor</span><br><span class="line">           return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8A%E7%AF%87/" target="_blank" rel="noopener">Spring AOP与IOC</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/springAOP/" data-id="cjuajt8rz000jfcamvnsjolem" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/08/动态代理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2019/03/25/dubbo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>

  
    
  <h5>RECENT POSTS
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2019/04/08/动态代理/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/04/08/springAOP/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/25/dubbo/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/22/操作系统_存储器管理和虚拟存储器/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/21/操作系统_处理机的调度与死锁/">(no title)</a>
        </li>
      
    </ul>
  </div>
</h5>
  
    <!-- Friends Blog -->

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>