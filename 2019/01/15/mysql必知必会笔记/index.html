<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>mysql必知必会笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="chapter3  了解数据库和表DOS命令行登录指令：mysql -u 用户名 -p   然后回撤，键入password；每一条mysql语句必须以“;”结束才能正确执行选择数据库：use 数据库名；查看数据库的信息：show databases;返回一个数据库列表；查看数据库内表的列表：show tables；查看某一个表的表列：show columns from 表名；每一个字段返回一行，也">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql必知必会笔记">
<meta property="og:url" content="http://yoursite.com/2019/01/15/mysql必知必会笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="chapter3  了解数据库和表DOS命令行登录指令：mysql -u 用户名 -p   然后回撤，键入password；每一条mysql语句必须以“;”结束才能正确执行选择数据库：use 数据库名；查看数据库的信息：show databases;返回一个数据库列表；查看数据库内表的列表：show tables；查看某一个表的表列：show columns from 表名；每一个字段返回一行，也">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-22T08:19:16.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mysql必知必会笔记">
<meta name="twitter:description" content="chapter3  了解数据库和表DOS命令行登录指令：mysql -u 用户名 -p   然后回撤，键入password；每一条mysql语句必须以“;”结束才能正确执行选择数据库：use 数据库名；查看数据库的信息：show databases;返回一个数据库列表；查看数据库内表的列表：show tables；查看某一个表的表列：show columns from 表名；每一个字段返回一行，也">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-mysql必知必会笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/15/mysql必知必会笔记/" class="article-date">
  <time datetime="2019-01-15T05:41:05.000Z" itemprop="datePublished">2019-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      mysql必知必会笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="chapter3-了解数据库和表"><a href="#chapter3-了解数据库和表" class="headerlink" title="chapter3  了解数据库和表"></a>chapter3  了解数据库和表</h1><p>DOS命令行登录指令：mysql -u 用户名 -p   然后回撤，键入password；<br>每一条mysql语句必须以“;”结束才能正确执行<br>选择数据库：use 数据库名；<br>查看数据库的信息：show databases;返回一个数据库列表；<br>查看数据库内表的列表：show tables；<br>查看某一个表的表列：show columns from 表名；每一个字段返回一行，也可以使用describe 表名；来查看表的信息<br>查看用来创建特定数据库的mysql语句：show create database 数据库名；<br>查看用来创建特定表的mysql语句：show create table 表名；</p>
<h1 id="chapter4-检索数据"><a href="#chapter4-检索数据" class="headerlink" title="chapter4 检索数据"></a>chapter4 检索数据</h1><h4 id="检索单个列表"><a href="#检索单个列表" class="headerlink" title="检索单个列表"></a>检索单个列表</h4><p>命令：select 列名 from 表名；<br>所需列名在select关键字后面给出，from给出从其中检索数据的表名。<br>SQL语句不区分大小写，但是便于阅读和调试，对所有的关键字使用大写，所有的列名和表名都使用小写。<br>在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。</p>
<h4 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h4><p>命令： SELECT 列名，列名，列名 FROM 表名；<br>选择多个列时，要在列名中间加逗号，但最后一个列名后不加</p>
<h4 id="检索所有的列"><a href="#检索所有的列" class="headerlink" title="检索所有的列"></a>检索所有的列</h4><p>命令：SELECT <em> FROM 表名；<br>如果给定一个通配符(</em>),则返回列表的所有列<br>一般除非你确实你需要表中的每个列，否则不要使用通配符，检索不需要的列通常会降低检索和应用程序的性能</p>
<h4 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h4><p>当你检索某一个字段时，会检索这个字段的所有行，但是可能这些行中有许多相同的字段，而你只需不同的字段，这时你只需要使用 DISTINCT关键字；<br>命令：SELECT DISTINCT 列名 FROM 表名；<br>DINSTINCT关键字必须放在列名的前面<br>不能不分使用DISTINCT<br>DINSTINCT关键字应用于所有列而不仅仅是前置它的列。如果给出 SELECT DISCINCT 列名，列名 FROM 表名；除非指定的列不同，否则所有行都将被检索出来。<br>也就是同时指定了两个字段，就是两个字段的字都是相同的行才会被排除在外。</p>
<h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p>SELECT语句返回所有匹配的行，他们可能是指定表中的每个行，为了返回第一行或前几行，课使用LIMIT句子：<br>命令：SELENT 列名 FROM 表名  LIMIT num；<br>例：如果num=5，则返回的结果不多以5行，如果想显示后五行这可以使用：<br>命令：SELECT 列名 FROM 表名 LIMIT 5,5；这样就会显示从第六行到第10行的内容；<br>其中第一个数为开始检索的位置，第二个数为检索的条数。</p>
<p>带一个值的LIMIT总是从第一行开始，给出的数为返回的行数，带两个值的LIMIT可以指定从行号为第一个值的位置开始。</p>
<p>行0    检测出来的第一行为行0而不是行1，因此LIMIT 1,1，将检测出第二行而不是第一行。</p>
<p>行数不够时，只返回能返回的行。</p>
<h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>SELECT  表名.列名  from 数据库名.表名</p>
<h1 id="chapter5-排序检索数据"><a href="#chapter5-排序检索数据" class="headerlink" title="chapter5 排序检索数据"></a>chapter5 排序检索数据</h1><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><p>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义<br>为了明确地排序用SELECT语句检索出的数据，可使用 ORDER BY子句。ORDER BY 子句取一个或多个列的名字，据此对输出进行排序。<br>命令：SELECT  列名  FROM  表名  ORDER  BY  列</p>
<h4 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h4><p>按多个列排序，只需要指定列名，列名之间用逗号分开即可：<br>SELECT 列名1，列名2，列名3 FROM 表名  ORDER BY 列名1，列名2；<br>检索出数据后，先按列名1排序，再按列名2排序。要注意：只有在有相同的列名1时，才对列名2进行排序</p>
<h4 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h4><p>数据排序不限于升序（A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（Z到A）顺序排序，为了进行降序排序必须z指定DESC 关键字。<br>命令行：SELECT 列名1，列名2，列名3 FROM 表名  ORDER BY 列名1 DESC；</p>
<p>DESC关键字只能应用到直接位于其前面的列名，如果想在多个列之间进行排序，必须对每个列指定DESC关键字<br>命令：SELECT 列名1，列名2，列名3 FROM 表名 ORDER BY 列名1 DESC，列名2 DESC；</p>
<p>与DESC相反的关键字是ASC，不过默认的都是升序  </p>
<p>ORDER  BY子句的位置<br>在给出ORDER BY子句时，应该保证它位于FROM子句之后，如果使用LIMIT，它必须位于ORDER BY之后。使用的次序不对将产生错误消息。   </p>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h4 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h4><p>在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出：<br>命令：SELECT 列名1，列名2 FROM 表名 WHERE 列名=值<br>where子句的位置，在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后            </p>
<p>####WHERE子句操作符<br>（1）= 等于 （2）&lt;&gt; 不等于（3）!=  不等于（4） &lt; 小于 （5）&lt;= 小于等于  （6）&gt; 大于<br>（7） &gt;= 大于等于  （8） BETWEEN  在指定的两个值之间<br>在编写sql语句时何时使用引号：<br>如果将值与串类型的列进行比较，则需要限定限定引号。用来与数值列进行比较的值不用引号</p>
<h5 id="范围值查找"><a href="#范围值查找" class="headerlink" title="范围值查找"></a>范围值查找</h5><p>命令： SELECT 列名1，列名2 FROM 表名 WHERE BETWEEN 值1  AND 值2；<br>在使用BETWEEN时，必须指定两个值–所需范围的低端值和高端值。这两个值必须用AND关键字分割。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p>
<p>#####空值检查<br>NULL 无值，它与字段包含0，空字符串或仅仅包含空格不同。<br>SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列，这个WHERE语句就是  IS NULL<br>命令：SELECT  列名1 FROM  表名 WHERE 列名2 IS NULL；<br>此条语句会查询出列2为NULL值的列名1的字段</p>
<p>NULL与不匹配</p>
<p>在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊含义，数据库不知道他们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p>
<p>因此在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行</p>
<h1 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h1><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><p>Mysql允许给出多个WHERE子句。这些子句可以以两种方式使用：以AND子句的方式或OR子句的方式</p>
<h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a>AND操作符</h3><p>为了通过不止一个列进行过滤，可使用AND操作符给WHERE子句附条件<br>命令：SELECT 列名1，列名2，列名3  FROM  表名  WHERE  列名1=值  AND 列名2&lt;=z值;</p>
<h3 id="OR操作符"><a href="#OR操作符" class="headerlink" title="OR操作符"></a>OR操作符</h3><p>OR操作符与AND操作符不同，它指示MYSQL检索匹配任一条件的行<br>命令：<br>命令：SELECT 列名1，列名2，列名3  FROM  表名  WHERE  列名1=值  OR 列名2&lt;=z值;</p>
<h3 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h3><p>WHERE可以包含任意数量的AND和OR操作符，允许两者结合以进行复杂和高级的过滤<br>AND在计算次序中的优先级比OR高，对于这种情况有时可以使用括号进行分组<br>命令：SELECT 列名1,列名2,列名3 FROM 表 WHERE （列名1=值 OR 列名2&lt;=值）AND 列名3=值</p>
<h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><p>圆括号在WHERE子句中海油另外一种用法。IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取的合法值是由逗号分隔的清单，全部括在圆括号中。<br>例如：IN操作符后面跟有  逗号  分隔的清单，整个清单必须在圆括号中<br>命令：SELECT 列名1，列名2，列名3 FROM 表 WHERE 字段 IN（值1，值2）ORDER  BY  列名；<br>使用IN操作符的优点：<br>（1）    在使用长的合法选项清单时，IN操作符的语法更清楚且更直观<br>（2）    在使用IN时，计算的次序更容易管理<br>（3）    IN操作符一般比OR操作符清单执行更快<br>（4）    IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</p>
<p>##NOT操作符<br>WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件<br>例：SELECT 列名1，列名2，列名3  FROM 表名 WHERE  字段1 NOT IN（值1，值2）ORDER BY 字段2；</p>
<p>MYSQL支持使用NOT对IN，BETWEEN和EXISTS子句取反，这与多数其他的DBMS允许使用NOT对各种条件取反有很大的差别</p>
<p>#用通配符进行过滤</p>
<h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><p>通配符：用来匹配值的一部分的特殊字符</p>
<h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p>在搜索中，%表示任何字符出现任意次数<br>例如：SELECT 列名1，列名2，列名3 FROM 表名 WHERE 列名1  LIKE ‘jet%’;<br>在执行这条子句时，将检索任意以jet起头的词。%告诉MYSQL接收jet之后的任意字符，不管它有多少字符。<br>通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。<br>SELECT 列名1，列名2 FROM  表名  WHERE  字段  LIKE ‘%jet%’;匹配包含’jet’的文本。<br>SELECT 列名1，列名2 FROM  表名  WHERE  字段  LIKE  ‘s%e’;匹配以s开头和以e结尾的文本。<br>尾空格可能会干扰通配符的匹配。注意 ‘%’不能匹配 NULL值</p>
<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（-）通配符"></a>下划线（-）通配符</h3><p>另外一个有用的通配符是下划线（-）。下划线的用途与%一样，单下划线只匹配单个字符而不是多个字符。<br>与%能匹配0个字符不一样，（-）总是匹配一个字符，不能多也不能少。</p>
<p>###通配符的几个技巧<br>（1）    不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。(搜索速度慢)<br>（2）    在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的额开始出。把通配符置于搜索模式的开始处，搜索起来是最慢的。<br>（3）    仔细注意通配符的位置。如果放错地方，可能不会反悔想要的数据。</p>
<h1 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h1><p>##基本的字符匹配<br>例：SELECT 列名1 FROM 表 WHERE  列名1 REGEXP ‘1000’ORDER  BY 列名1；</p>
<p>LIKE与REGEXP之间的差别：<br>SELECT 列名1 FROM 表 WHERE  列名1  LIKE ‘1000’ORDER  BY 列名1；<br>SELECT 列名1 FROM 表 WHERE  列名1  REGEXP ‘1000’ORDER  BY 列名1；<br>执行上面的两条语句，第一条不会返回数据，而第二条语句返回一行</p>
<p>LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回</p>
<h3 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h3><p>为搜索两个串之一，使用 |<br>例如：SELECT 列名1，列名2 FROM 表名 WHERE 列名 REGEXP  ‘1000|2000’ ORDER BY字段;</p>
<h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h3><p>匹配任何单一字符。如果想要匹配匹配特定字符，可通过指定一组用[]括起来的字符来完成例如：<br>SELECT 列名1 FROM WHERE 字段1 REGEXP ‘[123]TOM‘;<br>[123]意识是匹配1或2或3<br>集合也可以被否定，即他们将匹配除指定字符外的任何东西。<br>为一个否定字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1,2或3；但[^123]却匹配出这些字符外的任何东西</p>
<p>###范围匹配<br>集合可用来定义要匹配的一个或多个字符  例:[123456789]<br>为了简化这种类型的集合，可以使用‘-‘   [1-9]<br>范围不限于数字  字符也是可以的  [a-z]</p>
<p>###匹配特殊字符<br>‘.‘匹配任意字符<br>为了匹配特殊字符，必须用\为前导。\-表示查找-，\.表示查找’ . ’;</p>
<h3 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h3><p>重复单元符：<br>（1）     0个或多个匹配 （2） +  1个或多个匹配 （3）？ 0个或1个匹配<br>（4）{n}  指定数目的匹配 （5）{n,} 不少于指定数目的匹配  (6)（n,m）匹配数目的范围（m不超过255）</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>为了匹配特定位置的文本需要使用定位符<br>（1）^  文本的开始（2） $ 文本的结尾（3）[[:&lt;:]] 词的开始（4）[[:&gt;:]] 词的结尾</p>
<h1 id="chapter10-创建计算字段"><a href="#chapter10-创建计算字段" class="headerlink" title="chapter10  创建计算字段"></a>chapter10  创建计算字段</h1><p>##字段拼接<br>将值连接到一起构成单个值，可以利用CONCAT（）函数将两个列拼接起来；<br>多数的DBMS使用+或||来实现拼接，Mysql则使用Concat（）函数来实现。<br>示例：SELECT CONCAT（列名1,’(‘,列名2，‘)’) From 表名 ORDER BY 列名；<br>CONCAT（）拼接串，即把多个串连接起来形成一个较长的串，需要一个或多个指定的串，各个串之间用逗号分隔</p>
<p>如果要删除数据右侧的空格，则可以使用RTRIM（）函数来完成<br>例如：<br>命令：SELECT CONCAT（RTrim（列名1），’(‘,RTrim(列名2)，’)’）FROM 表名;<br>RTRIM（字段）去掉值右边所有的空格。去除右边的空格用Ltrim();</p>
<h2 id="使用别名’"><a href="#使用别名’" class="headerlink" title="使用别名’"></a>使用别名’</h2><p>SQl语句中的别名用AS关键字赋予.<br>命令：SELECT CONCAT（RTrim（列名1），‘（’，RTRIM（列名2），’)’） AS 别名 FROM 表名；</p>
<h2 id="执行算数计算"><a href="#执行算数计算" class="headerlink" title="执行算数计算"></a>执行算数计算</h2><p>MYSQL算术操作表：（1）+  加（2） -  减号（3）<em> 乘（4）/<br>命令：SELECT  列名1，列名2，列名1</em>列名2 AS 别名 FROM 表名 WHERE 列名1=值；<br>另外SELECT Now（）利用Now（）函数返回当前日期和时间。</p>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><p>UPPER（字段）函数将文本转换为大写<br>常用的文本处理函数：<br>（1）left()  返回串左边的字符  （2）Length（）  返回串的长度<br>（3）Locate（）找出串的一个子串 （4）Lower（）  将串转换为小写<br>（5）Ltrim()  去掉串左边的空格  （6）Right（）  返回串右边的字符<br>（7）Rtrim()  去掉串右边的空格  （8）Soundex()  返回串的SOUDEX值<br>（9）SubString() 返回子串的字符  （10）Upper()  将串转换为大写</p>
<p>其中Soundex()考虑了类的发音字符和音节，使得能对串进行发音比较而不是字符字母比较<br>例如：SELECT 列名1，列名2 FROM 表名 WHERE Soundex（列名1）=Soundex（’Y Lie’）;</p>
<h2 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h2><p>日期和时间采用响应的数据类型和特殊的格式存储，以便能快速和有效地排序和过滤<br>不过是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd；应该总是使用4位数字的年份。</p>
<p>DATE(order_date)函数只是MySQL仅提取列的日期部分，当然如果只想要时间值可以使用TIME（）函数</p>
<p>如果先要单独的提取某年某月的数据则可以使用以下指令：<br>SELECT  列名1，列名2 FROM 表名  WHERE DATE（日期字段） BETWEEN ‘2005-09-01’ AND ‘2005-09-30’;<br>另外还可以使用：<br>SELECT 列名1，列名2 FROM 表名  WHERE YEAR（日期字段）=2005 AND MONTH（日期字段）=9；</p>
<h2 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h2><p>常用的数字处理函数：<br>函数:(1) abs()   返回一个数的绝对值   （2）Cos（）  返回一个角度的余弦 （3）Exp（）  返回一个数的指数值<br>（4）Mod（）  返回除操作的余数（5）Pi  返回圆周率  （6）Rand（）  返回一个随机数<br>（7）Sin（）  返回一个角度的正弦  （8）Sqrt()   返回一个数的平方根  （9） Tan（）  返回一个角度的正切。</p>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>（1）AVG（）   返回某列的平均值  （2）COUNT（）  返回某列的行数<br>（3）MAX（）   返回某列的最大值  （4）MIN（）  返回某列的最小值<br>（5）SUM（）   返回某列值之和</p>
<h3 id="AVG（）"><a href="#AVG（）" class="headerlink" title="AVG（）"></a>AVG（）</h3><p>命令：SELECT AVG（列1） AS 别名  FROM 表名； 返回所有列的平均值<br>命令：SELECT AVG（字段） AS  别名  FROM 表名 WHERE  字段=值；用来确定特定列或行的平均值；<br>AVG（）函数忽略列值为NULL的行，如果要获得多个列的平均值，必须使用多个AVG（）函数</p>
<h3 id="COUNT（）"><a href="#COUNT（）" class="headerlink" title="COUNT（）"></a>COUNT（）</h3><p>COUNT（）函数有两种使用方式<br>（1）COUNT（*）对表中的行的数目进行计数，不管列表中包含的是空值（NULL）还是非空置<br>（2）COUNT（column） 对特定列中具有值的行进行计数，忽略NULL值  </p>
<p>另外MIN（），MAX（），SUM（）函数忽略列值为NULL的行。</p>
<h2 id="聚集不同的值"><a href="#聚集不同的值" class="headerlink" title="聚集不同的值"></a>聚集不同的值</h2><p>（1）对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）<br>（2）只包含不同的值，指定DISTINCT</p>
<p>ALL为默认  ALL参数不需要指定，因为它是默认行为。如果不指定DISTINCT，则假定为ALL；</p>
<p>命令：SELECT  AVG（DISNTINCT 列名） AS 别名 FROM 表名；</p>
<p>如果指定列名，则DISTINCT只用用于COUNT（）。DISCINCT不能用于COUNT（*）；  DISTINCT必须使用列名，不能用于计算或表达式</p>
<h2 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h2><p>组合聚集函数用逗号隔开；<br>命令：SELECT COUNT（*） AS 别名，MAX（列名） AS 别名 ，MIN（列名） AS 别名  FROM  表名；</p>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p> ##创建分组<br> 分组是在SELECT语句的GROUP BY子句中建立的<br> 命令：SELECT 列名1  COUNT（*） AS 别名  FROM  表名 GROUP BY 列名1；<br> GROUP BY  会按照  列名1 的值进行分组  ，相同的值分为一组<br> 使用GROUP BY 不必指定要计算和估值的每个分组。系统会自动完成。GROUP BY子句指示MYSQL分组数据，然后对每个分组而不是整个结果集进行聚集。</p>
<p> 再具体使用GROUP BY子句前，需要注意的：</p>
<pre><code>（1）GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。
（2）如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算
（3）GROUP BY子句中列出的每个列都必须是检索列或有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。
（4）除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出
（5） 如果分组中给出具有NULL值，则NULL将作为一个分组返回。如果列中有多个NULL值，他们讲分为一组。
（6）GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前
</code></pre><h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>MYSQL过滤分组不是使用WHERE，而是使用HAVING来代替。<br>HAVING非常类似于WHERE，目前为止所学过的所有类型的WHERE子句都可以用HAVING来代替。唯一的差别是WHERE是过滤行，而HAVING过滤分组。<br>命令：<br>SELECT  列名1，COUNT（<em>） AS 别名  FROM 表名 GROUP BY 列名1 HAVING COUNT（</em>）&gt;=2;        </p>
<p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中。</p>
<p>命令：SELECT 列名1，COUNT（<em>） AS 别名 FROM 表名 WHERE 列名2 &gt;= 值 GROUP BY 列名1 HAVING COUNT（</em>）&gt;=值。</p>
<h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><p>GROUP BY和ORDER BY经常完成相同的工作，但他们是非常不同的。<br>ORDER BY：<br>排序产生的输出；任意列都可以使用（甚至非选择的列也可以使用）</p>
<p>GROUP BY：<br>分组行。但输出可能不是分组的顺序；只可能使用选择列或则表达式，而且必须使用每个选择列表达式；如果与聚集函数一起使用列，则必须使用</p>
<p>命令：SELECT 列名1，SUM（列名2<em>列名3） AS 别名 GROUP BY 列名1 HAVING SUM（列名2</em>列名3）&gt;=值 ORDER BY 别名；</p>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>在SELECT语句使用时必须遵循的次序：          </p>
<p>######（1）SELECT    要返回的列或表达式          必须使用      </p>
<p>######（2）FROM    从中检索数据的表      仅在从表选择数据时使用                       </p>
<p>######（3） WHERE  行级过滤    不一定要使用                                   </p>
<p>######（4）GROUP BY  分组说明    仅在按组计算聚集时使用                  </p>
<p>######（5）HAVING  组级过滤     不一定要使用                    </p>
<p>######（6）ORDER BY  输出顺序排序   不一定要使用              </p>
<p>######（7）LIMIT  要检索的行数    不一定要使用</p>
<p>#使用子查询<br>嵌套在其他查询语句中的查询<br>可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE查询<br>在SELECT语句时，子查询总是从内向外处理                                   </p>
<p>命令：SELECT  列名1，列名2 FROM 表名 WHERE 列名3 IN（SELECT 列名3 FROM 表名）；</p>
<p>对于嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。</p>
<pre><code>列必须匹配   在WHERE子句使用子查询，应该保证SELECT语句具有与WHERE子句相同数目的列。通常，子查询返货单个列并且与单个列匹配，但如果需要也可以使用多个列。
</code></pre><h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>命令：SELECT 列名1，列名2 （SELECT COUNT（*） FROM 表名1 WHERE 表名1.列名3=表名2.列名3） AS别名  FROM 表名2 ORDER BY 字段1；</p>
<p>相关子查询   在涉及外部查询的子查询时，任何时候只要列名可能又多义性，就不许使用语法（表名和列名由一个句点分隔）</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>######外键<br>外键为某个表的一列，它包含另一个表的主键值<br>例如：<br>命令：SELECT vend_name,prod_name,prod_price FROM vendors,products WHERE vendors.vend_id=products.vend_id ORDER BY vend_name,prod_name;</p>
<p>vendors和products是两个表</p>
<h2 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h2><p>在一条SELECT语句中联结几个表时，相应的关系是运行中构造的，在数据库表的定义中不存在能指示Mysql如何如何对表进行联结的东西，必须要自己做这件事情</p>
<pre><code>笛卡尔积：由于没有联结条件的表关系返回的结果为笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。
</code></pre><h2 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h2><p>  目前为止所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也称为内部联结。</p>
<p>命令：SELECT 列名1，列名2，列名3 FROM  表名1  INNER  JOIN  表名2  ON  表名1.列名4=表名2.列名5；<br>联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p>
<h3 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h3><pre><code>一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。
命令：SELECT 列名1，列名2，列名3 FROM 表1，表2，表3 WHERE 表1.列1=表2.列2 AND 表2.列1=表3.列1 AND  列名=值；
</code></pre><h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><p>SQL允许给表名其别名的理由：<br>    （1）缩短SQL语句<br>    （2）允许在单挑SELECT语句中多次使用相同的表</p>
<h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>使用联结来查询<br>      SELECT p1.列名1，p2.列名2 FROM 表名1 AS  别名1， 表名1 AS 别名2  WHERE p1.列名=p2.列名 AND p2.列名2=值</p>
<h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h4><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中，标准的联结返回所有数据，甚至相同的列出现多次。自然联结排除多次出现，使每个列只返回一次。</p>
<pre><code>自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。
</code></pre><p>SELECT c.* ,o.列名 FROM 表名1 AS c，表名2 AS o WHERE c.列名=o.列名 AND 字段=值；<br>在上面这条语句中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来</p>
<h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><p>例如：<br>   SELECT customers.cust_id,orders.order_num FROM customers LEFT OUTER JOIN orders ON customers.cust_id=orders.cust_id;</p>
<p>   键值OUTER JOIN来指定联结的类型。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联的行。在使用OUTER JOIN 语法时，必须使用RIGHT 或LEFT关键字指定包括其所有行的表。上面的例子使用LEFT OUTER JOIN 从FROM子句的左边表中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN。</p>
<p>####使用带聚集函数的联结</p>
<pre><code>命令：SELECT  customers.cust_name customers.cust_id COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers_cust_id=orders.cust_id;
</code></pre><p>此SELECT语句使用INNER JOIN将customers和orders表互相关联。函数调用 COUNT(orders.order_num)对每个客户的订单计数，将他作为num_ord返回。</p>
<p>#组合查询</p>
<p>###组合查询<br>MYSQL允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或符合查询</p>
<p>有两种情况需要使用组合查询<br>      （1）在单个查询中从不同的表返回类似结构的数据；<br>      （2）对单个表执行多个查询，按单个查询返回数据</p>
<h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><pre><code>利用UNION操作符来组合数条SQL查询
</code></pre><p>####使用UNION<br>UNION的使用很简单所做的只是给出每条SELECT语句，在各条语句之间方上关键字UNION</p>
<p>UNION中的每个查询必须相同的列，表达式或聚集函数</p>
<pre><code>UNION从查询结果中会自动出去重复的行，这是UNION的默认行为，但是如果需要，可以改变它，想要返回所有匹配的行，可使用UNION ALL
</code></pre><p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询是，只能使用一条ORDER BY子句，他必须出现在最后一条SELECT语句之后。</p>
<p>#全文本搜索</p>
<p>##使用全文本搜索</p>
<p>###启用全文本搜索支持<br>一般在创建表时启用全文本搜索。CREATE  TABLE 语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔列表：<br>示例：<br>CREATE TABLE 表名{<br>Note_id  int  NOT NULL AUTO_INCREMENT,<br>Prod_id  char(10)  NOT NULL,<br>Note_date  datetime  NOT null,<br>Noet_text  text  null,<br>PRIMARY KEY(Note_id),<br>FULLTEXT(Note_text)<br>}<br>这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据子句FULLTEXT（note_text）的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要你也可以指定多个列。</p>
<p>在定义之后，MySQL自动维护该索引。在增加，更新或删除行时，索引随之自动更新。</p>
<h2 id="进行全文搜索"><a href="#进行全文搜索" class="headerlink" title="进行全文搜索"></a>进行全文搜索</h2><p>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<p>命令：SELECT note_text FROM 表名 WHERE  Match（note_text）Against(‘rabbit’);</p>
<p>Match(note_text)指示MySQL针对指定的列进行搜索，Against（’rabbit’）指定词rabbit作为搜索文本</p>
<p>使用完整的Match()说明  传递给Match()的值必须与FULLTEXT（）定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）。</p>
<p>搜索不区分大小写</p>
<p>全文搜索一个重要的部分就是对结果排序。具有较高等级的行先行返回</p>
<p>##使用查询扩展<br>（1）    首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行。</p>
<p>（2）    其次，MYSQL检查这些匹配行并选择所有有用的词</p>
<p>（3）    再其次，MYSQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词</p>
<p>使用扩展查询：<br>SELECT  列名 FROM 表名 WHERE Match（列名） Against（’要搜索的文本’ WITH QUERY EXPANSION）；</p>
<p>###布尔文本搜索</p>
<ol>
<li><p>要匹配的词</p>
</li>
<li><p>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）</p>
</li>
<li><p>排列提示（指定某些词比其他词更重要，更重要的词等级更高）；</p>
</li>
<li><p>表达式分组</p>
</li>
<li><p>另外一些内容</p>
</li>
</ol>
<p>即使没有FULLTEXT索引也可以使用</p>
<p>例如：SELECT 列名 FROM 表名 WHERE Match(列名) Against（’heavy –rope*’ IN BOOLEAN MODE）;返回包含 heavy  但排除 rope的行</p>
<p>#插入数据<br>INSERT是用来插入行到数据库表的，插入可以你几种方式使用：<br>（1）    插入完整的行；<br>（2）    插入行的一部分<br>（3）    插入多行<br>（4）    插入某些查询的结果</p>
<p>##插入完整的行<br>INSERT  表名（字段1，字段2，字段3）VALUES（值1，值2，值3）；<br>对每个列必须提供一个值</p>
<p>省略列：<br>满足一下条件：<br>（1）    该列定义为允许NULl值<br>（2）    在表定义中给出默认值，这表示如果不给出值，将使用默认值</p>
<p>插入多个行<br>命令：INSERT INTO 表名（字段1，字段2，字段3）VALUES（值1，值2，值3），（值1，值2，值3）；</p>
<h2 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h2><p>INSERT INTO 表名（字段1，字段2，字段3）SELECT  字段1，字段2，字段3  FROM 表名；</p>
<p>#更新和删除数据<br>为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：<br>（1）    更新表中特定行；<br>（2）    更新表中所有行。<br>命令:UPDATE  表名 SET 字段1=值1，字段2=值2 WHERE 字段3=值3；</p>
<p>IGNORE关键字  如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出现一盒错误，整个UPDATE操作被取消（错误放生前更新的所有行被恢复到它们原来的值）。即使发生错误，也要继续更新，可使用IGNORE关键字：UPDATE  IGNORE  表名 ……</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>（1）    从表中删除特定的行<br>（2）    从表中删除所有行<br>命令：DELETE FROM 表名 WHERE 字段=值</p>
<p>#创建和操纵表</p>
<p>##表创建基础<br>为利用CREATE TABLE 创建表：<br>（1）    新表的名字，在关键字CREATE TABLE之后给出；<br>（2）    表列的名字和定义你，用逗号分隔。<br>实际的表定义括在圆括号之中，各列之间用逗号分隔，表的主键可以在创建表时用PRIMARY KEY（字段）关键字指定。整条语句由圆括号后的分号结束。</p>
<p>如果你仅想在一个表不存在时创建它，应该在表名后给出IF  NOT  EXISTS。</p>
<h2 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h2><p>NULL值就是没有值或缺值。允许NNU’LL值的列也允许在插入行时不给出该列的值。不允许NULL值的列不接受该列没有值的行，换句话说，在插入和更新行时该列必须有值。</p>
<p>每个表列或者是NULL列，或则是NOT NULl列，这种状态在创建时由表的定义规定。<br>CREATE TABLE orders（<br>  Num INT  NOT NULL AUTO_INCREMENT,<br>  Date  datetime  NOT NULL,<br>  Id  int NOT NULL,<br>  PRIMARY KEY (id)<br>）<br>三个列都需要值，因此三个列都含有关键字NOT NULL<br>不指定NOT NULL时，默认是NULL值</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键值必须唯一。表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一</p>
<p>主键只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识</p>
<p>###AUTO_INCREMENT<br>每当增加一行时自动增长</p>
<p>###指定默认值<br>如果在插入时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的GEFAULT关键字指定。<br>例：quantity  int  NOT  NULL  DEAFULT  1,</p>
<p>##更新表<br>为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，当表中存储数据以后，该表就不应该再被更新</p>
<p>ALTER  TABLE  表名<br>ADD  字段   类型,    //添加一个列<br>DROP  COLUMN   列名，  //删除一个列</p>
<p>ALTER TABLE的一种常见用途是定义外键</p>
<p>ALTER  TABLE  表名<br>ADD  CONSTRAINT   fk_order_orders   FOREING  KEY (order_num)  REFERENCES  orders(prod_id);</p>
<p>##删除表<br>DROP  TABLE  表名；</p>
<p>####重命名表<br>RENAME  TABLE 原表名  TO  新表名</p>
<p>#chapter 22  使用视图<br>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p>
<h2 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h2><p>（1） 重用SQL语句<br>（2）简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节<br>（3）使用表的组成部分而不是整个表<br>（4）保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限<br>（5）更改数据格式和表示，视图可以返回与底层表的表示和格式不同的数据                </p>
<p>性能问题：因为视图不包含数据，所以每次使用视图时都必须处理查询执行时所需的任一个检索</p>
<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图创建：<br>（1）视图用CREATE VIEW 语句来创建。<br>（2）使用SHOW CREATE VIEW 视图名；来查看创建视图的语句；<br>（3）使用DROP删除视图，其语法为DROP VIEW 视图名；。<br>（4）更新视图时可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新视图不存在，则会创建，如果存在，则会替换。        </p>
<h2 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h2><p>视图最常见的应用之一是隐藏复杂的SQL，这通常会涉及联结。<br>命令：<br>CREATE VIEW 视图名 AS SELECT。。。。。。；<br>AS后面跟着的是具体的SQL语句。   </p>
<pre><code>WHERE子句与WHERE子句   如果从视图中检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。


一般，应该讲视图用于检索而不用于更新
</code></pre><p>#视图与存储过程<br>存储过程<br>      存储过程可以使得对数据库的管理、以及显示关于数据库及其用户信息的工作容易得多。存储过程是   SQL   语句和可选控制流语句的预编译集合，以一个名称存储并作为一个单元处理。存储过程存储在数据库内，可由应用程序通过一个调用执行，而且允许用户声明变量、有条件执行以及其它强大的编程功能。  </p>
<pre><code>存储过程可包含程序流、逻辑以及对数据库的查询。它们可以接受参数、输出参数、返回单个或多个结果集以返回值。
可以出于任何使用   SQL   语句的目的来使用存储过程
</code></pre><p>视图<br>  视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h2><p>MySQL称存储过程的执行为调用，因此MYSQL执行存储过程的语句为CALL。CALL 接受存储过程的名字以及传递给它的任意参数。</p>
<pre><code>命令：CALL  productpricing（@pricelow，@pricehigh，@priceaverage），其中执行名为productpricing的存储过程，他计算并返回产品的最低，最高和平均价格。
</code></pre><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>命令： CREATE  PROCEDURE  存储过程名（）<br>BEGIN<br>    SELECT。。。。。（mysql语句）；<br>END；</p>
<p>利用CREATE PROCEDURE   存储过程名（）来创建，如果存储过程有参数，它们将在（）中列举出来，此过程若没有参数，但后跟的（）仍需要。BEGIN和END语句用来限定存储过程的存储体。</p>
<pre><code>存储过程实际上是一种函数，所以存储过程名后需要有（）符号
</code></pre><h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>存储过程被创建以后，被保存在服务其上以供使用，直至被删除。<br>命令： DROP  PROCEDURE  存储过程名；</p>
<p>当过程存在 想要删除时（不存在不产生错误）：DROP  PROCEDURE  IF   EXISTS。</p>
<h2 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h2><p> 变量：内存中一个特定的位置，用来临时存储数据</p>
<p> 命令： CREATE  PROCEDURE  productpricing（</p>
<pre><code>OUT  p1  DECIMAL（8,2），                     
OUT  ph  DECIMAL（8,2），                   
OUT  pa  DECIMAL（8,2）                  
</code></pre><p> ）<br> BEGIN  </p>
<pre><code>SELECT  MIN（prod_price）                           
INTO  p1                         
FROM  products;                     
SELECT  MAX（prod_price）                       
INTO  ph                     
FROM  products;              
SELECT  priceaverage（prod_price）                  
INTO  pa                       
FROM  products;                     
</code></pre><p>END;</p>
<p>每个参数必须具有指定的类型，这里使用十进制。关键字OUT用来指出响应的参数用来从存储过程中传出一个值。</p>
<p>MYSQL支持IN（传递给存储过程），OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数。<br>这里用SELECT语句，用来检索，然后保存到相应的变量（通过指定INTO关键字）</p>
<p>注意：不能一个参数返回多个行和列。这就是为甚么前面的例子要使用三个参数（3个SELECT语句）的原因。</p>
<p>调用过程：<br>命令： CALL productpricing（@pricelow，@pricehigh，@priceaverage）;<br>由于此存储过程要求三个参数，因此必须正好传递3个参数。</p>
<p>变量名必须都以@开头。</p>
<p>为了显示数据则用一下命令：SELECT  @变量名；</p>
<h2 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h2><p>–Name：ordertotal<br>–parameter：number=  order number<br>–           taxable= 0 if  not taxable ,1 if taxable<br>–           ototal  = order total  variable                   </p>
<p>CREATE  PROCEDURE  ordertotal(</p>
<pre><code>IN  onumber  INT,
IN taxable  BOOLEAN ,
OUT ototal DECIMAL（8,2）
</code></pre><p>  )COMMENT ‘Obtain order total’<br>  BEGIN</p>
<pre><code>--DECLARE variable for total
DECLARE total DECIMAL（8,2）
--DECLARE variable for total
DECLARE taxrate  INT  DEFAULT  6；//声明变量

SELECT 。。。。。FROM  表名 INTO total；

IF  taxable  THEN  
      SELECT。。。。。。。。。。。。；
END IF；
SELECT  total  INTO  otatal；
</code></pre><p>   END</p>
<p>   DECLEAR 声明数据</p>
<p>  COMMENT关键字：给出次关键字，将咋啊SHOW PROCEDURE  STATUS 的结果中显示</p>
<p>  SHOW PROCEDURE  STATUS：将列出所有存储过程<br>  SHOW PROCEDURE  STATUS  LIKE  存储过程名；列出指定的存储过程列表。</p>
<h2 id="检查创建过程"><a href="#检查创建过程" class="headerlink" title="检查创建过程"></a>检查创建过程</h2><pre><code>SHOW  CREATE PROCEDURE  存储过程名；显示存储过程的创建语句。
</code></pre><p>#使用游标<br>    游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据</p>
<pre><code>MYSQL游标只能用于存储过程
</code></pre><h2 id="使用游标的几个明确步骤"><a href="#使用游标的几个明确步骤" class="headerlink" title="使用游标的几个明确步骤"></a>使用游标的几个明确步骤</h2><pre><code>（1）    在能够使用游标前，必须声明它。在这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。
（2）    一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来
（3）    对于天佑数据的游标，根据需要取出各行
（4）    在结束游标使用时，必须关闭游标。
在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作
</code></pre><p>###创建游标<br>    游标用DECLARE语句创建。DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。</p>
<pre><code>例如：
CREATE PROCEDURE  processorders()
BEGIN
        DECLARE  ordernumbers  CURSOR
        FOR
        SELECT  order_num  FROM  orders;
END;

DECLARE 语句用来定义和命名游标，这里为ordernumbers。存储过程处理完成后，游标就消失了（因为它局限于存储过程）
</code></pre><h3 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h3><pre><code>OPEN  ordernumbers；在处理OPEN语句时执行查询

CLOSE  ordernumbers；CLOSE释放游标使用的所有内部内存和资源

在一个游标关闭后，如果没有重新打开，则不能使用它。但是使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了
</code></pre><h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><pre><code>在一个游标打开后，可以使用FETCH语句分别访问它的每一行。
FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。


CREATE PROCEDURE  processorders()
BEGIN
        DECLARE o INT；//声明数据
        //声明游标
        DECLARE  ordernumbers  CURSOR
        FOR
        SELECT  order_num  FROM  orders;
        //打开游标
        OPEN ordernumbers；
        //检索数据
        FETCH  ordersnumbers  INTO  o;
        //关闭游标
        CLOSE  ordernumbers；
END;

FETCH用来检索当前行的游标order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理

循环：
         REPEAT
                要执行的SQL语句
         UNITL  变量名  END  REPEAT；//反复执行直到  变量为真时  停止
</code></pre><p>#使用触发器<br>    某条MySQL语句在事件发生时自动执行。这就是触发器。</p>
<pre><code>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：
（1）    DELETE
（2）    INSERT
（3）    UPDATE
</code></pre><h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><pre><code>创建触发器时需要给出的4条信息：
（1）唯一的触发器名
（2）触发器关联表
（3）触发器应该响应的活动（DELETE，INSERT或UPDATE）
（4）触发器何时执行
</code></pre><p>  注意：<br>    保持每个数据库的触发器名唯一<br>  触发器用CREATE  TRIGGER语句创建：<br>  命令：<br>  CREATE  TRIGGER   触发器名1  AFTER  INSERT  ON  表名1 FOR   EACH  ROW  SELECT ‘Product added’；<br>  CREATE TRIGGER用来创建名为  触发器1的新触发器，触发器可在一个操作发生之前或之后执行，这里给出了AFTER  INSERT，所以触发器将在INSERT语句执行后执行。而FOR EACH  ROW则表示在每个插入行执行‘Product added’</p>
<p>  只有表才支持触发器。单一个触发器不能与多个事件相关联。</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><pre><code>DROP TRIGGER  触发器名；
</code></pre><p>##使用触发器</p>
<p>###INSERT触发器<br>      (1)在INSERT触发器代码内，可引用一个名NEW的虚拟表，访问被插入的行<br>      (2)在BEFORE  INSERT触发器中，NEW中的值可以被更新<br>      (3)对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，，在INSERT执行之后包含新的自动生成的值。</p>
<pre><code>CREATE TRIGGER  neworder  AFTER INSERT ON orders FOR EACH ROW  SELECT  NEW.order_num;
在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num.触发器从NEW.order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成

测试触发器：
INSERT INTO orders（order_date,cust_id） VALUES(NEW(),10001);
order_num由MySQL自动生成，而且被返回
</code></pre><h3 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h3><pre><code>  （1）在DELETE触发器内，可以引用一个名为OLD的虚拟表，访问被删除的行
  （2）OLD中的值全都是只读的，不可更新

  例如：CREATE  TRIGGER  触发器名1 BEFORE DELETE ON orders
        FOR  EACH  ROW
        BEGIN
             INSERT  INTO archive_orders（order_num,order_date,cust_id）
             VALUES(OLD.order_num,OLD_order_date,OLD.cust_id);
        END;
使用BEGIN   END块：触发器能容纳多条SQL语句
</code></pre><p>###UPDATE  触发器<br>      （1）在UPDATE触发器代码中，可以引用一个名为OLD的虚拟表访问以前（UPDATE更新以前）的值，引用一个名为NEW的虚拟表访问更新的值<br>      （2）在BEFORE UPDATE触发器中，NEW中的值可能也被更新。<br>      （3）OLD中的值全都是只读，不能更新</p>
<p>#管理事务处理<br>事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么不执行</p>
<h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><pre><code>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退。何时不应该回退。

MYSQL使用下面的语句来标识事务的开始：
START  TRANSACTION

MySQL的ROLLBACK命令用来回退SQL语句：
SELECT  * FROM 表名；
START TRANSACTION；
DELETE  FROM 表名；
SELECT * FROM  表名；
ROLLBACK；
ROLLBACK语句回退START  TRANSACTION之后的所有语句。
</code></pre><p>###使用COMMIT<br>      一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交，即提交操作是自动进行的。<br>      但是，在事务处理块中，提交不会隐含地进行。为了进行明确的提交，使用COMMIT语句<br>      START   TRANSACTION；<br>      DELETE  FROM  表名  WHERE  字=值；<br>      DELETE  FROM  表名1 WHERE  字段1=值；<br>      COMMIT；<br>      最后的COMMIT仅在不出错时写出更改。如果取消，会被自动取消。<br>隐含事务关闭：当COMMIT或ROLLBACK语句执行后，事务会自动关闭</p>
<p>###使用保留点<br>      简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p>
<pre><code>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符  这些占位符称为保留点。

创建占位符：
SAVEPOINT  标识符1；
为了回退到本例给出的保留点：
ROLLBACK  TO  标识符；

保留点在事务完成后（执行一条ROLLBACK或COMMIT）后自动释放。也可以用RELASE  SAVEPOINT明确地释放保留点。
</code></pre><p>为了指示MySQL不自动提交更改，需要使用一下语句：<br>     SET  autocommit=0；<br>autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。</p>
<p>#安全管理</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><pre><code>MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/15/mysql必知必会笔记/" data-id="cjuajt99f000pfcamhb7e4sq3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/22/‘HashMap底层源码解析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ‘HashMap底层源码解析
        
      </div>
    </a>
  
  
    <a href="/2019/01/14/‘Netty指南/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">‘Netty指南</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>

  
    
  <h5>RECENT POSTS
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2019/04/08/动态代理/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/04/08/springAOP/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/25/dubbo/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/22/操作系统_存储器管理和虚拟存储器/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/21/操作系统_处理机的调度与死锁/">(no title)</a>
        </li>
      
    </ul>
  </div>
</h5>
  
    <!-- Friends Blog -->

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>