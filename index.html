<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-动态代理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/动态代理/" class="article-date">
  <time datetime="2019-04-08T12:06:18.313Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p><strong>步骤：</strong></p>
<p>①创建被代理的接口和类；</p>
<p>②创建InvocationHandler接口的实现类，在invoke方法中实现代理逻辑；</p>
<p>③通过Proxy的静态方法newProxyInstance( ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理对象</p>
<p>④使用代理对象。</p>
<p><strong>1.创建被代理的接口和类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhb.jdk.proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author ZHB</span><br><span class="line">* @date 2018年8月31日下午10:44:49</span><br><span class="line">* @todo TODO</span><br><span class="line">*/ </span><br><span class="line">public interface IUserService &#123;</span><br><span class="line"> </span><br><span class="line"> void add(String name);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zhb.jdk.proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author ZHB</span><br><span class="line">* @date 2018年8月31日下午10:47:25</span><br><span class="line">* @todo TODO </span><br><span class="line">*/ </span><br><span class="line">public class UserServiceImpl implements IUserService &#123; </span><br><span class="line"> </span><br><span class="line"> @Override </span><br><span class="line"> public void add(String name) &#123; </span><br><span class="line">   System.out.println(&quot;向数据库中插入名为： &quot;+name+&quot; 的用户&quot;); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建InvocationHandler接口的实现类（拦截器）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.zhb.jdk.dynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author ZHB</span><br><span class="line">* @date 2018年8月31日下午11:25:53</span><br><span class="line">* @todo TODO</span><br><span class="line">*/</span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"> </span><br><span class="line"> //被代理对象，Object类型 </span><br><span class="line"> private Object target;</span><br><span class="line"> </span><br><span class="line"> public MyInvocationHandler(Object target) &#123; </span><br><span class="line">   this.target = target; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> @Override </span><br><span class="line"> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">   </span><br><span class="line">   System.out.println(&quot;准备向数据库中插入数据&quot;); </span><br><span class="line">   Object returnvalue = method.invoke(target, args);</span><br><span class="line">   System.out.println(&quot;插入数据库成功&quot;); </span><br><span class="line">   return returnvalue; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> 通过Proxy的静态方法创建代理对象并使用代理对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.zhb.jdk.dynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author ZHB</span><br><span class="line">* @date 2018年8月31日下午11:35:07</span><br><span class="line">* @todo TODO </span><br><span class="line">*/ </span><br><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line"> </span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">   IUserService target = new UserServiceImpl();</span><br><span class="line">   MyInvocationHandler handler = new MyInvocationHandler(target);</span><br><span class="line">   //第一个参数是指定代理类的类加载器（我们传入当前测试类的类加载器） </span><br><span class="line">   //第二个参数是代理类需要实现的接口（我们传入被代理类实现的接口，这样生成的代理类和被代理类就实现了相同的接口） </span><br><span class="line">   //第三个参数是invocation handler，用来处理方法的调用。这里传入我们自己实现的handler </span><br><span class="line">   IUserService proxyObject = (IUserService) Proxy.newProxyInstance(DynamicProxyTest.class.getClassLoader(), </span><br><span class="line">       target.getClass().getInterfaces(), handler); </span><br><span class="line">   proxyObject.add(&quot;陈粒&quot;); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>动态代理的代理对象是在内存中的，是JDK根据我们传入的参数生成好的</strong></p>
<h2 id="动态代理源码深入分析"><a href="#动态代理源码深入分析" class="headerlink" title="动态代理源码深入分析"></a>动态代理源码深入分析</h2><p>Proxy.newProxyInstance( ClassLoaderloader, Class[] interfaces, InvocationHandler h)产生了代理对象，所以我们进到newProxyInstance的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                         Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                         InvocationHandler h)</span><br><span class="line">       throws IllegalArgumentException</span><br><span class="line">   &#123;</span><br><span class="line">       //检验h不为空，h为空抛异常</span><br><span class="line">       Objects.requireNonNull(h);</span><br><span class="line">       //接口的类对象拷贝一份</span><br><span class="line">       final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">       //进行一些安全性检查</span><br><span class="line">       final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       if (sm != null) &#123;</span><br><span class="line">           checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Look up or generate the designated proxy class.</span><br><span class="line">        *  查询（在缓存中已经有）或生成指定的代理类的class对象。</span><br><span class="line">        */</span><br><span class="line">       Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Invoke its constructor with the designated invocation handler.</span><br><span class="line">        */</span><br><span class="line">       try &#123;</span><br><span class="line">           if (sm != null) &#123;</span><br><span class="line">               checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">           &#125;</span><br><span class="line">           //得到代理类对象的构造函数，这个构造函数的参数由constructorParams指定</span><br><span class="line">           //参数constructorParames为常量值：private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;</span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">           final InvocationHandler ih = h;</span><br><span class="line">           if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   public Void run() &#123;</span><br><span class="line">                       cons.setAccessible(true);</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">           //这里生成代理对象，传入的参数new Object[]&#123;h&#125;后面讲</span><br><span class="line">           return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">       &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           throw new InternalError(e.toString(), e);</span><br><span class="line">       &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">           Throwable t = e.getCause();</span><br><span class="line">           if (t instanceof RuntimeException) &#123;</span><br><span class="line">               throw (RuntimeException) t;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               throw new InternalError(t.toString(), t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">           throw new InternalError(e.toString(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这段代码核心就是通过getProxyClass0(loader, intfs)得到代理类的Class对象，然后通过Class对象得到构造方法，进而创建代理对象。下一步看getProxyClass0这个方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//此方法也是Proxy类下的方法</span><br><span class="line">   private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">       if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the proxy class defined by the given loader implementing</span><br><span class="line">       // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">       // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">       //意思是：如果代理类被指定的类加载器loader定义了，并实现了给定的接口interfaces，</span><br><span class="line">       //那么就返回缓存的代理类对象，否则使用ProxyClassFactory创建代理类。</span><br><span class="line">       return proxyClassCache.get(loader, interfaces);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这里看到proxyClassCache，有Cache便知道是缓存的意思，正好呼应了前面Look up or generate the designated proxy class。查询（在缓存中已经有）或生成指定的代理类的class对象这段注释。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * a cache of proxy classes</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">       proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br></pre></td></tr></table></figure></p>
<p><strong>proxyClassCache是个WeakCache类的对象，调用proxyClassCache.get(loader, interfaces); 可以得到缓存的代理类或创建代理类（没有缓存的情况）。说明WeakCache中有get这个方法。先看下WeakCache类的定义（这里先只给出变量的定义和构造函数）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/K代表key的类型，P代表参数的类型，V代表value的类型。</span><br><span class="line">// WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;  proxyClassCache  说明proxyClassCache存的值是Class&lt;?&gt;对象，正是我们需要的代理类对象。</span><br><span class="line">final class WeakCache&lt;K, P, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">   private final ReferenceQueue&lt;K&gt; refQueue</span><br><span class="line">       = new ReferenceQueue&lt;&gt;();</span><br><span class="line">   // the key type is Object for supporting null key</span><br><span class="line">   private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">       = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap</span><br><span class="line">       = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   private final BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line">   private final BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span><br><span class="line">                    BiFunction&lt;K, P, V&gt; valueFactory) &#123;</span><br><span class="line">       this.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">       this.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中map变量是实现缓存的核心变量，他是一个双重的Map结构: (key, sub-key) -&gt; value。其中key是传进来的Classloader进行包装后的对象，sub-key是由WeakCache构造函数传人的KeyFactory()生成的。value就是产生代理类的对象，是由WeakCache构造函数传人的ProxyClassFactory()生成的。</strong><br>产生sub-key的KeyFactory代码如下，这个我们不去深究，只要知道他是根据传入的ClassLoader和接口类生成sub-key即可。</p>
<p>好，大体上说完WeakCache这个类的作用，我们回到刚才proxyClassCache.get(loader, interfaces);这句代码。get是WeakCache里的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//K和P就是WeakCache定义中的泛型，key是类加载器，parameter是接口类数组</span><br><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">       //检查parameter不为空</span><br><span class="line">       Objects.requireNonNull(parameter);</span><br><span class="line">        //清除无效的缓存</span><br><span class="line">       expungeStaleEntries();</span><br><span class="line">       // cacheKey就是(key, sub-key) -&gt; value里的一级key，</span><br><span class="line">       Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">       // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">       //根据一级key得到 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;对象。如果之前不存在，则新建一个ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;和cacheKey（一级key）一起放到map中。</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">       if (valuesMap == null) &#123;</span><br><span class="line">           ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">               = map.putIfAbsent(cacheKey,</span><br><span class="line">                                 valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">           if (oldValuesMap != null) &#123;</span><br><span class="line">               valuesMap = oldValuesMap;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">       // subKey from valuesMap</span><br><span class="line">       //这部分就是调用生成sub-key的代码，上面我们已经看过怎么生成的了</span><br><span class="line">       Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">       //通过sub-key得到supplier</span><br><span class="line">       Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">       //supplier实际上就是这个factory</span><br><span class="line">       Factory factory = null;</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           //如果缓存里有supplier ，那就直接通过get方法，得到代理类对象，返回，就结束了，一会儿分析get方法。</span><br><span class="line">            if (supplier != null) &#123;</span><br><span class="line">               // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">               V value = supplier.get();</span><br><span class="line">               if (value != null) &#123;</span><br><span class="line">                   return value;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // else no supplier in cache</span><br><span class="line">           // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">           // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line">           // lazily construct a Factory</span><br><span class="line">           //下面的所有代码目的就是：如果缓存中没有supplier，则创建一个Factory对象，把factory对象在多线程的环境下安全的赋给supplier。</span><br><span class="line">            //因为是在while（true）中，赋值成功后又回到上面去调get方法，返回才结束。</span><br><span class="line">           if (factory == null) &#123;</span><br><span class="line">               factory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (supplier == null) &#123;</span><br><span class="line">               supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">               if (supplier == null) &#123;</span><br><span class="line">                   // successfully installed Factory</span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125;</span><br><span class="line">               // else retry with winning supplier</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                   // successfully replaced</span><br><span class="line">                   // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                   // with our Factory</span><br><span class="line">                   supplier = factory;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // retry with current supplier</span><br><span class="line">                   supplier = valuesMap.get(subKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>所以接下来我们看Factory类中的get方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get() &#123; // serialize access</span><br><span class="line">    // re-check</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    /重新检查得到的supplier是不是当前对象</span><br><span class="line">           if (supplier != this) &#123;</span><br><span class="line">               // something changed while we were waiting:</span><br><span class="line">               // might be that we were replaced by a CacheValue</span><br><span class="line">               // or were removed because of failure -&gt;</span><br><span class="line">               // return null to signal WeakCache.get() to retry</span><br><span class="line">               // the loop</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           // else still us (supplier == this)</span><br><span class="line"></span><br><span class="line">           // create new value</span><br><span class="line">           V value = null;</span><br><span class="line">           try &#123;</span><br><span class="line">                //代理类就是在这个位置调用valueFactory生成的</span><br><span class="line">                //valueFactory就是我们传入的 new ProxyClassFactory()</span><br><span class="line">               //一会我们分析ProxyClassFactory()的apply方法</span><br><span class="line">               value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (value == null) &#123; // remove us on failure</span><br><span class="line">                   valuesMap.remove(subKey, this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // the only path to reach here is with non-null value</span><br><span class="line">           assert value != null;</span><br><span class="line"></span><br><span class="line">           // wrap value with CacheValue (WeakReference)</span><br><span class="line">           //把value包装成弱引用</span><br><span class="line">           CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">           // put into reverseMap</span><br><span class="line">           // reverseMap是用来实现缓存的有效性</span><br><span class="line">           reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">           // try replacing us with CacheValue (this should always succeed)</span><br><span class="line">           if (!valuesMap.replace(subKey, this, cacheValue)) &#123;</span><br><span class="line">               throw new AssertionError(&quot;Should not reach here&quot;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // successfully replaced us with new CacheValue -&gt; return the value</span><br><span class="line">           // wrapped by it</span><br><span class="line">           return value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>来到ProxyClassFactory的apply方法，代理类就是在这里生成的：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">//这里的BiFunction&lt;T, U, R&gt;是个函数式接口，可以理解为用T，U两种类型做参数，得到R类型的返回值</span><br><span class="line">private static final class ProxyClassFactory</span><br><span class="line">       implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       // prefix for all proxy class names</span><br><span class="line">       //所有代理类名字的前缀</span><br><span class="line">       private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line">       </span><br><span class="line">       // next number to use for generation of unique proxy class names</span><br><span class="line">       //用于生成代理类名字的计数器</span><br><span class="line">       private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">             </span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">            //验证代理接口，可不看</span><br><span class="line">           for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that the class loader resolves the name of this</span><br><span class="line">                * interface to the same Class object.</span><br><span class="line">                */</span><br><span class="line">               Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">               try &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               if (interfaceClass != intf) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that the Class object actually represents an</span><br><span class="line">                * interface.</span><br><span class="line">                */</span><br><span class="line">               if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that this interface is not a duplicate.</span><br><span class="line">                */</span><br><span class="line">               if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //生成的代理类的包名 </span><br><span class="line">           String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">           //代理类访问控制符: public ,final</span><br><span class="line">           int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Record the package of a non-public proxy interface so that the</span><br><span class="line">            * proxy class will be defined in the same package.  Verify that</span><br><span class="line">            * all non-public proxy interfaces are in the same package.</span><br><span class="line">            */</span><br><span class="line">           //验证所有非公共的接口在同一个包内；公共的就无需处理</span><br><span class="line">           //生成包名和类名的逻辑，包名默认是com.sun.proxy，类名默认是$Proxy 加上一个自增的整数值</span><br><span class="line">            //如果被代理类是 non-public proxy interface ，则用和被代理类接口一样的包名</span><br><span class="line">           for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               int flags = intf.getModifiers();</span><br><span class="line">               if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">                   String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">                   if (proxyPkg == null) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       throw new IllegalArgumentException(</span><br><span class="line">                           &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (proxyPkg == null) &#123;</span><br><span class="line">               // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Choose a name for the proxy class to generate.</span><br><span class="line">            */</span><br><span class="line">           long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           //代理类的完全限定名，如com.sun.proxy.$Proxy0.calss</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Generate the specified proxy class.</span><br><span class="line">            */</span><br><span class="line">           //核心部分，生成代理类的字节码</span><br><span class="line">           byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           try &#123;</span><br><span class="line">               //把代理类加载到JVM中，至此动态代理过程基本结束了</span><br><span class="line">               return defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">           &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">                * proxy class generation code) there was some other</span><br><span class="line">                * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">                * class creation (such as virtual machine limitations</span><br><span class="line">                * exceeded).</span><br><span class="line">                */</span><br><span class="line">               throw new IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p>JDK动态代理机制只能代理实现接口的类，一般没有实现接口的类不能进行代理。cglib就是针对类来实现代理的，它的原理是指针对目标类生成一个子类，并覆盖其中的方法实现增强，但是因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<p>使用cglib实现动态代理，完全不受代理类必须实现接口的限制，而且cglib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用java反射效率要高。</p>
<p>需要引入两个jar包：cglib.jar，asm.jar</p>
<p>定义了一个拦截器，在调用目标方法之前，cglib回调MethodInterceptor接口方法拦截，来实现自己的业务逻辑，类似</p>
<p>于JDK中的InvocationHandler接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable ；</span><br></pre></td></tr></table></figure>
<p>proxy：为cglib动态生成的代理实例<br>method：为上文中实体类所调用的被代理的方法调用</p>
<p>args：为method参数数值列表</p>
<p>methodProxy:为生成代理类对方法的代理引用</p>
<p>返回：从代理实例方法调用返回的值</p>
<p><strong>实现一个业务类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.lanhuigu.spring.proxy.cglib;</span><br><span class="line"></span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    public HelloService() &#123;</span><br><span class="line">        System.out.println(&quot;HelloService构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的</span><br><span class="line">     */</span><br><span class="line">    final public String sayOthers(String name) &#123;</span><br><span class="line">        System.out.println(&quot;HelloService:sayOthers&gt;&gt;&quot;+name);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;HelloService:sayHello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自定义MethodInterceptor：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.lanhuigu.spring.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义MethodInterceptor</span><br><span class="line"> */</span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * sub：cglib生成的代理对象</span><br><span class="line">     * method：被代理对象方法</span><br><span class="line">     * objects：方法入参</span><br><span class="line">     * methodProxy: 代理方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;======插入前置通知======&quot;);</span><br><span class="line">        Object object = methodProxy.invokeSuper(sub, objects);</span><br><span class="line">        System.out.println(&quot;======插入后者通知======&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>生成CGLIB代理对象调用目标方法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.lanhuigu.spring.proxy.cglib;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 代理类class文件存入本地磁盘方便我们反编译查看源码</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\code&quot;);</span><br><span class="line">        // 通过CGLIB动态代理获取代理对象的过程</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        // 设置enhancer对象的父类</span><br><span class="line">        enhancer.setSuperclass(HelloService.class);</span><br><span class="line">        // 设置enhancer的回调对象</span><br><span class="line">        enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line">        // 创建代理对象</span><br><span class="line">        HelloService proxy= (HelloService)enhancer.create();</span><br><span class="line">        // 通过代理对象调用目标方法</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/动态代理/" data-id="cjuajt8s0000kfcamouyr7a1p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springAOP" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/springAOP/" class="article-date">
  <time datetime="2019-04-08T02:46:35.436Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-什么是AOP"><a href="#一-什么是AOP" class="headerlink" title="一.什么是AOP"></a>一.什么是AOP</h2><p>AOP(面向切面编程)，可以说是OOP的补充和完善。OOP引入封装，继承和多态等概念来监利一中对象层次结构，用以公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显的无能为力。OOP允许你从上到下的关系，但是并不适合定义从左到右。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，模块间的藕合度高，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心业务逻辑组件和横切关注点。横切关注点模块化为特殊的类，这些类被称为“切面”，好处：1.横切关注点都集中于一块，不会出现大量重复代码；2.核心模块只关注核心功能的代码，模块间藕合度降低。</p>
<h2 id="二-AOP实现原理"><a href="#二-AOP实现原理" class="headerlink" title="二.AOP实现原理"></a>二.AOP实现原理</h2><p><img src="pictures/AOP代理方法.png" alt="AOP代理方法"></p>
<p>AOP 实际上是由目标类的代理类实现的。AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异，AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。</p>
<h3 id="三-AOP-相关概念"><a href="#三-AOP-相关概念" class="headerlink" title="三.AOP 相关概念"></a>三.AOP 相关概念</h3><p>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。通俗的说就是加入切点的那个点</p>
<p>通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p>
<p>切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p>
<p>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</p>
<p>织入（Weaving）：将切面应用到目标对象来创建新的代理对象的过程。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<p>增强（Advice）：是织入到目标类连接点上的一段程序代码。Spring使用增强类定义横切逻辑，同时由于Spring只支持方法连接点，增强还包括了在方法上的哪一点加入横切代码的方位信息，所以增强既包括横切逻辑、还包含部分连接点的信息。</p>
<p>引介（Introduction）：是一种特殊的增强，为类添加一些属性和方法。</p>
<p>切面（Advisor）：代表一般切面，包含了横切代码和连接点信息，本身是一个简单的切面，横切的连接点是目标类的所有方法。3种类型：一般切面（advisor）、切点切面（PointcutAdvisor）、引介切面（IntroductionAdvisor）。</p>
<p><strong>Spring 采用jdk动态代理模式来实现Aop机制。<br>Spring AOP采用动态代理过程：<br>1.将切面使用动态代理的方式动态织入到目标对象，形成一个代理对象。<br>2.目标对象如果没有实现代理接口，那么spring会采用CGLib来生成代理对象，该代理对象是目标对象的子类。<br>3.目标对象如果是final类，也没有实现接口，就不能运用AOP</strong></p>
<p><strong>AOP的实现包含下面几个方面：</strong></p>
<ol>
<li>根据配置或注解解析切面</li>
<li>生成AOP代理对象，给目标对象生成一个代理类以及代理类实例，根据解析出的切面，生成通知链设置到代理对象，在代理的回调中会执行通知链。</li>
<li>把AOP代理对象注册到容器中代替目标对象，当使用者向容器请求目标bean时，容器会返回代理对象。</li>
</ol>
<p><strong>切面解析</strong><br><img src="pictures/AOP切面接口.png" alt="AOP切面接口"></p>
<ol>
<li>PointCut：描述切点，在进行切点匹配时，使用ClassFilter进行类匹配，MethodMatcher进行执行方法匹配。</li>
<li>Advice：通知，AfterAdvice后通知，BeforeAdvice前通知，DynamicIntroductionAdvice引用通知，环绕通知通过Interceptor实现。</li>
<li>Advisor：通知器，也就是切面，PointcutAdvisor切点通知器，IntroductionAdvisor引用通知器。</li>
</ol>
<p><strong>aop标签解析</strong></p>
<p>aop名称空间的解析器是AopNamespaceHandler：<br>再AopNamespaceHandler中可以看到aop下各个标签对应的解析器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AopNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; for the</span><br><span class="line">	 * &apos;&#123;@code config&#125;&apos;, &apos;&#123;@code spring-configured&#125;&apos;, &apos;&#123;@code aspectj-autoproxy&#125;&apos;</span><br><span class="line">	 * and &apos;&#123;@code scoped-proxy&#125;&apos; tags.</span><br><span class="line">	 */</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		// In 2.0 XSD as well as in 2.1 XSD.</span><br><span class="line">		registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">		// Only in 2.0 XSD: moved to context namespace as of 2.1</span><br><span class="line">		registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在init方法中注册了各个标签的解析器，可以看到aop:config标签的解析器是ConfigBeanDefinitionParser。<br>在ConfigBeanDefinitionParser的parse方法中对aop:config下面的三个直接子标签pointcut、advisor、aspect分别进行解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line">for (Element elt: childElts) &#123;</span><br><span class="line">	String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line">	if (POINTCUT.equals(localName)) &#123;</span><br><span class="line">		parsePointcut(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (ADVISOR.equals(localName)) &#123;</span><br><span class="line">		parseAdvisor(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (ASPECT.equals(localName)) &#123;</span><br><span class="line">		parseAspect(elt, parserContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>pointcut标签解析</strong><br>解析器会为pointcut标签创建一个切点bean定义，并且把bean定义注册到容器中，代码在ConfigBeanDefinitionParser类的parsePointcut和createPointcutDefinition方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private AbstractBeanDefinition parsePointcut(Element pointcutElement, ParserContext parserContext) &#123;</span><br><span class="line">	String id = pointcutElement.getAttribute(ID);</span><br><span class="line">	String expression = pointcutElement.getAttribute(EXPRESSION);</span><br><span class="line"></span><br><span class="line">	AbstractBeanDefinition pointcutDefinition = null;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		this.parseState.push(new PointcutEntry(id));</span><br><span class="line">		pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">		pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));</span><br><span class="line"></span><br><span class="line">		String pointcutBeanName = id;</span><br><span class="line">		if (StringUtils.hasText(pointcutBeanName)) &#123;</span><br><span class="line">			parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parserContext.registerComponent(</span><br><span class="line">				new PointcutComponentDefinition(pointcutBeanName, pointcutDefinition, expression));</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return pointcutDefinition;</span><br><span class="line">&#125;</span><br><span class="line">protected AbstractBeanDefinition createPointcutDefinition(String expression) &#123;</span><br><span class="line">	RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class);</span><br><span class="line">	beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">	beanDefinition.setSynthetic(true);</span><br><span class="line">	beanDefinition.getPropertyValues().add(EXPRESSION, expression);</span><br><span class="line">	return beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该切点bean定义的类型是AspectJExpressionPointcut，这个类同时实现了ClassFilter和MethodMatcher接口执行类匹配和方法匹配逻辑。它有一个expression属性设置表达式，AspectJ最终会把该表达式解析成一个PointcutExpression对象执行相关的语义</p>
<p><strong>aspect标签解析</strong><br>aspect标签的解析要相对复杂一些，扫描它下面的所有通知子标签（aop:before、aop:after等标签）。</p>
<p>1、把这些标签都解析成通知类，通知标签的方法属性（method属性）会被解析成一个MethodLocatingFactoryBean类型的bean，把aspect引用的bean名称（aop:aspect标签的ref属性）和method方法通过属性注入到MethodLocatingFactoryBean类型bean中。</p>
<p>2、生成一个SimpleBeanFactoryAwareAspectInstanceFactory类型的bean，这个bean的作用是用来加载aspect引用的bean，把aspect引用的bean名称通过属性注入到该这个bean中。</p>
<p>3、生成一个通知（Advice）bean。</p>
<p>3.1、把aspect bean id和order（指定通知在通知链中的顺序）通过属性注入到该bean。</p>
<p>3.2、把各个通知标签特有属性注入（比如returning，throwing等属性）。</p>
<p>3.3、把上面生成方法MethodLocatingFactoryBean类型bean通过构造器注入。</p>
<p>3.4、构造子注入引用的切点bean，pointcut或pointcut-ref指定，如果是pointcut-ref属性，直接引用这个bean，如果是pointcut属性，生成一个匿名的切点bean。</p>
<p>3.5、构造子注入上面的SimpleBeanFactoryAwareAspectInstanceFactory类型bean。</p>
<p>通知bean的类型根据标签的不同而不同，aop;before对应AspectJMethodBeforeAdvice，aop:after对应AspectJAfterAdvice，aop:aroude对应AspectJAroundAdvice，在通知方法中通过反射调用method属性中设置的方法。通过ConfigBeanDefinitionParser类的getAdviceClass方法可以看出标签和类的对应关系。</p>
<p><strong>如何使用Spring AOP</strong><br>可以通过文件或则编程的方式来使用Spring AOP</p>
<p>配置可以通过xml文件来进行，大概有四种方式：</p>
<ol>
<li><p>配置ProxyFactoryBean，显式地设置advisors, advice, target等</p>
</li>
<li><p>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</p>
</li>
<li><p>通过<a href="aop:config" target="_blank" rel="noopener">aop:config</a>来配置</p>
</li>
<li><p>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</p>
</li>
</ol>
<p><strong>在Spring中使用AOP编程步骤：</strong></p>
<p>1、在Spring配置文件（applicationContext.xml）中配置Spring对AspectJ的支持；以下两种方式任意一种即可</p>
<p>（1）<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a></p>
<p>（2）&lt; bean class=”org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator” /&gt;</p>
<p>2、引入Jar文件（在Spring的根目录下的lib/aspectj下）<br>     aspectjrt.jar  和  aspectjweaver.jar</p>
<p>3、定义连接点(若不使用接口编程，即SimplePersonManager不实现任何接口，此时要实现AOP代理，需要引入CGLIB 包cglib-nodep-2.1_3.jar，但是一旦实现了接口Spring就会使用JDK的动态代理实现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface PersonManager &#123;  </span><br><span class="line"></span><br><span class="line">    public void addPerson(Person person);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SimplePersonManager implements PersonManager&#123;  </span><br><span class="line"></span><br><span class="line">    public void addPerson(Person person) &#123;  </span><br><span class="line">        Person.persons.add(person);  </span><br><span class="line">                System.out.println(&quot;添加了一个用户&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义一个切面类，该切面类中定义了一个切入点，连接点为SimplePersonManager类中的addPerson方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.lang.annotation.Aspect;  </span><br><span class="line">import org.aspectj.lang.annotation.Before;  </span><br><span class="line"></span><br><span class="line">@Aspect  </span><br><span class="line">public class SimpleAspect &#123;  </span><br><span class="line"></span><br><span class="line">    @Before (&quot;execution (* rote.spring.aop.service.impl.SimplePersonManager.addPerson(..))&quot;)  </span><br><span class="line">    public void addPersonAop()&#123;  </span><br><span class="line">        System.out.println(&quot;-------------------addPerson-----------------------&quot;);  </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、在Spring配置文件中声明切面类<br>    <!-- 切面声明 --><br>    <bean id="simpleAspectj" class="rote.spring.aop.aspectj.SimpleAspect"><br>    </bean></p>
<p>6、在Spring配置文件中配置连接点类<br>     <bean id="personManager" class="rote.spring.aop.service.impl.SimplePersonManager"><br>    </bean></p>
<p><strong>Spring AOP的XML实现方式，先实现一个接口：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    void printHelloWorld();</span><br><span class="line">    void doPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义两个接口实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldImpl1 implements HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    public void printHelloWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl1.printHelloWorld()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doPrint()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl1.doPrint()&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorldImpl2 implements HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">    public void printHelloWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl2.printHelloWorld()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doPrint()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Enter HelloWorldImpl2.doPrint()&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>横切关注点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TimeHandler</span><br><span class="line">&#123;</span><br><span class="line">    public void printTime()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;CurrentTime = &quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AOP.xml配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt;</span><br><span class="line">        &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt;</span><br><span class="line">        &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:config&gt;</span><br><span class="line">            &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt;</span><br><span class="line">                &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;</span><br><span class="line">                &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;</span><br><span class="line">            &lt;/aop:aspect&gt;</span><br><span class="line">        &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>aspect里面有一个order属性，order属性的数字就是横切关注点的顺序，spring默认以aspect的定义顺序作为织如顺序</p>
<p><strong>Spring AOP代理对象的生成</strong></p>
<p>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * &lt;ol&gt;</span><br><span class="line">    * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)</span><br><span class="line">    * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口</span><br><span class="line">    * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象</span><br><span class="line">    * &lt;/ol&gt;</span><br><span class="line">    */</span><br><span class="line">   public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; +this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line">       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>下面的问题是，代理对象生成了，那切面是如何织入的？</strong></p>
<p>我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123;</span><br><span class="line">       MethodInvocation invocation = null;</span><br><span class="line">       Object oldProxy = null;</span><br><span class="line">       boolean setProxyContext = false;</span><br><span class="line"></span><br><span class="line">       TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">       Class targetClass = null;</span><br><span class="line">       Object target = null;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           //eqauls()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123;</span><br><span class="line">                return (equals(args[0])? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //hashCode()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123;</span><br><span class="line">                return newInteger(hashCode());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">           if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface()</span><br><span class="line">                    &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                // Service invocations onProxyConfig with the proxy config...</span><br><span class="line">                return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Object retVal = null;</span><br><span class="line"></span><br><span class="line">           if (this.advised.exposeProxy) &#123;</span><br><span class="line">                // Make invocation available ifnecessary.</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = true;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //获得目标对象的类</span><br><span class="line">           target = targetSource.getTarget();</span><br><span class="line">           if (target != null) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //获取可以应用到此方法上的Interceptor列表</span><br><span class="line">           List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);</span><br><span class="line"></span><br><span class="line">           //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">           if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Massage return value if necessary.</span><br><span class="line">           if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy)</span><br><span class="line">                    &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                // Special case: it returned&quot;this&quot; and the return type of the method</span><br><span class="line">                // is type-compatible. Notethat we can&apos;t help if the target sets</span><br><span class="line">                // a reference to itself inanother returned object.</span><br><span class="line">                retVal = proxy;</span><br><span class="line">           &#125;</span><br><span class="line">           return retVal;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                // Must have come fromTargetSource.</span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line">           if (setProxyContext) &#123;</span><br><span class="line">                // Restore old proxy.</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下：</strong></p>
<p>首先，从上面的代码可以看到，通知链是通过Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看下这个方法的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt;getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;</span><br><span class="line">                   MethodCacheKeycacheKey = new MethodCacheKey(method);</span><br><span class="line">                   List&lt;Object&gt;cached = this.methodCache.get(cacheKey);</span><br><span class="line">                   if(cached == null) &#123;</span><br><span class="line">                            cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                                               this,method, targetClass);</span><br><span class="line">                            this.methodCache.put(cacheKey,cached);</span><br><span class="line">                   &#125;</span><br><span class="line">                   returncached;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。</p>
<p>下面来分析下这个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,</span><br><span class="line">    * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断</span><br><span class="line">    * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.</span><br><span class="line">    */</span><br><span class="line">    publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123;</span><br><span class="line">       // This is somewhat tricky... we have to process introductions first,</span><br><span class="line">       // but we need to preserve order in the ultimate list.</span><br><span class="line">       List interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line"></span><br><span class="line">       //查看是否包含IntroductionAdvisor</span><br><span class="line">       boolean hasIntroductions = hasMatchingIntroductions(config,targetClass);</span><br><span class="line"></span><br><span class="line">       //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor</span><br><span class="line">       AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">       Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        for (int i = 0; i &lt;advisors.length; i++) &#123;</span><br><span class="line">           Advisor advisor = advisors[i];</span><br><span class="line">           if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">                // Add it conditionally.</span><br><span class="line">                PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    //TODO: 这个地方这两个方法的位置可以互换下</span><br><span class="line">                    //将Advisor转化成Interceptor</span><br><span class="line">                    MethodInterceptor[]interceptors = registry.getInterceptors(advisor);</span><br><span class="line"></span><br><span class="line">                    //检查当前advisor的pointcut是否可以匹配当前方法</span><br><span class="line">                    MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"></span><br><span class="line">                    if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">                        if(mm.isRuntime()) &#123;</span><br><span class="line">                            // Creating a newobject instance in the getInterceptors() method</span><br><span class="line">                            // isn&apos;t a problemas we normally cache created chains.</span><br><span class="line">                            for (intj = 0; j &lt; interceptors.length; j++) &#123;</span><br><span class="line">                               interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else if (advisor instanceof IntroductionAdvisor)&#123;</span><br><span class="line">                IntroductionAdvisor ia =(IntroductionAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors= registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                Interceptor[] interceptors =registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor.</p>
<p>接下来我们再看下得到的拦截器链是怎么起作用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">       //  We start with an index of -1and increment early.</span><br><span class="line">       if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123;</span><br><span class="line">           //如果Interceptor执行完了，则执行joinPoint</span><br><span class="line">           return invokeJoinpoint();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Object interceptorOrInterceptionAdvice =</span><br><span class="line">           this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line"></span><br><span class="line">       //如果要动态匹配joinPoint</span><br><span class="line">       if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)&#123;</span><br><span class="line">           // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">           // been evaluated and found to match.</span><br><span class="line">           InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">           //动态匹配：运行时参数是否满足匹配条件</span><br><span class="line">           if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123;</span><br><span class="line">                //执行当前Intercetpor</span><br><span class="line">                returndm.interceptor.invoke(this);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">                //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class="line">                return proceed();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // It&apos;s an interceptor, so we just invoke it: The pointcutwill have</span><br><span class="line">           // been evaluated statically before this object was constructed.</span><br><span class="line">           //执行当前Intercetpor</span><br><span class="line">           return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8A%E7%AF%87/" target="_blank" rel="noopener">Spring AOP与IOC</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/springAOP/" data-id="cjuajt8rz000jfcamvnsjolem" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dubbo" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/dubbo/" class="article-date">
  <time datetime="2019-03-25T11:53:06.534Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p><strong>Dubbo架构</strong><br><img src="pictures/dubbo架构.png" alt="Dubbo架构"><br><img src="pictures/Dubbo节点说明.png" alt="节点说明"><br><img src="pictures/调用关系.png" alt="调用关系"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/dubbo/" data-id="cjuajt7r50002fcamuzrruqtf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统_存储器管理和虚拟存储器" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/操作系统_存储器管理和虚拟存储器/" class="article-date">
  <time datetime="2019-03-22T07:06:35.745Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h4 id="一-存储器的层次结构"><a href="#一-存储器的层次结构" class="headerlink" title="一.存储器的层次结构"></a>一.存储器的层次结构</h4><p><img src="pictures/计算机系统存储层次示意图.png" alt="存储层次示意图"></p>
<ol>
<li>主存储器</li>
</ol>
<p>主存储器是计算机系统中的一个主要部件，用于保存进程运行时的程序和数据，CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器中读取并将他们装入到寄存器中，或者从寄存器存入到主存储器，CPU与外围设备交换的信息一般也依托于主存储器地址空间。但是，主存储器的访问速度远低于CPU执行指令的速度，于是引入了寄存机和告诉缓冲。</p>
<ol start="2">
<li>寄存器</li>
</ol>
<p>寄存器访问速度最快，能与CPU协调工作，价格昂贵，容量不大，寄存器用于加速存储器的访问速度，如用寄存器存放操作数，或用作地址寄存器加快地址转换速度等。</p>
<ol start="3">
<li>高速缓存</li>
</ol>
<p>高速缓存容量大于或远大于寄存器，但小于内存，访问速度高于主内存器，根据程序局部性原理，将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度。通常，进程的程序和数据存放在主存，每当使用时，被临时复制到高速缓存中，当CPU访问一组特定信息时，首先检查它是否在高速缓存中，如果已存在，则直接取出使用，否则，从主存中读取信息。有的计算机系统设置了两级或多级高速缓存，一级缓存速度最高，容量小，二级缓存容量稍大，速度稍慢。</p>
<ol start="4">
<li>磁盘存储</li>
</ol>
<p>　磁盘的IO速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息暂时存放在磁盘缓存中，可减少访问磁盘的次数，磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读出或写入的信息，主存可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。</p>
<h4 id="二-连续分配存储管理方式"><a href="#二-连续分配存储管理方式" class="headerlink" title="二.连续分配存储管理方式"></a>二.连续分配存储管理方式</h4><p>为了能将用户程序装入内存，必须为它分配替丁大小的内存空间。连续分配方式是最早出现的一种存储器分配方式。</p>
<p><strong>连续分配的方式</strong></p>
<ol>
<li><p><strong>单一连续分配:</strong> 这是一种最简单的存储管理方式，但只能在单用户、单任务的操作系统中，将内存分为系统区和用户区，系统区供OS使用，通常放在内存的低地址，用户区是指除系统区以外的全部内存空间，提供给用户使用。</p>
</li>
<li><p><strong>固定分区分配:</strong> 固定分区分配是一种最简单的可运行多道程序的存储管理方式，将内存用户空间划分为若干个固定大小的区域，在每个分区只装入一道作业，这样，便允许多道作业并发执行，当有空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。</p>
</li>
</ol>
<p>对于内存的用户空间的划分，有如下两种方法。</p>
<p>　　① 分区大小相等，即所有的内存分区大小相等。缺点是缺乏灵活性，即当程序太小时，会造成内存资源的浪费，程序太大时，一个分区由不足以装入该程序，只是该程序无法运行。</p>
<p>　　② 分区大小不等，把内存区划分成含有多个较小的分区、适量中等分配和少量大分区，这样，便可根据程序的大小为之分配适当的分区。</p>
<p>为了便于内存分配，将分区按大小进行排队，并为之简历一张分区使用表，其中各表项包括每个分区的起始地址、大小、状态（是否已分配），当有一个程序需要装入时，由内存分配程序检索该表，从中找出一个能满足要求的，尚未分配的分区，将之分配给该程序，然后将该表项中的状态设置为已分配，若未找到大小足够的分区，则拒绝为该用户分配内存。</p>
<p><img src="pictures/分区表.png" alt="分区表"></p>
<ol start="3">
<li><strong>动态分区分配：</strong> 动态分区分配是根据进程的实际需要，动态地为之分配内存空间，在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法、分区的分配和回收等。</li>
</ol>
<p>　① 分区分配中的数据结构，为了实现分区分配，胸中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况，为分配提供依据，常用的数据结构有如下两种形式：空闲分区表（在系统中设置一张空闲分区表，用于记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区序号、分区始址、分区大小等，在前面已有介绍）、空闲分区链（为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的向前指针；在分区尾部设置一向后指针，这样，可以将空闲分区链接成一个双向链），为了检索方便，在分区尾部重复设置状态为和分区大小表目，当分区被分配出去以后，把状态为从0改成1，此时前后指针都失去意义（已经不再空闲链表中）。<br><img src="pictures/空闲链结构.png" alt="空闲链结构"></p>
<p>　　③ 分区分配操作，在动态分区分配存储管理中，主要的操作是分配内存和回收内存。</p>
<p><strong>回收分区：</strong>　当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时会出现如下四种情况之一：回收分区与插入点的前一个空闲区F1相邻接，此时将回收区与插入点的前一分区合并，不必为回收区分配新表项，只需要修改前一分区F1的大小。回收分区与插入点的后以空闲分区F2相邻接，此时将两分区合并，形成新的空闲分区，用回收区的首址作为新空闲区的首址，大小为两者之和。回收区同时与插入点的前、后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。回收区既不与F1邻接，也不与F2邻接，这时为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p>
<p><strong>分区分配算法：</strong><br>为把一个新作业装入内存，需按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业，目前常用一下五种分配算法。</p>
<p><strong>（1）首次适应算法  ：</strong><br>以空闲分区链为例进行说明，FF算法要求空闲分区链以地址递增的次序链接，在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按照作业的大小，从该分区划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中，若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这给以后达到的大作业分配大的内存空闲创造了条件，缺点在与低地址空间不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低地址部分开始，这无疑会增加查找可用空闲分区的开销。</p>
<p><strong>（2）循环首次适应算法  ：</strong>　由首次适应算法演变而来，在未进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划分出一块与请求大小相等的内存空间分配给作业。进行空闲分区分配时，会采用循环查找方式，即如果最后一个（链尾）空闲分区的大小仍不能满足要求，则返回第一个空闲分区。该算法能使内存中的空闲分区分布得更加均匀，从而减少了查找空闲分区时的开销，但是会缺乏大的空闲分区。</p>
<p><strong>（3）最佳适应算法  ：</strong><br>该算法总是能把满足要求、又是最小的空闲分区分配给作业，避免大材小用，为了加速寻找，该算法要求把所有的空闲分区按其容量以从小到大的顺序形成一个空闲分区链，这样，第一次就能找到满足要求的空闲区，必然是最佳的，孤立地看，最佳适应算法似乎是最佳的，然而宏观上却不一定，因为每次分配后所切割下来的剩余部分总是最小的，会留下很多难以使用的小空闲区。</p>
<h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><p>为了提高搜索空闲分区的速度，在大，中型系统中往往会采用基于索引搜索的动态分区分配算法，目前常用的有  快速适应算法，伙伴系统和哈希算法。</p>
<p><strong>（1）快速适应算法  ：</strong></p>
<p>该算法又称为分类搜索法，是将空闲分区容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这些，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。该算法的优点是查找效率高，仅需根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。但是在分区归还主存时算法复杂，系统开销大。</p>
<p><strong>（2）伙伴系统   ：</strong><br>伙伴系统规定，无论已分配分区还是空闲分区，其大小均为2的k次幂，k为整数，1&lt;= k &lt;= m，其中，2^1表示分配的最小分区的大小，2^m表示分配的最大分区的大小，通常2^m是整个可分配内存的大小。假设系统开始时的初始容量为2^m个字，由于不断切分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。</p>
<p>　　当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使2^i-1 &lt; n &lt;= 2^i，然后，在空闲分区大小为2^i的空闲分区链表中查找，若找到，即把该空闲分区分配给进程，否则，表明2^i的空闲分区已经耗尽，在大小为2^i+1的空闲分区链表中查找，若存在，则将该空闲分区分为两个大小为2^i的分区，一个用于分配，一个加入到大小为2^i的空闲分区链表中，若还是不存在，则继续在大小为2^i+2的空闲分区链表中查找，若存在，则将空闲分区进行两次分割，一次分割为两个大小为2^i+1的空闲分区，一个加入到大小为2^i+1的空闲分区链表中，另外一个继续进行分割，分成两个大小2^i的空闲块，一个用于分配，另外一个加入到大小为2^i的空闲分区链表中，以此类推。在最坏的情况下，可能需要对2^k的空闲分区进行k此分割才能得到所需分区。</p>
<p>　　当回收空闲分区时，也需要经过多次合并，如回收大小为2^i的空闲分区时，若事先已经存在2^i的空闲分区，则应将其与伙伴分区合并为一个大小为2^i+1的空闲分区，若事先已存在2^i+1的空闲分区，则再次进行合并，合并为2^i+2的分区，以此类推。</p>
<p><strong>（3）哈希算法  ：</strong></p>
<p>在上述的分类搜索算法和伙伴系统算法中，都是将空闲分区根据大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在一张管理索引表中查找到所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针，从而通过查找得到一个空闲分区。如果空闲分区分类较细，则相应的表项就多了。</p>
<p>哈希算法就是利用快速查找的优点，以及空闲分区在可利用空闲表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p>
<h4 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h4><p>在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况，另一方面，却有很多作业在外存上等待，因无内存而无法进入内存运行的情况，这是对系统资源的浪费，为了解决这个问题，增设了对换设施，对换是把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或者进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施。如果对换的单位是进程，便称为整体对换或进程对换，为了实现进程对换，系统必须实现对换空间的管理、进程的换出、进程的换入。</p>
<h4 id="基本的分页存储管理方式"><a href="#基本的分页存储管理方式" class="headerlink" title="基本的分页存储管理方式"></a>基本的分页存储管理方式</h4><p>连续分配方式会形成很多碎片，为之进行紧凑操作的开销非常大，如果允许一个进程直接分散地装入到许多不相邻接的分区中，则无须进行紧凑操作，基于这一思想产生了离散分配方式，如果离散分配的基本单位是页，则称为分页存储管理方式，若为段，则为分段存储管理方式。</p>
<p><strong>页面与页表</strong></p>
<p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页进行编号，从0开始。相应地，把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或者页框，也同样为它们编号，如0#块，1#块等。在进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻接的物理块中，由于进程的最后一页经常装不满一块而形成不可利用的碎片，称之为页内碎片。</p>
<p>在分页系统中的页面其大小应适中，页面若太大，一方面可以是内存碎片减少，有利于提供内存利用率，但是，每一个进程占用的页面较多，导致页表过长，占用太多内存，会降低页面换进换出的效率。页面若太大，可减少页表的长度，提供页面换进换出的速度，但是，内存碎片会增大，所以，也页面大小应适中，通常为512B~8K：</p>
<p><img src="pictures/分页地址中的地址结构.png" alt="分页地址中的地址结构"></p>
<p><strong>为了能够保证在内存中找到每个页面所对应的物理块，系统为每个进程建立了一张页面映射表，简称为页表。页表项纪录了相应页在内存中对应的物理块号，在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号，页表实现了从页号到物理块号的地址映像。</strong><br><img src="pictures/页面到块的额映射.png" alt="页面到块的映射"></p>
<p>　即使在简单的分页系统中，也常在页表的表项中设置一存取控制字段，用于对该存储块中的内存加以保护，当存取控制字段仅有一位时，可用来规定该存储块中的内存时允许读/写，还是只读；若存取控制字段为二位，则可规定为读/写、只读、只执行等存取方式。</p>
<p><strong>地址变换机构</strong></p>
<p>为了能够将用户地址空间中的逻辑地址变换为内存空间中的物理地址，在系统中必须设置地址变换机构，该机构的基本任务是实现从逻辑地址到物理地址的转换，由于页内地址与物里块内的地址一一对应，无须再进行转换，因此，地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。又因为页面映射表的的作用就是用于实现从页号到物理块号的变换，因此，地址变换任务是借助页表来完成的。</p>
<p>页表的功能可以由一组专门的寄存器来实现，一个页表项用一个寄存器，由于寄存器具有较高的访问速度，因而有利于提高地址变换的速度，但成本较高，且页表项一般会很多，都使用寄存器实现不太现实，因此，页表大多驻留在内存。在系统中只设置一个页表寄存器PTR(Page-Table Register)，用于存放页表在内存的始址和页表的长度，平时，进程执行时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，将这两个数据装入页表寄存器，因此，在单处理机环境下，虽然系统中可以运行多个进程，但只需要一个页表寄存器。</p>
<p>　　当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引去检索页表，查找操作由硬件执行，在执行检索前，先将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址超越了进程的地址空间，这一错误将被系统发现并产生一个地址越界中断。若未出现错误，则将页表始址加上页号与页表项长度的乘积，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器，与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中，这样，便完成了逻辑地址到物理地址的转换。<br><img src="pictures/分页系统的地址变化机构.png" alt="分页系统的地址变换机构"></p>
<p>上述操作中，每次存取一个数据时，都会访问内存两次，第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址，第二次访问时，才是从第一次所得的地址中获得所需数据，因此，这种方式会使计算机的处理速度降低一半，<strong>为了提高地址变换速度，可以在地址变换机构中增设一个具有并行查询能力的特殊高速缓冲寄存器，又称为联想寄存器或快表，用以存放当前访问的那些页表项。</strong></p>
<p><img src="pictures/快表地址变换结构.png" alt="快表地址变换结构"></p>
<p><strong>两级和多级页表</strong></p>
<p><img src="pictures/两级和多级页表.png" alt="两级和多级页表"><br><img src="pictures/两级页表.png" alt="两级页表"><br><img src="pictures/页表地址变换.png" alt="页表地址变换"></p>
<h4 id="基本存储管理方式"><a href="#基本存储管理方式" class="headerlink" title="基本存储管理方式"></a>基本存储管理方式</h4><p>从固定分区到动态分区分配，再到分页存储管理方式，其主要动力为提高内存利用率，引入分段存储管理的目的在于满足用户在编程和使用上多方面的要求。如</p>
<p>　　① 方便编程，用户可以把自己的作业按照逻辑关系划分为若干段，每个段都是从0开始编址，并有自己的名字和长度。</p>
<p>　　② 信息共享，在实现对程序和数据的共享时，是以信息的逻辑单位为基础的，比如共享某个函数。</p>
<p>　　③ 信息保护，信息保护同样是对信息的逻辑单位进行保护。</p>
<p>　　④ 动态增长，在实际应用中，数据段在使用过程中往往会不断增长，而实现无法确切知道数据段会增长到多大，分段可以较好的解决这个问题。</p>
<p>　　⑤ 动态链接，再运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中有需要调用某段时，才将该段调入内存并进行链接。</p>
<p><strong>分段系统的基本原理</strong></p>
<p>在分段管理中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如有主程序段MAIN，子程序段X，数据段D及栈段S，每个段都有自己的名字，每个段从0开始编址，并采用一段连续的地址空间，段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址构成。<br><img src="pictures/作业的地址空间结构.png" alt="结构"></p>
<p>　　说明：一个作业允许最长有64K个段，每个段的最大长度为64KB。</p>
<p>在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区，为了使程序正常运行，能够物理内存中找出每个逻辑段所对应的位置，应该为每个进程建立一张段映射表，称为段表，每个段在表中有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但通常将段表放在内存中。段表用于实现从逻辑段到物理内存区的映射。</p>
<p><img src="pictures/段表.png" alt="段表"></p>
<p><strong>分页与分段存在很大的相似性，如都采用离散分配方式，都需要通过地址映射机构实现地址变换，但两者的主要区别如下。</strong></p>
<p>　　① 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，或者说，分页仅仅是由于系统管理的需要而不是用户的需要，段则是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。</p>
<p>　　② 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，一个系统中，只存在一种大小的页面，段的长度则不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>　　③ 分页的作业的地址空间是一维的，即单一的线性的地址空间，程序员只利用一个记忆符即可表示一个地址，而分段的作业地址空间是二维的，程序员在标识一个地址是，需要给出段名和段内地址。</p>
<p><strong>段页式存储管理</strong></p>
<p>分页系统能够有效的提高内存利用率（但是会存在页内碎片），分段系统则能够很好地满足用户需要。若能将两种方式结合起来，既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等优点，又能像分页系统那样很好地解决内存的外部碎片问题，基于此，提出了段页式系统。<br><img src="pictures/段页式地址结构.png" alt="段页式地址结构"><br><img src="pictures/段页式存储结构.png" alt="段页式存储结构"></p>
<p>#虚拟存储器<br>内存的容量有限, 如果有大作业或大量作业运行, 内存就会不够用. 为解决这一问题边催生了虚拟存储器的概念.从逻辑上扩从内存。</p>
<p>常规存储器管理方式的特征</p>
<p><strong>一次性：</strong><br>作业必须一次性地全部装入内存后才能开始运行.</p>
<p><strong>驻留性：</strong><br>作业被装入内存后, 整个作业都一直驻留在内存中, 其中任何部分都不会被换出, 直至作业运行结束。</p>
<p><strong>局部性原理：</strong></p>
<p>时间局限性：如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。</p>
<p>空间局限性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p>
<p><strong>虚拟存储器的基本工作情况：</strong><br>应用程序在运行之前没有必要将之全部装入内存，而仅将那些当前要运行的少数页面或段先装入内存便可运行，其余的暂留在盘上。程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但是入伙程序所要访问的页（段）尚未调入内存，便发出缺页中断请求，此时OS系统将利用请求调页功能将它们调入内存。如果此时内存已满，OS系统还需再利用页的置换功能，将内存中暂时不用的页调至盘上，腾出足够的内存空间后，再将要访问的页面调入内存</p>
<p>定义：具有请求调入和置换功能, 能从逻辑上对内存容量加以扩充的存储器系统。</p>
<p><strong>特征：</strong></p>
<p>1.多次性. 一个作业中的程序和数据无需再作业运行时一次性全部装入内存, 而是允许被分成多次调入内存运行. (只需当前要运行的部分程序和数据装入内存即可)</p>
<p>2.对换性. 一个作业中的程序和数据, 无须在作业运行时一直常驻内存, 而是允许在作业的运行过程中进行对换操作.(在进程运行期间, 将有用的程序或数据换入, 无用的则换出)</p>
<p>3.虚拟性. 能够从逻辑上扩充内存容量. 提高内存利用率</p>
<p>虚拟性是以多次性和对换性为基础的.</p>
<p><strong>虚拟存储器可以通过请求分页, 请求分段的方法实现, 它们都需要软硬件支持, 主要硬件有页(段)表机制, 缺页(段)中断机构, 地址变换结构。</strong></p>
<h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><p><strong>求情页表机制</strong><br>请求页标机制，将用户地址空间中的逻辑地址映射成为内存空间中的物理地址。<br><strong>页表</strong><br><img src="pictures/请求分页.png" alt="请求分页"></p>
<p><strong>缺页中断机制</strong></p>
<p>每当要访问的页面不再内存时, 便产生依次缺页中断, 请求OS将所缺之页调入内存.</p>
<ol>
<li>指令在执行期间产生和处理中断信号</li>
<li>一条指令在执行期间可能产生多次缺页中断</li>
</ol>
<p><strong>地址变换机构</strong></p>
<p><img src="pictures/地址变换机构.png" alt="地址变换"></p>
<p><strong>内存分配</strong></p>
<p><strong>最小物理块数</strong><br>最小物理块数能保证进程正常运行, 它取决于指令的格式, 功能和寻址方式.</p>
<p><strong>内存分配策略</strong><br>内存在进行分配时可以采取固定分配和可变分配.</p>
<p><strong>固定分配：</strong> 为每个进程分配一组固定数目的物理块, 在进程运行期间不可更改.</p>
<p><strong>可变分配：</strong><br>为每个进程分配一定数目的物理块, 在进程运行期间可以更改.<br>页面置换时可以采取全局置换和局部置换.</p>
<p><strong>全局置换：</strong> 如果进程在运行期间返现缺页, 则将OS所保留的空间物理块取出一块分配给该进程, 或者以所有进程的全部物理块为标的, 选择一块换出, 然后将所缺之页调入.</p>
<p><strong>局部置换：</strong> 如果进程在运行中发现缺页, 则只能从分配给该进程的n个页面中选出一页换出, 然后在调入一页, 以保证分配给该进程的内存空间不变.<br>通过以上可以组合一下三种策略:</p>
<p><strong>固定分配局部置换</strong><br>为每个进程分配多少物理块是根据进程类型(交互型或批处理型)或根据程序员的建议来确定.</p>
<p><strong>可变分配全局置换</strong><br>凡是产生缺页的物理块, 都将获得新的物理块.</p>
<p><strong>可变分配全局置换</strong><br>为每个进程分配一定数目的物理块, 但当某进程发现缺页时, 只允许从该进程在内存的页面中选择一页换出.</p>
<p>物理块分配算法</p>
<p><strong>平均分配算法.</strong> 将系统中所有可供分配的物理块平均分配给各个进程.</p>
<p><strong>按比例分配算法</strong> 根据进程大小按比例分配物理.</p>
<p><strong>考虑优先权的分配算法</strong><br>一部分按比例分配, 一部分根据进程的优先权分配</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><strong>1.最佳置换算法：</strong><br>其所选择的被淘汰页面，将是以后永不使用的， 或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。</p>
<p><strong>2.先进先出页面置换算法：</strong><br>淘汰最先进入内存的页面, 即在内存中驻留时间最久的页面.<br>实现方便。不需要额外硬件。 效果不好。</p>
<p><strong>3.最近最久未使用的算法LRU（Least Recently Used）</strong><br>根据页面调入内存后的使用情况来做出决策。<br>为了快速知道哪一页是最近最久未使用的页面，需要硬件支持（寄存器和栈两类硬件之一的支持）</p>
<p><strong>寄存器：</strong><br>为了记录某个进程在内存中各页的使用情况，须为每个在内存中的页面置换一个移位寄存器，可表示R=R(n-1)R(n-2)R(n-3)R(n-4)R(n-5)….R0</p>
<p>当进程访问某个物理块时，要将相应的寄存器R(n-1)位置置1,。此时，定时信号将每隔一定时间将寄存器右移一位，如果我们把n位寄存器的数看成是一个整数，那么具有最小数值的寄存器所对应的页面，就是最近最久为使用的页面</p>
<p><strong>栈：</strong><br>可利用一个特殊的栈保存当前使用的各个页面的页面号。每当有进程访问某页面时，便将该页面的页面号从栈中移除，将它压入栈顶。因此栈顶始终就是最新被访问的页面编号，而栈低则是最近最久未使用页面的页面号</p>
<p>最近最久未使用的页面予以淘汰</p>
<p><strong>4.最少使用的页面置换算法</strong></p>
<p>在采用LFU算法时，应为在内存中的每个页面设置一个一位寄存器，用来记录该页面被访问的频率。该算法选择在最近时期使用最少的页面作为淘汰页</p>
<p>每次访问某页时，便将该移位寄存器的最高位置置1，每个一定时间右移一次。这样，在最近一段时间使用最少的将是  寄存器各个位置上的数字之和最小的页</p>
<p>LFU与LRU访问图完全相同，利用一套硬件既可以实现LRU算法，又可实现LFU算法</p>
<p><strong>Clock置换算法</strong><br>为每页设置一位访问位, 再将内存中的所有页面都通过链接指针链接成一个循环队列. 当某页被访问时, 其访问位被置1. 置换算法在选择一页淘汰时, 只需检查页的访问位. 如果是0, 就选择该页换出; 若为1, 则重新将它置0, 暂不换出; 再按照FIFO算法检查下一个页面. 当检查到队列中的最后一个页面时, 若其访问位仍为1, 则再返回到队首去检查第一个页面.</p>
<p><img src="pictures/简单的Clock置换算法.png" alt="简单Clock置换算法"><br><strong>改进型的Clock置换算法</strong><br>将一个页面换出时，如果页面已被修改过，便须将页重新写回到磁盘上；但如果该页面被修改过，则不必将它拷回到磁盘上。对于修改过的页面，在换出时所付出的开销比未修改的页面大，或则说，置换代价大。在改进型Clock算法中，除考虑页面的使用情况，还要增加一个因素-置换代价。这样，选择页面换出时，即要是未使用过的页面，又要是未被修改过的页面。</p>
<p><strong>1类(A=0, M=0): 表示该页最近既未被访问, 又未被修改, 是最佳淘汰页.</strong></p>
<p><strong>2类(A=0, M=1):表示该页最近未被访问, 但已被修改, 并不是很好的淘汰页.</strong></p>
<p><strong>3类(A=1, M=0)：最近已被访问, 但未被修改, 该页有可能再被访问.</strong></p>
<p><strong>4类(A=1, M=1):最近已被访问且被修改, 该页可能再被访问</strong></p>
<p><strong>执行过程：</strong></p>
<ol>
<li>从指针所指当前位置开始, 扫描循环队列, 寻找A=0且M=0的页面, 将遇到的第一个页面作为淘汰页. 在第一次扫描期间不改变访问位A.</li>
<li>如果第一步失败, 即查找一轮后未遇到的第一类页面, 则开始第二轮扫描, 寻找A=0且M=1的页面, 将所遇到的第一个这类页面作为淘汰页. 在第二轮扫描期间, 将所有扫描过的页面的访问位置都置0.</li>
<li>第二步也失败, 亦即未找到第二类页面, 则将指针返回到开始的位置, 并将所有的访问位复0. 然后重复第一步. 若果仍失败, 必要时重复第二步, 此时就一定能找到被淘汰的页.</li>
</ol>
<p><strong>页面分配策略</strong><br>何时调入页面</p>
<ol>
<li>预调入策略<br>将在不久之后便会被访问的页面预先调入内存</li>
<li>请求调入策略<br>当进程所访问的页面不再内存中时, 便立即请求, 由OS将所需页面调入内存.<br>从何处调入页面</li>
</ol>
<p>若系统由足够的对换区, 则从对换区调入. 否则从文件区调入.<br>UNIX方式: 未运行国的页面从文件区调入, 运行过的页面从对换区调入(运行过的页面已被换出至对换区</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>抖动现象: 在系统中的进程太多, 需要频繁的进行进程的对换操作, 以至于占用太多时间, 从而处理机的利用率下降并趋于0的情况, 我们称之为抖动. 通常用工作集来避免抖动</p>
<p>工作集是在某段时间内, 进程实际索要访问的页面集合. 我们将这些页面又称为活跃页面.</p>
<p>预防抖动的方法</p>
<ol>
<li>采取局部置换策略</li>
<li>工作集算法融入处理机调度</li>
<li>调节缺页率</li>
<li>暂停进程</li>
</ol>
<h3 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h3><p><img src="pictures/请求段表.png" alt="请求段表"></p>
<p><strong>缺段中断机构</strong><br><img src="pictures/缺段中断.png" alt="缺段中断"></p>
<p><strong>请求分段地址变换</strong><br><img src="pictures/求情分段地址变换.png" alt="请求分段地址变换机构"></p>
<h4 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h4><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</p>
<p>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</p>
<p>段向用户提供二维地址空间；页向用户提供的是一维地址空间</p>
<p>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/操作系统_存储器管理和虚拟存储器/" data-id="cjuajt94h000mfcam1qqokkgn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统_处理机的调度与死锁" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/21/操作系统_处理机的调度与死锁/" class="article-date">
  <time datetime="2019-03-21T09:07:28.517Z" itemprop="datePublished">2019-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h2><h4 id="1-处理机调度的类型"><a href="#1-处理机调度的类型" class="headerlink" title="1.处理机调度的类型"></a>1.处理机调度的类型</h4><p><strong>（1）作业调度</strong></p>
<p>作业调度的本质就是根据某种算法，把外存上的作业调入内存，并为之创建进程，分配处理机并执行。</p>
<p><strong>（2）进程调度</strong></p>
<p>进程调度的本质就是根据某种算法，把处理机分配给进程。进程调度首先会保存处理机现场。将程序计数器等指定寄存器中的内容保存到PCB中。然后将按照某种算法从就绪队列中选取进程，把处理机分配给进程。最后，把指定进程的PCB中的处理机现场信息恢复到处理机中，处理机分配给进程执行。</p>
<p>1）进程调度中的三个基本机制</p>
<p>排队器：将所有的就绪进程按照一定方式 （如优先级）排成一个队列，以便调度程序找到。</p>
<p>分派器:把从就绪队列中取出的进程，处理机上下文切换后，把处理机分配给该进程执行。</p>
<p>上下文切换机制:<br>　　（PS：这里有一个额外的知识：通常每一次上下文切换需要花费几毫秒的时间。有一种简单的方式，通过多组寄存器来减少上下文切换的时间。一组寄存器供处理机在系统态使用，一组供处理机在应用程序状态时使用。这样，上下文切换的时候只需要改变指针，指向当前的寄存器。）</p>
<p>　　（PSS：CPU的系统态就是CPU在执行操作系统，用户态则是CPU在执行普通应用程序。）</p>
<p>　　2）进程调度的两种调度方式</p>
<p>非抢占式（Nonpreemptive Mode）。说白了就是一旦把进程分配给某个进程，除非它自愿退出，它将永远运行下去。<br>抢占式（Preemptive Mode）。说白了就是可以根据某种条件，使正在运行的进程暂停，将处理机分配给另一个进程。相当于信号量机制中的条件变量。</p>
<p>“抢占”不是一种任意性行为，必须遵循一定的原则：</p>
<ol>
<li>优先权原则</li>
<li>短进程优先原则</li>
<li>时间片原则</li>
</ol>
<p><strong>（3）中级调度</strong></p>
<p>中级调度的本质就是让暂时不能运行的进程挂起，释放内存资源，并把它们调到外存上去等待。什么是外存？外存就是硬盘、磁盘等存储设备。</p>
<h4 id="2-作业调度算法"><a href="#2-作业调度算法" class="headerlink" title="2.作业调度算法"></a>2.作业调度算法</h4><p><strong>先来先服务调度算法（FCFS）：</strong><br>该算法即可以用于作业调度，也可以用于进程调度。</p>
<p>就是先来的先进入内存或占用处理机。对于作业调度，就是从后备作业队列中选择一个或多个最先进入队列的作业，将其调入内存。对于进程调度就是从就绪队列选择最先进入的进程，为之分配处理机。</p>
<p><strong>短作业（进程）优先调度算法（SJF）</strong></p>
<p>就是在选择作业或进程的时候，先估算每个作业、进程的服务时间，选择其中最短的优先获得处理机。</p>
<p>缺点：</p>
<p>1.必须预知作业的运行时间</p>
<p>2.对长作业非常不利，长作业的周转时间明显增长</p>
<p><strong>优先级调度算法和高响应比优先调度算法</strong></p>
<ol>
<li>优先级调度算法and 高响应比优先调度算法</li>
</ol>
<p>基于作业的紧迫程度，由外部赋予作业响应的优先级</p>
<p>这种算法给进程加了一个属性，那就是优先权。这个算法的本质就是，高优先权的优先调用。优先权有两种类型，一种是静态的，即每个进程、作业的优先权在它创建的时候就已经确定，此后都不能改变。另一种是动态的，即进程、作业的优先权是可以改变的。最常见的做法就是进程、作业在等待中，优先权以一定速率随时间增长，这样等待时间越长，被调用的可能性就越大。</p>
<h4 id="3-进程调度算法"><a href="#3-进程调度算法" class="headerlink" title="3.进程调度算法"></a>3.进程调度算法</h4><p><strong>轮转调度算法</strong></p>
<ol>
<li>轮转法的基本原理</li>
</ol>
<p>这就是分时系统中采用的调度算法。原理就是把所有的就绪队列进程按先来先服务的原则排成队列。每次都把CPU分配给队首，让其执行一个时间片，执行完毕，调度器中断进程，并把该进程移至就绪队列的队尾，然后再取一个队首进程，继续执行下一个时间片。时间片是什么，就是一段很短的CPU时间，几毫秒到几百毫秒不等。</p>
<ol start="2">
<li>进程切换时机</li>
</ol>
<p>两种情况:</p>
<p>(1)时间片未完成，正在运行的程序便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行</p>
<p>(2)在一个时间片用完时，计时器中断处理程序被激活，将该程序放到就绪队列的队尾</p>
<ol start="3">
<li>时间片大小的确定</li>
</ol>
<p>时间片太小，意味着会频繁地执行进程调度和进程上下文切换</p>
<p>时间片太长就会退化成FCFS算法</p>
<p>一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间</p>
<p><strong>优先级调度算法</strong></p>
<p>两种类型：</p>
<ol>
<li>非抢占式优先级调度算法：一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成</li>
<li>抢占式调度算法：把处理机分配给优先级最高的进程，使之执行，但在其执行时间内，只要出现了另一个其优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程</li>
</ol>
<p><strong>优先级的类型</strong></p>
<p>静态优先级：创建程序时确定的</p>
<p>动态优先级：先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能</p>
<p><strong>多队列调度算法</strong></p>
<p>该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的额就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级</p>
<p><strong>多级反馈队列调度算法</strong></p>
<p>（1）设置多个就绪队列，第一个就绪队列优先级最高。第二个就绪队列优先级第二，其余队列也一样，优先级依次递减，时间片依次增加</p>
<p>（2）每个队列都采用FCFS算法</p>
<p>（3）按队列的优先级进行调度。调度程序首先调度最高优先级队列中的诸进程运行，仅当第一队列空时才调度第二队列中的进程运行。</p>
<p><strong>基于公平原则的调度算法</strong></p>
<ol>
<li>保证调度算法</li>
</ol>
<p>保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。一种比较容易实现的性能保证是处理机分配的公平。如果有n个相同类型的进程同时运行，为了公平起见，须保证每个进程获得相同的处理机时间1/n</p>
<ol start="2">
<li>公平分享调度算法</li>
</ol>
<p>分配给每个进程相同的处理机时间，显然这对诸进程而言，是体现了一定程度的公平，但是如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。</p>
<h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p><strong>1.实现实时调度的基本条件</strong></p>
<p>1.提供必要的信息</p>
<p>（1）就绪时间，是指某任务称为就绪状态的起始时间</p>
<p>（2）开始截止时间和完成截止时间</p>
<p>（3）处理时间，一个任务从开始执行，直到完成时所需要的时间</p>
<p>（4）资源要求，任务执行时所需的一组资源</p>
<p>（5）优先级</p>
<p>2.系统能力强</p>
<p>在实时系统中，若是处理能力不够强，则可能因为处理机忙不过来，而致使某些实时任务不能得到及时的处理，从而导致发生难以预料的后果</p>
<p>3.采用抢占式调度机制</p>
<p>4.具有快速切换的机制：（1）对中断的快速响应能力（2）快速的任务分配能力</p>
<p><strong>实时调度算法</strong></p>
<p>1.抢占式调度算法</p>
<p>2.非抢占式调度算法</p>
<p><strong>1.最早截止时间优先EDF算法：</strong><br>该任务是根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是优先选择就绪队列中的第一个任务，为之分配处理机</p>
<p><strong>2.最低松弛度优先LLF算法：</strong><br>该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度越高，赋予该任务的优先级就越高，以是使之优先执行。例如一个任务在200ms时必须完成，而它本身所需运行时间为100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度为100ms。实现该算法时系统中有一个按松弛程度排序的实时任务就绪队列，松弛度最低的任务排在最前面。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进</p>
<p><strong>死锁产生的的原因：</strong></p>
<ol>
<li>系统资源的竞争</li>
</ol>
<p>（1）竞争不可抢占性资源而引起的死锁：通常系统中拥有不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。如磁盘，打印机<br>（2）竞争可消耗资源引起的死锁：例如：p1收到p2的消息向并p2发出消息，同时p2收到p1发出的消息，并向p1发出消息，两个进程形成一个环，如果两个进程一个收一个发则不会造成死锁，若两个进程同时都进行收操作以后才发送消息就会造成死锁。</p>
<ol start="2">
<li>进程推进顺序非法</li>
</ol>
<p>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。</p>
<p><strong>死锁产生的必要条件</strong></p>
<p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<p>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<p>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有</p>
<p><strong>处理死锁的方法</strong></p>
<ol>
<li>预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</li>
<li>检测死锁：无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后釆取某种措施解除死锁。</li>
<li>解除死锁：当系统检测到系统中已经发生死锁时，就采取相应的措施，将进程从死锁中解脱出来。常用的方法就是撤销一些进程，回收他们的资源，将他们分配给已经处于阻塞状态的进程。</li>
</ol>
<p><img src="pictures/死锁策略比较.png" alt="死锁策略"></p>
<p><strong>预防死锁</strong></p>
<p>1) 破坏互斥条件</p>
<p>如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p>
<p>2) 破坏不剥夺条件</p>
<p>当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。</p>
<p>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p>
<p>3) 破坏请求和保持条件</p>
<p>釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p>
<p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p>
<p>4) 破坏循环等待条件</p>
<p>为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。</p>
<p><strong>死锁避免</strong></p>
<p>1.系统安全状态</p>
<p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。</p>
<p>所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, …, Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, …, Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。</p>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
<p>2.银行家算法</p>
<p>银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<p>1) 数据结构描述</p>
<p>可利用资源矢量Available：含有m个元素的歎组，其中的每一个元素代表一类可用的资源数目。Available[j]=K，则表示系统中现有Rj类资源K个。</p>
<p>最大需求矩阵Max：为n*m矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i, j]=K，则表示进程i需要Rj类资源的最大数目为K。</p>
<p>分配矩阵Allocation：为n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。All0Cati0n[i, j]= K，则表示进程i当前已分得Rj类资源的数目为K。</p>
<p>需求矩阵Need：为n*m矩阵，表示每个进程尚需的各类资源数。Need[i, j]=K，则表示进程i还需要Rj类资源的数目为K。</p>
<p>上述三个矩阵间存在下述关系：<br>Need[i, j] = Max[i, j] - Allocation[i, j]</p>
<p>2) 银行家算法描述</p>
<p>设Requesti是进程Pi的请求矢量，如果Requesti[j]K，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<p>①如果Requesti[j] &lt;= Need[i, j]，便转向步骤②；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p>
<p>②如果Requesti[j] &lt;= Available[j]，便转向步骤③;否则，表示尚无足够资源，Pi须等待。</p>
<p>③系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available[j] = Available[j] - Requesti[j];</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Requesti[ j];</span><br><span class="line">Need[i, j] = Need[i, j] - Requesti[j];</span><br></pre></td></tr></table></figure></p>
<p>④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p>
<p><strong>安全性算法</strong></p>
<p>①设置两个矢量。工作矢量Work；它表示系统可提供给进程继续运行所需的各类资源数目，它含有所个元素，在执行安全算法开始时，Work=Available; Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时 Finish[i]=false；当有足够资源分配给进程 Pi 时，再令 Finish[i]=true。</p>
<p>②从进程集合中找到一个能满足下述条件的进程：Finish[i]=false;    Need[i, j]&lt;=Work[j]; 若找到，执行下一步骤，否则，执行步骤4。</p>
<p>③当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Work[j]=Work[j]+Allocation[i, j];</span><br><span class="line">Finish[i]=true;</span><br><span class="line">go to step &lt;2&gt;;</span><br></pre></td></tr></table></figure></p>
<p>④如果所有进程的Finish[i]=tme都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>
<p><strong>死锁的检测和解除</strong></p>
<p><img src="pictures/资源分配图.png" alt="资源分配图"></p>
<p><strong>死锁定理</strong></p>
<p>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：</p>
<p>1) 在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2-18(a)中，P1是满足这一条件的进程结点，将P1的所有边消去，便得到图248(b)所示的情况。</p>
<p>2) 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2-17中，进程P2就满足这样的条件。根据第1) 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图2-18(c)所示。</p>
<p>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。</p>
<p><img src="pictures/资源分配简化图.png" alt="资源分配简化图"></p>
<p><strong>死锁的解除</strong></p>
<p>一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要方法有：</p>
<p>1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。<br>2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。<br>3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/21/操作系统_处理机的调度与死锁/" data-id="cjuajt8l0000dfcamrbeiypla" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机操作系统" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/计算机操作系统/" class="article-date">
  <time datetime="2019-03-20T06:36:47.541Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h3 id="1-操作系统引论"><a href="#1-操作系统引论" class="headerlink" title="1.操作系统引论"></a>1.操作系统引论</h3><p><strong>操作系统的目标：方便性，有效性，可扩充性和开放性</strong></p>
<p><strong>方便性：1.提高资源利用率 2.提高系统的吞吐量</strong></p>
<p><strong>操作系统的作用：</strong></p>
<ol>
<li>用户与计算机硬件系统之间的接口</li>
<li>计算机系统资源的管理者：处理机，存储器，I/O设备以及文件</li>
<li>实现对计算机资源的抽象</li>
</ol>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>操作系统最核心的概念是进程：这时对正在运行程序的一个抽象，一个进程就是一个正在执行程序的实例，包括程序计数器，寄存器和变量的当前值。</p>
<p><strong>创建进程</strong></p>
<p>有4种主要事件导致进程的创建：</p>
<ol>
<li>系统初始化</li>
<li>执行了正在运行的进程所调用的进程创建系统调用</li>
<li>用户请求创建一个新进程</li>
<li>一个批处理作业的初始化</li>
</ol>
<p>在Unix系统中，只有一个系统可以用来创建进程：fork，这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，这两个进程（父进程和子进程）拥有相同的存储映像，相同的环境字符串和同样的打开文件</p>
<p>在windows中情形正好相反，一个win32函数调用CreateProcess既处理进程的创建，㛑负责把正确的程序装入新的进程</p>
<p>在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其他地址空间中修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中子进程的初始地址空间时父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。但是对于一个新创建的进程而言，确实有可能共享其创建者的其他资源。</p>
<p>在windows操作系统中，从一开始父进程的地址空间和子进程的地址空间就是不同的</p>
<p><strong>进程终止</strong></p>
<ol>
<li><p>正常退出（自愿的）</p>
<p> 当编译器完成所给程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成，在UNIX中该调用是exit，在windows中相关调用是ExitProcess</p>
</li>
<li><p>出错退出（自愿的）</p>
<p>进程发现错误，如编译一个文件，但是文件不存在</p>
</li>
<li><p>严重错误（非自愿的）</p>
<p>   进程引起的错误，通常是由于程序中的错误所致。在有些系统中（如UNXI），进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。</p>
</li>
<li><p>被其他进程杀死（非自愿的）<br>   某个进程执行一个系统调用通知操作系统杀死某个进程，在UNIX中这个系统调用是kill，在win32中对应的函数式TerminateProcess。<br>   在有些系统中，当一个进程终止时，不论是自愿的还是其他原因，由该进程锁创建的所有进程一律被杀死。不过UNIX和Windows都不是这种工作方式。</p>
<p><strong>进程的层次结构</strong></p>
<p>在某些系统中，当一个进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多进程，组成一个进程的层次结构。<br>在UNIX中，进程和它的所有子女进程以及后裔共同组成一个进程组</p>
<p>在UNIX启动时初始化自己。一个称谓init的特殊进程出现在启动映像中。当他开始运行时，读入一个说明终端数量的文件。接着，为每个终端进程创建一个新进程。这些进程等待用户登录。如果一个用户登录成功，该登录进程就执行一个shell准备接受命令。所接受的这些命令会启动更多的进程，依次类推。这样，在整个系统中，所有的进程都属于以init为根的一颗树</p>
<p>在windows中没有进程层次的概念，所有的进程都是低位相同的。</p>
</li>
</ol>
<p><strong>进程的状态</strong></p>
<ol>
<li>运行态（该时刻进程实际占用CPU）</li>
<li>就绪态（可运行，但因为其他进程正在运行而暂时停止）</li>
<li>阻塞态（除非某种外部事件发生，否则进程不能运行）</li>
</ol>
<p><img src="pictures/进程的状态.png" alt="进程的状态"></p>
<p><strong>进程的实现</strong></p>
<p>为了实现进程的模型。操作系统维护着一张表，即进程表。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器，堆栈指针，内存分配状况等</p>
<p><img src="pictures/进程表.png" alt="进程表"></p>
<p><strong>多道程序设计</strong></p>
<p><img src="pictures/多道程序设计.png" alt="多道程序设计"></p>
<h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><p>进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则规则共享系统资源，并能很好地相互合作，从而使程序的执行具有可再线性。</p>
<p><strong>两种形式的制约关系</strong></p>
<ol>
<li>间接制约关系（互斥）</li>
</ol>
<p>当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<ol start="2">
<li>直接制约关系</li>
</ol>
<p>它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p><strong>1.临界资源</strong></p>
<p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>
<p>对于临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可以把临界资源的访问过程分为四个部分：</p>
<ol>
<li>进入区：<br>为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>临界区：进程中访问临界资源的那段代码，又称临界段</li>
<li>退出区：将正在访问临界区的标志清除</li>
<li>剩余区：代码中的其余部分。</li>
</ol>
<p><strong>同步机制遵循的规则</strong></p>
<ol>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
<h5 id="硬件同步方法"><a href="#硬件同步方法" class="headerlink" title="硬件同步方法"></a>硬件同步方法</h5><p><strong>1.中断屏蔽方法</strong></p>
<p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。因为CPU只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。其典型模式为：…关中断;临界区;开中断;…这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。</p>
<p><strong>2.利用Test-and-Set指令实现互斥</strong></p>
<p>这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock=true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用，初值为false。在进程访问临界资源之前，利用TestAndSet检查和修改标志lock；若有进程在临界区，则重复检查，直到进程退出。</p>
<p><strong>3.利用Swap指令实现互斥</strong></p>
<p>每个临界资源设置了一个共享布尔变量lock，初值为false；在每个进程中再设置一个局部布尔变量key，用于与lock交换信息。在进入临界区之前先利用Swap指令交换lock 与key的内容，然后检查key的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。</p>
<p><strong>硬件方法的优点：</strong><br>适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。<br><strong>硬件方法的缺点：</strong><br>进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</p>
<h5 id="信号量机制同步方法"><a href="#信号量机制同步方法" class="headerlink" title="信号量机制同步方法"></a>信号量机制同步方法</h5><p>信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语wait(S)和signal(S)来访问，也可以记为“P操作”（通过）和“V操作（释放）”。原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。如前述的“Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p>
<p><strong>整型信号量</strong></p>
<p>整型信号量被定义为一个用于表示资源数目的整型量S，wait和signal操作可描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    while (S&lt;=0);</span><br><span class="line">    S=S-1;</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;</span><br><span class="line">    S=S+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait操作中，只要信号量S&lt;=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态</p>
<p><strong>记录型信号量</strong></p>
<p>记录型信号量是不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。记录型信号量可描述为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process *L;</span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line">void wait (semaphore S) &#123; //相当于申请资源</span><br><span class="line">    S.value--;</span><br><span class="line">    if(S.value&lt;0) &#123;</span><br><span class="line">        add this process to S.L;</span><br><span class="line">        block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signal (semaphore S) &#123;  //相当于释放资源</span><br><span class="line">    S.value++;</span><br><span class="line">    if(S.value&lt;=0)&#123;</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wait操作，S.value–，表示进程请求一个该类资源，当S.value&lt;0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。</p>
<p>signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value&lt;=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。</p>
<p><strong>利用信号量实现进程互斥</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P1 ( ) &#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S);  // 准备开始访问临界资源，加锁</span><br><span class="line">    // 进程P1的临界区</span><br><span class="line">    V(S);  // 访问结束，解锁</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S); //准备开始访问临界资源，加锁</span><br><span class="line">    // 进程P2的临界区；</span><br><span class="line">    V(S);  // 访问结束，解锁</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥的实现是不同进程对同一信号量进行P、V操作，一个进程在成功地对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行V操作,表示当前没有进程进入临界区，可以让其他进程进入。<br><strong>利用信号量实现同步</strong></p>
<p>信号量机构能用于解决进程间各种同步问题。设S为实现进程P1、P2同步的公共信号量，初值为0。进程P2中的语句y要使用进程P1中语句x的运行结果，所以只有当语句x执行完成之后语句y才可以执行。其实现进程同步的算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = 0;  //初始化信号量</span><br><span class="line">P1 ( ) &#123;</span><br><span class="line">    // …</span><br><span class="line">    x;  //语句x</span><br><span class="line">    V(S);  //告诉进程P2,语句乂已经完成</span><br><span class="line">&#125;</span><br><span class="line">P2()）&#123;</span><br><span class="line">    // …</span><br><span class="line">    P(S) ;  //检查语句x是否运行完成</span><br><span class="line">    y;  // 检查无误，运行y语句</span><br><span class="line">    // …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>管程机制同步方法</strong></p>
<p><strong>管程的出现：</strong><br>每个访问临界资源的进程都需要自备同步操作wait(S)和signal(S)，会使大量的同步操作分散在各个进程中不利于管理，又因为是显示的使用wait(S)和signal(S)，会因为使用不当导致系统死锁。</p>
<p><strong>管程介绍：</strong><br>是一种进程同步工具。简单的说管程临界资源数据结构+一组对临界资源的操作。管程中的数据结构只能被定义于该管程中的操作所访问，管程中的操作只能访问定义于该管程中的数据结构。管程相当于围墙，所有进程访问临界资源时，都必须经过管程中的操作才能访问到，并且每次只允许一个进程进入管程，即是互斥的</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><strong>常见的通信方式</strong></p>
<ol>
<li><p>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，具有固定的读写端，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。<br><img src="pictures/管道通信的示例.png" alt="管道通信的示例"></p>
</li>
<li><p>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信，它以一种特殊设备文件形式存在于文件系统中。</p>
</li>
<li>消息队列：消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li>
</ol>
<p>将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。</p>
<p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</p>
<p>消息队列独立于发送和接收进程。进程终止时，消息队列及其内容并不会被删除</p>
<p>消息队列可以实现信息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取</p>
<ol start="4">
<li>共享存储</li>
</ol>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<ol start="5">
<li>信号量</li>
</ol>
<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<ol start="6">
<li>套接字（Socket）</li>
</ol>
<p>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。是一个通信标识类型的数据结构</p>
<ol start="7">
<li>信号（signal）</li>
</ol>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p><strong>线程与进程的比较</strong></p>
<ol>
<li><p>调度的基本单位：线程是调度和分派的基本单位，是能独立运行的基本单位。线程切换时仅保存和设置少量寄存器的内容，切换代价远低于进程</p>
</li>
<li><p>并发性：引入线程后，不仅进程之间可以并发，一个进程中的多个先后才能之间也可以并发执行，不同进程之间的线程也可以并发执行。</p>
</li>
<li><p>拥有资源：进程可以拥有资源，并作为系统中拥有资源的一个基本单位。线程本身并不拥有系统资源，而是仅有一点必不可少的，能保证独立运行的资源</p>
</li>
<li><p>独立性：同一进程中不同线程之间彼此独立要比不同进程之间的独立性低的多</p>
</li>
<li><p>系统开销：在创建或撤销进程时，系统都要为之分配和回收进程控制块，分配或回收其他资源，线程上下文切换要比线程上下文切换快很多</p>
</li>
<li><p>支持多处理机系统：多线程进程可以将多个线程分配到不同的处理机上</p>
</li>
</ol>
<p>线程的三种状态之间的转换和进程三种状态之间的转换是一样的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/计算机操作系统/" data-id="cjuajt8l2000gfcam9be7oyy8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-lucene" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/lucene/" class="article-date">
  <time datetime="2019-03-19T06:42:59.082Z" itemprop="datePublished">2019-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><h2 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h2><ol>
<li>结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li>非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件</li>
</ol>
<h2 id="非结构化数据查询方法"><a href="#非结构化数据查询方法" class="headerlink" title="非结构化数据查询方法"></a>非结构化数据查询方法</h2><ol>
<li>顺序扫描法</li>
</ol>
<p>所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。</p>
<ol start="2">
<li>全文检索法</li>
</ol>
<p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。</p>
<p><strong>全文检索的应用场景</strong></p>
<p>对于数据量大，数据结构不固定的数据可采用全文检索的方式</p>
<p><img src="pictures/索引与搜索流程图.png" alt="索引"></p>
<p>1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：<br>确定原始内容即要搜索的内容–采集文档–创建文档–分析文档–索引文档</p>
<p>2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：<br>用户通过搜索界面–创建查询–执行搜索，从索引库搜索–渲染搜索结果</p>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。</p>
<p>注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。<br>传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。</p>
<p>倒排索引结构是根据内容（词语）找文档，如下图：</p>
<p><img src="pictures/倒排索引.png" alt="倒排索引"></p>
<h4 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h4><p>查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。</p>
<h4 id="创建查询"><a href="#创建查询" class="headerlink" title="创建查询"></a>创建查询</h4><p>用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，比如：<br>语法 “fileName:spring.txt”表示要搜索Field域的内容为“spring.txt”的文档<br>语法 “lucene AND java” 表示要搜索即包括关键字“lucene”也包括“java”的文档。</p>
<h4 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h4><p>搜索索引过程：<br>1.根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。<br>比如搜索语法为“lucene AND java”表示搜索出的文档中即要包括lucene也要包括java。</p>
<p><img src="pictures/执行查询.png" alt="执行查询"></p>
<h4 id="Lucene查询结构"><a href="#Lucene查询结构" class="headerlink" title="Lucene查询结构"></a>Lucene查询结构</h4><p><img src="pictures/Lucene结构.png" alt="Lucene结构"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/lucene/" data-id="cjuajt7rf0004fcamp8nx3d8u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/15/Redis/" class="article-date">
  <time datetime="2019-03-15T03:16:08.155Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。</p>
<p>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区(buffer)：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。</p>
<p><strong>SDS的定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    //记录buf数组中已使用字节的数量</span><br><span class="line">    unsigned int len;</span><br><span class="line">    //记录buf数组中未使用字节的数量</span><br><span class="line">    unsigned int free;</span><br><span class="line">    //字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SDS遵循C字符串以空字符串结尾的惯例，保存空字符串的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</p>
<p><strong>SDS与C字符串的区别</strong></p>
<ol>
<li>常数复杂度获取字符串长度</li>
</ol>
<p>和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度即为O(1)。</p>
<p>设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。</p>
<p>通过使用SDS而不是C字符串，Redis将获取字符串长度所需的复杂度从O(N)降低到O(1)，这确保了获取字符串长度的工作不会成为Redis的性能瓶颈</p>
<ol start="2">
<li>杜绝缓冲区溢出</li>
</ol>
<p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展到执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p>
<ol start="3">
<li>减少修改字符串时所带来的内存分配次数</li>
</ol>
<p>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</p>
<p>通过未使用空间，SDS实现了空间分配和惰性空间释放两种优化策略。</p>
<p>（1）空间预分配</p>
<p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。</p>
<p>（2）惰性释放</p>
<p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p>
<h3 id="Redis链表为双向链表"><a href="#Redis链表为双向链表" class="headerlink" title="Redis链表为双向链表"></a>Redis链表为双向链表</h3><p> 链表是一种非常常见的数据结构，在Redis中使用非常广泛，列表对象的底层实现之一就是链表。其它如慢查询，发布订阅，监视器等功能也用到了链表。</p>
<p> <strong>双向无环链表</strong></p>
<p><img src="pictures/redis链表.png" alt="redis链表"></p>
<p>Redis使用一个listNode结构来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode</span><br><span class="line">&#123;</span><br><span class="line">    // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure></p>
<p> <strong>list结构</strong></p>
<p> 同时Redis为了方便的操作链表，提供了一个list结构来持有链表</p>
<p><img src="pictures/redis_list结构.png" alt=" redis_list结构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    //表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    //链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void *(*free)(void *ptr);</span><br><span class="line">    //节点值对比函数</span><br><span class="line">    int (*match)(void *ptr,void *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure>
<p><strong>Redis链表结构其主要特性如下:</strong></p>
<p>双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。</p>
<p>无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。</p>
<p>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。</p>
<p>带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。</p>
<p>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。</p>
<p><strong>双向无环链表在Redis中的使用</strong></p>
<p>链表在Redis中的应用非常广泛，列表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。既然列表对象的底层实现之一是链表，那么我们通过一个表格来分析列表对象的常用操作命令。如果分别使用数组、单链表和双向链表实现列表对象的时间复杂度对照如下:</p>
<p><img src="pictures/redis_链表2.png" alt="链表"></p>
<p>我们可以看到在列表对象常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表</p>
<h3 id="Redis字典"><a href="#Redis字典" class="headerlink" title="Redis字典"></a>Redis字典</h3><p><strong>Redis字典的实现</strong></p>
<p>Redis字典使用散列表最为底层实现，一个散列表里面有多个散列表节点，每个散列表节点就保存了字典中的一个键值对。</p>
<p><img src="pictures/redis字典结构.png" alt="redis字典"></p>
<p><strong>字典</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">         //类型特定函数</span><br><span class="line">         void *type;</span><br><span class="line">         //私有数据</span><br><span class="line">         void *privdata;</span><br><span class="line">         //哈希表-见2.1.2</span><br><span class="line">         dictht ht[2];</span><br><span class="line">         //rehash 索引 当rehash不在进行时 值为-1</span><br><span class="line">         int trehashidx;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。</p>
<p>1.type属性是一个指向dictType结构的指针，每个dictType用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
<p>2.privdata属性则保存了需要传给给那些类型特定函数的可选参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictType</span><br><span class="line">&#123;</span><br><span class="line">         //计算哈希值的函数</span><br><span class="line">         unsigned int  (*hashFunction) (const void *key);</span><br><span class="line">         //复制键的函数</span><br><span class="line">         void *(*keyDup) (void *privdata,const void *key);</span><br><span class="line">         //复制值的函数</span><br><span class="line">         void *(*keyDup) (void *privdata,const void *obj);</span><br><span class="line">          //复制值的函数</span><br><span class="line">         void *(*keyCompare) (void *privdata,const void *key1, const void *key2);</span><br><span class="line">         //销毁键的函数</span><br><span class="line">         void (*keyDestructor) (void *privdata, void *key);</span><br><span class="line">         //销毁值的函数</span><br><span class="line">         void (*keyDestructor) (void *privdata, void *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>3.ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下，字典只使用ht[0] 哈希表, ht[1]哈希表只会对ht[0]哈希表进行rehash时使用。</p>
<p>4.rehashidx记录了rehash目前的进度，如果目前没有进行rehash，值为-1。</p>
<p><strong>散列表</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht</span><br><span class="line">&#123;</span><br><span class="line">         //哈希表数组，C语言中，*号是为了表明该变量为指针，有几个* 号就相当于是几级指针，这里是二级指针，理解为指向指针的指针</span><br><span class="line">         dictEntry **table;</span><br><span class="line">         //哈希表大小</span><br><span class="line">         unsigned long size;</span><br><span class="line">         //哈希表大小掩码，用于计算索引值</span><br><span class="line">         unsigned long sizemask;</span><br><span class="line">         //该哈希已有节点的数量</span><br><span class="line">         unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure></p>
<p>1.table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对</p>
<p>2.size属性记录了哈希表的大小，也是table数组的大小</p>
<p>3.used属性则记录哈希表目前已有节点（键值对）的数量</p>
<p>4.sizemask属性的值总是等于size-1（从0开始），这个属性值和哈希表一起决定键应该被放到table数组的哪个索引上面（索引下标值）</p>
<p><strong>散列表节点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//哈希表节点定义dictEntry结构表示，每个dictEntry结构都保存着一个键值对。</span><br><span class="line">typedef struct dictEntry</span><br><span class="line">&#123;</span><br><span class="line">         //键</span><br><span class="line">         void *key;</span><br><span class="line">         //值</span><br><span class="line">         union&#123;</span><br><span class="line">           void *val;</span><br><span class="line">            uint64_tu64;</span><br><span class="line">            int64_ts64;</span><br><span class="line">            &#125;v;</span><br><span class="line">         // 指向下个哈希表节点，形成链表</span><br><span class="line">         struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p>
<p>可以属性保存着键值中的键，而v属性则保存着键值对中的值，其中键值（v属性）可以是一个指针，或unit64_t整数，或int64_t整数。next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决冲突问题。</p>
<p><strong>Redis rehash</strong></p>
<p>随着操作的进行，散列表中保存的键值对也会不断地增加或减少，为了保证负载因子维持在一个合理的范围内，当散列表内的键值对过多或过少时，需要定期进行rehash，以提升性能或节省内存。redis的rehash的步骤如下：<br><img src="pictures/redis_rehash.png" alt="redis_rehash"></p>
<p>1.为字典的ht[1]散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量</p>
<pre><code>（1）扩展操作：ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方幂。
(2)收缩操作：ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂
</code></pre><p><img src="pictures/rehash-1.png" alt="rehash"></p>
<p>2.将保存在ht[0]中的键值对重新计算对重新计算键值的散列值和索引值，然后放大ht[1]指定的位置上。<br><img src="pictures/rehash-2.png" alt="rehash-2"></p>
<p>3.将ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并创建一个新的ht[1]，哈希表为下一次rehash做准备</p>
<p><img src="pictures/rehash-3.png" alt="rehash"></p>
<p><strong>rehash操作需要满足一下条件：</strong></p>
<p>1.服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。</p>
<p>2.服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。</p>
<p>3.当负载因子小于0.1时，程序自动开始执行收缩操作。</p>
<p>Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作</p>
<p><strong>渐进式rehash</strong></p>
<p>对于rehash我们思考一个问题如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。这种情况听着就很耗时，而生产环境中甚至会更大。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。</p>
<p> Redis为了解决这个问题采用渐进式rehash方式。以下是Redis渐进式rehash的详细步骤:</p>
<pre><code>1. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。

2.在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ，表示 rehash 工作正式开始。

3.在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。

4.随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。
</code></pre><p><strong>说明：</strong></p>
<p>1.因为在进行渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。</p>
<ol start="2">
<li>在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 ht[1] 里面，而 ht[0] 则不再进行任何添加操作：这一措施保证了 ht[0] 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。</li>
</ol>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现</p>
<p>和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途</p>
<p><strong>跳跃表的实现</strong></p>
<p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等：</p>
<p><img src="pictures/跳跃表1.png" alt="跳跃表"></p>
<p>上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含一下属性：</p>
<ol>
<li>header：指向跳跃表的表头节点</li>
<li>tail：指向跳跃表的表尾节点</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li>
<li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li>
</ol>
<p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p>
<ol>
<li>层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。</li>
</ol>
<p><strong>跳跃表节点：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* ZSETs use a specialized version of Skiplists */</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;  /*成员对象*/</span><br><span class="line">    double score;   /*分值*/</span><br><span class="line">    struct zskiplistNode *backward; /*后退指针*/</span><br><span class="line">    struct zskiplistLevel &#123; /*层*/</span><br><span class="line">        struct zskiplistNode *forward;  /*前进指针*/</span><br><span class="line">        unsigned int span;  /*跨度*/</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<p>1.分值和成员</p>
<p>节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p>
<p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p>
<p>2.后退指针</p>
<p>节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p>程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，于是访问结束。</p>
<p>3.层</p>
<p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p>
<p>  每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p>
<p>4.前进指针</p>
<p>每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点。<br>下图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径：<br><img src="pictures/跳跃表.png" alt="跳跃表"></p>
<p>  1) 迭代程序首先访问跳跃表的第一个节点(表头)，然后从第四层的前进指针移动到表中的第二个节点。</p>
<p>  2) 在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</p>
<p>  3) 在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。<br>  <br>  4) 当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历</p>
<p>5.跨度</p>
<p>层的跨度(level[i].span属性)用于记录两个节点之间的距离：</p>
<p>1.两个节点之间的跨度越大，它们相距得就越远。</p>
<p>2.指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点</p>
<p>初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis底层使用到的主要数据结构有：简单动态字符串，双端链表，字典，压缩列表，整数集合</p>
<p>Redis并没有直接使用这些数据结构来实现K-value数据库，而是基于这些数据结构创建了一个对象系统。</p>
<p><strong>Redis对象的数据结构</strong></p>
<p>Redis的每一个对象都是由redisObject结构表示，其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * redisObject Redis对象</span><br><span class="line"> */</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    unsigned type : 4; // 类型</span><br><span class="line"></span><br><span class="line">    unsigned encoding : 4; // 编码</span><br><span class="line"></span><br><span class="line">    int refcount; // 引用计数</span><br><span class="line"></span><br><span class="line">    void *ptr; // 指向底层实现数据结构的指针（实际值）</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>1.对象的type属性记录了对象的类型，这个属性的值可以：字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p>
<p>对象的type属性记录了对象的类型，我们可以使用type key指令来查看当前对象的类型：string list  hash  set zset</p>
<p>键值对的键类型一直都是字符串对象。</p>
<p>2.ecoding属性记录了对象所使用的编码，即该对象使用了什么数据结构做为底层实现。</p>
<p><img src="pictures/对象_数据结构.png" alt="对象_数据结构"></p>
<p><img src="pictures/对象_数据结构2.png" alt="对象_数据结构"></p>
<p><strong>字符串对象</strong></p>
<p>redis中字符串对象针对不同的数据可能有三种编码方式：int，raw，embstr。</p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用龙类型来表示</p>
<p>对于长度小于等于39的字符串（3.0之后长度小于等于44），采用embstr编码方式存储。</p>
<p>除以上两种情况外的字符串采用raw编码方式。</p>
<p><strong>列表对象</strong></p>
<p>列表对象的编码可以是ziplist或则linkedlist</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现</p>
<p>linkedlist编码的列表对象使用双端列表作为底层实现</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p>
<p>1.列表对象保存的所有字符串元素的长度都小于64字节</p>
<p>2.列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码</p>
<p>对于使用ziplist编码的列表来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端列表里面，对象编码也会从ziplist变为linkedlist</p>
<p><strong>哈希对象</strong></p>
<p>哈希对象的编码可以是ziplist或则hashtable</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到好戏对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾：</p>
<p>同一键值对总是仅仅的挨在一起。先压入的键值对在列表前面，后压入的键值对在列表的后面</p>
<p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都是用一个字典键值来保存：</p>
<p>1.字典的每个键都是一个字符串对象，对象中保存了键值对的键</p>
<p>2.字典的每一个值都是一个字符串对象，对象中保存了键值对的值</p>
<p>满足一下条件时，哈希对象适应ziplist编码：</p>
<p>1.哈希对象保存的所有键值对的键和值的字符串长度都小于64</p>
<p>2.哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用话说她病了编码</p>
<p><strong>集合对象</strong></p>
<p>集合对象的编码可以使intset或者hashtable</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值全部设置为NULL</p>
<p><strong>编码转换</strong></p>
<p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p>
<p>1.集合对象保存的所有元素都是整数值</p>
<p>2.集合对象保存的元素不操过512</p>
<p>不能满足这两个条件的集合对象需要使用hashtable编码</p>
<p><strong>有序集合对象：</strong></p>
<p>有序集合对象的编码可以使ziplist或者skiplist</p>
<p>ziplist编码的有序集合对象底层使用压缩列表实现，每个集合元素使用两个紧挨在一起压缩列表节点来保存，第一个节点保存元素的成员，而第二个节点保存元素的分值（score）</p>
<p>压缩列表内的集合元素按分值的大小进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。</p>
<p>skiplist编码的有序集合使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">  zskiplist *zsl;</span><br><span class="line">  dict *dict;</span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure></p>
<p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合的元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围操作。</p>
<p>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素:字典的键保存了元素的成员，而字典中的值保存了元素的分值。通过这个字典，程序可以用O(1)复杂度查找给定成员的分值。</p>
<p><strong>为什么有序集合需要同时使用字典和跳跃表来实现？</strong></p>
<p>在理论上，有序集合可以单独使用字典或则跳跃表的其中一种数据结构的实现，无论单独使用字典还是跳跃表，在性能上对比起来同时使用字典和跳跃表都会有所降低</p>
<p>例如只是用字典实现有序集合，虽然已O(1)复杂度查找数据的分值这一特性会被保留，因为字典是无序方式来保存集合元素的，所以在每次执行范围操作时，程序需要多字典保存的元素排序，需要至少O(NlogN)时间复杂度，以及额外的O(N)内存空间为要创建一个数组来保存排序后的元素。</p>
<p>若只用跳跃表实现有序集合，那么执行范围操作时所有有点都会保留，但是没有字典，所以根据成员分值这已操作的复杂度将从O(1)上升为O(logN)</p>
<p><strong>编码转化</strong></p>
<p>当有序集合对象可以同时满足一下两个条件时，对象使用ziplist编码：</p>
<p>1.有序集合保存的元素小于128</p>
<p>2.有序集合保存的所有元素的长度都小于64</p>
<p>不能瞒住以上两个条件的有序集合对象将使用skiplist编码</p>
<p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定命令。</p>
<p><strong>内存回收</strong></p>
<p>因为C语言不具备内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>
<p><strong>对象共享</strong></p>
<p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用，例如：A与B 两个键同时指向一个对象，则对象的引用计数器从之前的1变成2，其他属性没有变化。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>服务器中的数据库</strong></p>
<p>Redis服务器将所有数据库都保存在服务器状态redis将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中：<br>db数组中的每一项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：<br><img src="pictures/redis数据库.png" alt="redis"></p>
<p>程序会根据服务器状态dbnum属性来决定应该创建多少个数据库，dbnum属性的值由服务器配置的database选项决定，默认情况下该值为16</p>
<p><strong>数据库切换</strong></p>
<p>每个redis客户端都有自己的目标数据库，每个redis客户端默认情况下目标数据库为0号数据库，但是客户端可以通过执行select命令来切换目标数据库</p>
<p>在服务器内部，客户端状态RedisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个执行redisDB结构的指针：redisClient.db指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库<br><img src="pictures/redis数据库切换.png" alt="redis数据库切换"></p>
<p><strong>数据库空间</strong></p>
<p>Redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb,其中redisDb中的dictionary字典保存了数据库中的所有键值对，我们将这个字典称为键空间<br>键空间和用户的数据库是直接对应的：</p>
<p>键空间的键也就是数据库的键，每个键都是一个字符串对象</p>
<p>键空间的值也就是数据库的值，，每个值可以使字符串对象，列表对象，哈希对象，集合对象和有序集合对象中的任一种redis对象<br><img src="pictures/键空间.png" alt="键空间"></p>
<p><strong>增删更新查</strong></p>
<p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值为任意一种类型的redis对象</p>
<p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象</p>
<p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p>
<p>对一个数据库键进行取值，实际上就是对键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同</p>
<p><strong>读写键空间时的维护</strong></p>
<ol>
<li>读取一个键（读和写都要），服务器会根据键是否来存在更新服务器的键空间命中次数和不命中次数，可以看keysapce_hists和keyspace_misses属性查看。</li>
<li>读取一个键之后，会更新LRU，用于计算键的闲置时间。</li>
<li>如果读取一个键时发现过期，就会先删除这个过期键。</li>
<li>如果客户端watch命令监视了某个键，那么服务器在堆被监视的键进行修改后，会将这个键标记为脏。</li>
<li>服务器每次修改一个键后，都会对脏键技器值增以，会触发误区七的持久化以及复制操作。</li>
<li>如果服务器开启了数据控通知功能，会触发相应数据库通知。</li>
</ol>
<p><strong>设置键的生存时间或过期时间</strong></p>
<p>通过EXPIRE命令或则PEXPIRE命令，客户端可以以秒或则毫秒精度为数据库中的某个键设置生存时间（TTL），经过指定的秒数或则毫秒数之后，服务器就会自动删除生存时间为0的键</p>
<p><img src="pictures/过期时间.png" alt="过期时间"></p>
<p>无论执行哪个命令最终执行效果都和PEXPIRE命令一样</p>
<p><strong>保存过期时间</strong></p>
<p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典</p>
<p>1.过期字典的键是一个指针，这个指针指向键空间中某个键对象(也即是某个数据库键)</p>
<p>2.过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度UNIX时间戳</p>
<p><strong>移除过期时间</strong></p>
<p>PEXPIREAT命令可以移除一个键的过期时间。</p>
<p>PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联</p>
<p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</p>
<h5 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h5><p>1、定时删除，在设置过期时间时创建一个timer，让定时器在键过期时间来临时，立即执行删除</p>
<p>定是删除策略是最好的，能保证尽快删除，并释放内存。但是对cpu时间是不友好额，如果过期键过多的时候，删除就会影响相应时间。</p>
<p>2、惰性删除，过期后不管，在读取键 检查是否过期的时候再删除</p>
<p>惰性删除对cpu来说是友好的，但是这样会让其所占用内存不释放，如果有些键过期了又永远不删除可以认为是内存泄漏。</p>
<p>3、定期删除：每隔一端时间就进行一次检查，删除里面的过期键。</p>
<p>定期删除的话可以减少时长和频率，以及自定义时间可以在夜晚的时候执行。</p>
<p><strong>Redis的过期键删除策略</strong></p>
<p><strong>惰性删除</strong></p>
<p>过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查</p>
<p><img src="pictures/惰性删除.png" alt="惰性删除"></p>
<p><strong>定期删除策略</strong></p>
<p>过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并且删除其中的过期键。</p>
<p><img src="pictures/定期删除策略.png" alt="定期删除策略‘"></p>
<p><strong>AOF，RDB和复制功能对过期键的处理</strong></p>
<p><strong>1.生成RDB文件</strong></p>
<p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库键进行检查，过期的键不会保存到新创建的RDB文件中。</p>
<p>在启动redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>
<p>1、如果服务器以主服务器模式运行，那么载入的时候就会检查是否过期。</p>
<p>2、如果以服务器模式运行，那么所有键都会被载入。</p>
<p>因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</p>
<p><strong>AOF文件写入</strong></p>
<p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或定期删除，那么AOF文件不会因为这个过期键而产生影响。</p>
<p>当过期键被被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令来显式记录该键已经删除</p>
<p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p>
<p><strong>复制</strong></p>
<p>当服务器运行在复制模式下时，从服务器过期键删除动作由主服务器控制。</p>
<p>1、主服务器会删除一个过期键之后会向slave发送一个DEL命令。</p>
<p>2、从服务器在执行客户端发送命令时，即使碰到过期键也不会将过期键删除</p>
<p>3、从服务器只有接到DEL命令之后才会删除过期键。</p>
<p><img src="pictures/复制过期策略.png" alt="复制过期策略"></p>
<p><strong>数据库通知</strong></p>
<p><img src="pictures/通知.png" alt="通知"></p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>redis持久化即可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。</p>
<p><img src="pictures/RDB持久化.png" alt="RDB持久化"></p>
<p><strong>RDB文件的创建与载入</strong></p>
<p>有两个redis命令可以用于生成RDB文件，一个是save，另一个BGSAVE。SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令，和SAVE命令直接阻塞不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p>
<p>RDB文件的载入工作是服务器启动时自动执行的，所以Redis并没有专门载入RDB文件的命令，只要服务器启动时检测到RDB文件存在，它就会自动载入RDB文件</p>
<p><img src="pictures/RDB持久化文件.png" alt="RDB持久化"></p>
<p><strong>BGSAVE命令执行时服务器状态</strong></p>
<p>BGSAVE命令执行期间，客户端发送的BGSAVE命令和SAVE命令都会被服务器拒绝，避免同时调用rdbSave，产生竟态条件。</p>
<p><img src="pictures/Bgsave4.png" alt="Bgavee"></p>
<p><strong>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</strong></p>
<p><strong>自动间隔性保存</strong></p>
<p>redis允许用户可以设置服务器配置的save选项，让服务器每隔一段时间执行一次BGSAVE名利，用户可以通过设置save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p>
<p><img src="pictures/自动保存.png" alt="自动保存"></p>
<p>服务器程序会根据save选项设置的保存条件，设置服务器状态redisServer结构的saveparams属性：<br>saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：<br><img src="pictures/save选项.png" alt="save选项"></p>
<p>除了saveparams数组外，服务器还维持着一个dirty计数器，以及一个lastsave属性：</p>
<p>dirty计数器记录了距离上一次成功执行save命令或者bgsave命令之后，服务器对数据库状态进行了多少次修改（写入、删除、更新等操作）。<br>lastSave属性是一个unix时间戳记录上次成功执行RDB持久化的时间。</p>
<p><strong>redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否满足，满足的话就执行BGSAVE命令</strong></p>
<p><strong>RDB文件结构</strong></p>
<p><img src="pictures/RDB文件结构.png" alt="RDB文件结构"></p>
<p>REDIS部分长度为5个字节，通过这五个字节可以快速检查所载入的文件是否是RDB文件</p>
<p>db_version长度为4字节，记录了RDB文件的版本号</p>
<p><img src="pictures/datebase.png" alt="datebase"></p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p><img src="pictures/AOF.png" alt="AOF写命令"></p>
<p>AOF保存的是服务器执行的写命令</p>
<p><strong>AOF持久化的实现</strong></p>
<p>AOF持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤：</p>
<p><strong>命令追加</strong></p>
<p>当AOF持久化功能出于打开状态时，服务器执行完一个写命令之后，会以被执行的写命令追加到服务器的aof_buf缓冲区的末尾</p>
<p><strong>AOF文件的写入与同步</strong></p>
<p>Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求以及向客户端发送命令回复。</p>
<p>每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将缓冲区的内容写入和保存到AOF文件里面。</p>
<p><img src="pictures/AOF文件同步.png" alt="AOF文件同步"></p>
<p><img src="pictures/AOF效率和安全性1.png" alt="AOF"><br><img src="pictures/AOF效率与安全性2.png" alt="AOF">   </p>
<p><strong>AOF文件的载入与数据的还原</strong></p>
<p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令。就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="pictures/AOF文件载入与数据还原.png" alt="文件载入与数据还原"></p>
<p><strong>AOF重写</strong></p>
<p>AOF文件中的内容越多，文件的体积也会越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器，甚至整个计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能。通过该功能，redis服务器可以创建一个新的AOF文件来代替现有的AOF文件，新旧两个AOF文件保存的数据库状态相同，但新的AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件所能保存的体积通常会比旧AOF文件的体积要小的多。</p>
<p><strong>AOF文件重写的实现</strong></p>
<p>AOF文件重写并不需要对现有的AOF文件进行任何读取，分析或写入操作，这个功能是通过读取服务器当前的数据库状态来实现的</p>
<p><img src="pictures/AOF文件重写.png" alt="AOF文件重写"></p>
<p>其他所有类型的键都可以以同样的方式去减少AOF文件中命令的数量</p>
<p><img src="pictures/AOF重写文件1.png" alt="AOF重写文件1"></p>
<p><strong>AOF后台重写</strong></p>
<p><img src="pictures/AOF后台重写.png" alt="AOF后台重写"></p>
<p>这样一来：<br>（1）AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行</p>
<p>（2）从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写的缓冲区里面</p>
<p>当子进程完成AOF重写后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：<br>（1）将AOF重写缓冲区中的所有内容写入到新的AOF文件中，这时新的AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</p>
<p>（2）对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p>
<p>整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到最低。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><img src="pictures/文件事件.png" alt="文件事件处理器"><br><img src="pictures/文件事件处理器.png" alt="文件事件处理器"></p>
<p><strong>文件事件处理器</strong></p>
<p>Redis为文件事件编写多个处理器，这些事件处理器分别用于实现不同的网络通信需求</p>
<p><img src="pictures/Q文件事件处理器.png" alt="文件事件处理器"></p>
<p><strong>时间事件</strong></p>
<p>定时时间：指定时间后执行一次</p>
<p>周期性时间：每个指定时间就执行一次</p>
<p><img src="pictures/事件事件属性.png" alt="时间事件属性"></p>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="pictures/事件调度.png" alt="时间调度"></p>
<p><img src="pictures/事件调度原则.png" alt="事件调度原则"></p>
<p>因为时间事件在文件事件之后执行，并且时间之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间少晚一些。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向每个客户端返回命令回复。</p>
<p>通过使用IO多路复用技术实现的文件事件处理器，redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信</p>
<p>redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的额客户端的状态结构。<br><img src="pictures/Clients.png" alt="Clients"></p>
<h3 id="15-复制"><a href="#15-复制" class="headerlink" title="15 复制"></a>15 复制</h3><p><img src="pictures/服务器-复制.png" alt="服务器-复制"></p>
<p>进行主从复制的服务器双方保存相同的数据库，向主服务器中插入数据，可以在从服务器中查找到</p>
<p><strong>旧版复制功能的实现</strong></p>
<p>Redis的复制功能分为sync同步和command propagate命令传播两个操作。<br>同步：同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。<br>命令传播操作：用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</p>
<p><strong>同步</strong></p>
<p>1、发送sync<br>2、接受sync并开启bgsvae命令，缓冲区记录所有写命令<br>3、bgsave完成后发送rdb文件，接受rdb后倒入并执行缓冲区命令。</p>
<p><img src="pictures/复制_同步.png" alt="复制_tongbu"></p>
<p>命令传播：</p>
<p>主服务器将自己的执行的命令，发送给从服务器，让主从服务器再一次回到一致状态</p>
<p><strong>旧版复制的缺点</strong></p>
<p>在Redis中，从服务器对主服务器的复制可以分为以下几种情况：<br>1、初次复制<br>2、断线后复制（效率极低）</p>
<p><img src="pictures/旧版复制的缺点.png" alt="旧版复制的缺点"></p>
<p><strong>新版复制功能的实现</strong></p>
<p>PSYNC命令代替SYNC命令，新命令有完整同步和部分重同步</p>
<p>完整同步用于处理  初次复制</p>
<p>部分同步用于处理  断线后同步   如果条件允许只将断线后的写命令发送给从服务器，保持主从一致。</p>
<p><strong>部分同步的实现</strong></p>
<p>主要由三个部分构成：<br>1、主服务器的复制偏移量和从服务器的复制偏移量（replication offset）<br>2、主服务器的复制积压缓冲区<br>3、服务器的运行</p>
<p><strong>复制偏移量</strong><br>执行的复制双方会维护一个复制偏移量，主发送N个字节，就加上N，从接送就接受N</p>
<p><img src="pictures/断线不一致.png" alt="不一致"></p>
<p>此时就执行部分同步</p>
<p><strong>复制积压缓冲区</strong></p>
<p><img src="pictures/复制积压缓冲区.png" alt="缓冲区"></p>
<p><strong>服务器ID</strong></p>
<p>每个服务都有自己的ID，保证断线丛连后，所连接到的主服务器与原来一致。</p>
<h3 id="16-Sentinel"><a href="#16-Sentinel" class="headerlink" title="16 Sentinel"></a>16 Sentinel</h3><p>Sentinel（哨兵）是redis的高可用性的解决方案：Sentinel 组成的sentinel系统可以监视任意多个主服务器以及主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，继续处理请求。</p>
<p><img src="pictures/故障转移.png" alt="故障转移"></p>
<p><strong>启动初始化服务器</strong></p>
<p>启动一个Sentinel时，需要执行以下步骤：<br>1、初始化服务器<br>2、将普通Redis服务器使用的状态代码换成Sentinel专用代码<br>3、初始化Sentinel状态<br>4、根据给定的配置文件，初始化Sentinel的监视主服务器列表<br>5、创建连接主服务器的网络连接</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/15/Redis/" data-id="cjuajt99c000nfcam30nqfw8u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常见排序算法总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/14/常见排序算法总结/" class="article-date">
  <time datetime="2019-03-14T11:00:53.337Z" itemprop="datePublished">2019-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常见算法排序总结"><a href="#常见算法排序总结" class="headerlink" title="常见算法排序总结"></a>常见算法排序总结</h1><p><strong>排序的定义</strong><br>对一序列对象根据某个关键字进行排序</p>
<p><strong>术语说明</strong></p>
<p><strong>稳定：</strong><br>如果a原本在b前面，而a=b，排序之后a仍然在b的前面</p>
<p><strong>不稳定：</strong><br>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面</p>
<p><strong>内排序：</strong><br>所有排序操作都在内存中完成</p>
<p><strong>外排序：</strong><br>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的额数据传输才能进行</p>
<p><strong>时间复杂度：</strong><br>一个算法执行所耗费的时间</p>
<p><strong>空间复杂度：</strong><br>运行完一个程序所需内存的大小</p>
<p><strong>算法总结</strong></p>
<p><img src="pictures/算法总结.png" alt="排序算法总结"></p>
<p><strong>n:数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存  Out-place：占用二外内存</strong></p>
<p><strong>算法分类：</strong></p>
<p><img src="pictures/排序算法分类.png" alt="排序算法分类"></p>
<h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把他们交换过来。走访数列的工作时重复地进行直到没有在需要交换，也就是说该数列已经排序完成。每次循环都会把遍历得到的最大的元素放到数组的后面。</p>
<p><strong>算法描述</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；<br><img src="pictures/冒泡排序.gif" alt="冒泡排序"><img src="pictures/冒泡代码.jpg" alt="冒泡"></li>
</ol>
<p><strong>算法分析：</strong><br>最佳情况：数组已排好序，只需进行n-1比较，时间复杂度T(n)=O(n)</p>
<p>最差情况：数组已经排好序，但是是反序的，需要进行n-1比较，n-1次交换，时间复杂度：T(n)=O(n2)</p>
<p>平均情况：T(n)=O(n2)</p>
<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处就是不占用额外的内存空间</p>
<p>选择排序：首先在未排序序列序列中找到最大（小）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最大（小）元素，然后放到已排好序列的末尾。依次类推，直到所有元素均排序完毕。</p>
<p><strong>2.1 算法描述</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。</p>
<p>初始状态：无序化为R[1..n],有序区为空</p>
<p>第i趟排序（i=1,2,3….n-1）,当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区的第一个记录R交换，使R[1..i]和R[i+1…n]分别变为记录个数增加1个的新的有序区和记录个数减少1个的新无序区。</p>
<p>n-1趟结束，数组有序化了。</p>
<p><strong>动图演示</strong><br><img src="pictures/选择排序.gif" alt="选择排序"><br><img src="pictures/选择代码.jpg" alt="选择代码"></p>
<p><strong>算法分析</strong></p>
<p>最佳情况：已经排好序，但仍然要进行n2次级别的比较  时间复杂度T(n)=O(n2)</p>
<p>最差情况：也已经排好序，但是是反序的，所以也要进行n2次级别的比较，还有n-1次交换，市价复杂度T(n)=O<br>(n2)</p>
<p>平均情况：T(n)=O(n2)</p>
<h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h3><p>插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需要用到O(1)的额外空间排序），吟哦在从后向前排序扫描过程中，需要反复把已排好序的元素逐步向后移位，为最新元素提供插入空间。</p>
<p><strong>算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现，具体算法描述如下：</p>
<p>从第一个元素开始，该元素可以认为已经被排序；</p>
<p>取出下一个元素，在已经排序好的元素序列中从后向前扫描；如果该元素（已排好）大于新元素，将该元素移到下一位置；</p>
<p>重复步骤3，直到找到已排序的元素小于或则等于新元素的位置；</p>
<p>将新元素插入到该位置后；重复步骤2-5</p>
<p><img src="pictures/插入排序.gif" alt="插入排序"><br><img src="pictures/插入代码.jpg" alt="插入代码"></p>
<p><strong>算法分析：</strong></p>
<p>最佳情况：已经排好序，只需要进行n-1比较  时间复杂度 T(n)=O(n)</p>
<p>最坏情况：已经排好序但是是倒序          时间复杂度  T(n)=O(n2)</p>
<p>平均情况： 时间复杂度  T(n)=O(n2)</p>
<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h3><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，同时该算法是冲破O(n2)的第一批算法之一，它与插入排序的不同之处在于，它会优先比较距离较远的元素</p>
<p>希尔排序是把记录按表的一定增量分组，对每组使用插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法边终止。</p>
<p><strong>算法描述</strong></p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
<p>按增量序列个数k，对序列进行k 趟排序；</p>
<p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p><img src="pictures/希尔排序.jpg" alt="希尔排序"><br><img src="pictures/希尔代码.jpg" alt="希尔排序"></p>
<p><strong>算法分析：</strong></p>
<p>最佳情况：T(n)=O(nlogn)</p>
<p>最坏情况：T(n)=O(nlogn)</p>
<p>平均情况：T(n)=O(nlogn)</p>
<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn)的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法采用分治法的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，在使两个子序列间有序。若将两个有序表合并成一个有序表，称为2-路归并</p>
<p><strong>算法描述</strong></p>
<p>将长度为n的输入序列分成两个长度为n/2的子序列</p>
<p>对这两个子序列分别采用归并排序</p>
<p>将两个排序好的子序列合并成一个最终的排序序列</p>
<p><img src="pictures/归并排序.gif" alt="归并排序"><br><img src="pictures/归并代码.jpg" alt="归并代码"></p>
<p><strong>算法分析</strong></p>
<p>最佳情况： 所有都是排好序的，只需要进行n-1次比较    T(n)=O(n)</p>
<p>最差情况：  T(n)=O(nlogn)</p>
<p>平均情况：  T(n)=O(nlogn)</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分继续进行排序，以达到整个序列有序。</p>
<p><strong>算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot）；</p>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p><img src="pictures/快排.gif" alt="快排"><br><img src="pictures/快排1.jpg" alt="快排1"><br><img src="pictures/快排2.jpg" alt="快排2"></p>
<p><strong>算法分析：</strong><br>最佳情况： T(n)=O(nlogn)</p>
<p>最差情况：T(n)=O(n2)</p>
<p>平均：T(n)=O(nlogn)</p>
<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时瞒住堆积的性质：即子节点的键值或索引总是小于（或则大于）它的父节点</p>
<p><strong>算法描述</strong></p>
<p>将初始待排序关键字序列（R1，R2。。。。Rn）构建成大顶堆，此堆为初始无序区；</p>
<p>将堆顶元素R1与最后一个元素Rn交换，，此时得到新的无序区（R1，R2，R3…..Rn-1）和新的有序区（Rn），且满足R[1,2….n-1]&lt;=Rn;</p>
<p>由于交换后新的堆顶R1可能违反堆的性质，因此需要对当前无序区（R1，R2….Rn-1）调整为新堆，然后再次将R1与无序区最后一个元素交换，得到新的无序区(R1，R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
<p><img src="pictures/堆排序1.gif" alt="堆排序"><br><img src="pictures/堆排序2.gif" alt="堆排序"></p>
<p><img src="pictures/堆排序代码1.jpg" alt="堆排序代码1"><br><img src="pictures/堆排序代码2.jpg" alt="堆排序代码2"></p>
<p><strong>算法分析</strong><br>最佳情况：T(n)=O(nlogn)</p>
<p>最差情况：T(n)=O(nlogn)</p>
<p>平均情况：T(n)=O(nlogn)</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的证书。</p>
<p>计数排序是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排数组A中值等于i的元素的个数。然后根据数组C来讲A中的元素排到正确的位置。它只能对整数进行排序。</p>
<p><strong>算法描述</strong></p>
<p>找出待排序的数组中最大和最小的元素；</p>
<p>统计数组中每个值i的元素出现的次数，存储数组C的第i项；</p>
<p>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</p>
<p>反向填充目标数组：将每个元素i放在放在新数组的第C(i),每放 一个元素就将C(i)减去1</p>
<p><img src="pictures/计数排序.gif" alt="计数排序"><br><img src="pictures/计数排序代码.jpg" alt="计数排序"></p>
<p><strong>算法分析</strong></p>
<p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k)  最差情况：T(n) = O(n+k)  平均情况：T(n) = O(n+k)</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序的工作原理： 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶里再分别排序（有可能再使用别的排序算法或则是以递归方式继续使用桶排序）</p>
<p><strong>算法描述：</strong><br>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放{1,2,3,4,5}这几种数字，但是容量不限，即可以存放100个3）；</p>
<p>遍历输入数据，并且把数据一个一个放到对应的桶里去；</p>
<p>对每个不同的桶进行排序，可以使用其他的办法，也可以使用桶排序；</p>
<p>从不是空的桶里把排序好的数据拼接起来。</p>
<p><img src="pictures/桶排序1.jpg" alt="桶排序1"><br><img src="pictures/桶排序2.png" alt="桶排序2"></p>
<p><strong>代码：</strong></p>
<p><img src="pictures/桶排序代码1.jpg" alt="桶排序"><br><img src="pictures/桶排序代码2.jpg" alt="桶排序"></p>
<p><strong>算法分析：</strong><br>桶排序最好情况下使用线性时间O(n),桶排序的时间复杂度取决于各个桶之间进行排序的时间复杂度，因为其他部分的时间复杂度都为O(n).很显然，桶划分越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<p>最佳情况： T(n)=O(n+k)</p>
<p>最差情况：T(n)=O(n+k)</p>
<p>平均情况：T(n)=O(n2)</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(nk)，n为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有些时候有些属性是有优先级顺序的，先按低位优先级排序，再按高位优先级排序。最后的次序就是高优先级的在前，高优先级相同的低优先级高的在前。计数排序基于分别排序，分别收集，所以是稳定的</p>
<p><strong>算法描述：</strong></p>
<p>取得数组中的最大数，并取得位数；</p>
<p>arr为原始数组，从最低位开始取每个位组成radix数组；</p>
<p>对radix进行计数排序（利用计数排序使用与小范围的特点）</p>
<p><img src="pictures/基数排序.gif" alt="基数排序"><br><img src="pictures/基数排序代码.jpg" alt="基数排序代码"></p>
<p><strong>算法分析</strong></p>
<p>最佳情况： T(n)=O(n<em>k)  最差情况： T(n)=O(n</em>k)  平均情况： T(n)=O(n*k)</p>
<p>基数排序有两种方法：<br>MSD从高位开始进行排序LSD从低位开始进行排序</p>
<p>基数排序 vs 计数排序 vs桶排序</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<p>基数排序：根据键值的每位数字分配桶</p>
<p>基数排序：每个桶只存储单一键值</p>
<p>桶排序：每个桶存储一定范围的数值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/14/常见排序算法总结/" data-id="cjuajt844000afcamt3ty3mey" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql索引" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/mysql索引/" class="article-date">
  <time datetime="2019-03-13T14:21:51.604Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Mysql索引类型及创建"><a href="#Mysql索引类型及创建" class="headerlink" title="Mysql索引类型及创建"></a>Mysql索引类型及创建</h1><p>索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</p>
<h2 id="Mysql索引的类型"><a href="#Mysql索引的类型" class="headerlink" title="Mysql索引的类型"></a>Mysql索引的类型</h2><h3 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h3><p>这是最基本的索引，它没有任何限制.</p>
<p><strong>直接创建索引</strong></p>
<ol>
<li>ALTER TABLE</li>
</ol>
<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list)</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE (column_list)</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_list)</span><br></pre></td></tr></table></figure></p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<ol start="2">
<li>CREATE INDEX</li>
</ol>
<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br></pre></td></tr></table></figure></p>
<p>table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引</p>
<p>索引类型：</p>
<p>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。<br>PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p>
<ol start="3">
<li>创建表时直接创建索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `table` (</span><br><span class="line"></span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line"></span><br><span class="line">`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line"></span><br><span class="line">`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line"></span><br><span class="line">`time` int(10) NULL DEFAULT NULL ,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">INDEX index_name (title(length))</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">删除索引</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>
<p><strong>唯一索引</strong><br>与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">–创建唯一索引</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX indexName ON table(column(length))</span><br><span class="line"></span><br><span class="line">–修改表结构</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))</span><br><span class="line"></span><br><span class="line">–创建表的时候直接指定</span><br><span class="line"></span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line"></span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line"></span><br><span class="line">`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line"></span><br><span class="line">`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line"></span><br><span class="line">`time` int(10) NULL DEFAULT NULL ,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">UNIQUE indexName (title(length))</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>删除索引</strong></p>
<p>可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON talbe_name</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name</span><br><span class="line">ALTER TABLE table_name DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>
<p>其中，前两条语句是等价的，删除掉table_name中的索引index_name。<br>第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。<br>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<p><strong>全文索引（FULLTEXT）</strong></p>
<p>FULLTEXT索引仅可用于MyISAM表；他们可以从CHAR，VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE或CREATE INDEX被添加。对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成一个全文索引时一个非常消耗时间非常消耗硬盘空间的做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">–创建表的适合添加全文索引</span><br><span class="line"></span><br><span class="line">CREATE TABLE `table` (</span><br><span class="line"></span><br><span class="line">`id` int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line"></span><br><span class="line">`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,</span><br><span class="line"></span><br><span class="line">`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,</span><br><span class="line"></span><br><span class="line">`time` int(10) NULL DEFAULT NULL ,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">FULLTEXT (content)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">–修改表结构添加全文索引</span><br><span class="line"></span><br><span class="line">ALTER TABLE article ADD FULLTEXT index_content(content)</span><br><span class="line"></span><br><span class="line">–直接创建索引</span><br><span class="line"></span><br><span class="line">CREATE FULLTEXT INDEX index_content ON article(content)</span><br></pre></td></tr></table></figure></p>
<p><strong>单列索引</strong></p>
<p>多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。<br><strong>组合索引（最左前缀）</strong></p>
<p>平时用的sql查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引，例如针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">–title,time</span><br><span class="line">–title</span><br></pre></td></tr></table></figure></p>
<p>为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">–使用到上面的索引</span><br><span class="line"></span><br><span class="line">SELECT * FROM article WHREE title=&apos;测试&apos; AND time=1234567890;</span><br><span class="line"></span><br><span class="line">SELECT * FROM article WHREE utitle=&apos;测试&apos;;</span><br><span class="line"></span><br><span class="line">–不使用上面的索引</span><br><span class="line"></span><br><span class="line">SELECT * FROM article WHREE time=1234567890;</span><br></pre></td></tr></table></figure>
<p>mysql索引的优化：</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。下面是一些总结以及收藏的MySQL索引的注意事项和优化方法。</p>
<h2 id="什么是索引？为什么要建立索引？"><a href="#什么是索引？为什么要建立索引？" class="headerlink" title="什么是索引？为什么要建立索引？"></a>什么是索引？为什么要建立索引？</h2><p>索引用于快速找出某一列中有一特定值的行，不使用索引，MYSQL必须从第一条记录开始读完整个表，直到找到相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间</p>
<p>例如：有一张person表，其中有2W条记录，记录着2W个人的信息。有一个Phone的字段记录每个人的电话号码，现在想要查询出电话号码为xxxx的人的信息。</p>
<p>如果没有索引，那么将从表中第一条记录一条条往下遍历，直到找到该条信息为止。</p>
<p>如果有了索引，那么会将该Phone字段，通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，而不必在遍历2W条数据了。其中MySQL中的索引的存储类型有两种：BTREE、HASH。 也就是用树或者Hash值来存储该字段，要知道其中详细是如何查找的，就需要会算法的知识了。我们现在只需要知道索引的作用，功能是什么就行。</p>
<h2 id="MYSQL中索引的优点和缺点和使用原则"><a href="#MYSQL中索引的优点和缺点和使用原则" class="headerlink" title="MYSQL中索引的优点和缺点和使用原则"></a>MYSQL中索引的优点和缺点和使用原则</h2><p><strong>优点：</strong></p>
<ol>
<li>所有的MySql列类型（字段类型）都可以被索引，也就是给任意字段设置索引</li>
<li>大大加快数据的查询速度</li>
</ol>
<p><strong>缺点：</strong></p>
<p>1.创建索引和维护索引要耗费时间，并且随着数据量的增加锁耗费的时间也会增加</p>
<p>2.索引页需要占空间，我们知道数据表中的数据也会有最大上线设置，如果我们有大量的索引，索引文件可能会比数据文件更快达到上限值</p>
<p>3.当对表中的数据进行增加，删除，修改时，索引也需要动态维护，降低了数据的维护速度</p>
<p><strong>使用原则：</strong></p>
<p>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段设置索引就好，也不是索引越多越好，而是需要自己合理的使用</p>
<p>1.对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引</p>
<p>2.数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果</p>
<p>3.在不同直少的列（字段上）不要建立索引，比如在学生的“性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可建立索引</p>
<p><strong>索引的分类</strong></p>
<p><strong>注意：</strong><br>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。</p>
<p>MyISAM和In弄DB存储引擎：只支持BTREE索引，也就是说默认使用BTREE，不能够更换</p>
<p>MEMORY和HEAP存储引擎：支持HASH和BTREE索引</p>
<p>1、索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、</p>
<p>1.1、单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。</p>
<p>1.1.1、普通索引：</p>
<p>　　　　　　　　　　　MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p>
<p>1.1.2、唯一索引：</p>
<p>　　　　　　　　　索引列中的值必须是唯一的，但是允许为空值，</p>
<p>1.1.3、主键索引：</p>
<p>　　　是一种特殊的唯一索引，不允许有空值。</p>
<p>1.2、组合索引</p>
<p>　　　　在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说　</p>
<p>1.3、全文索引</p>
<p>　　　　全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个大煞笔，二货 …” 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。</p>
<p>1.4、空间索引</p>
<p>　　　空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。</p>
<p>　　　在创建空间索引时，使用SPATIAL关键字。</p>
<p>　　　要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。具体细节看下面　</p>
<h2 id="MySQL索引详解与索引优化"><a href="#MySQL索引详解与索引优化" class="headerlink" title="MySQL索引详解与索引优化"></a>MySQL索引详解与索引优化</h2><h3 id="一-BTree索引"><a href="#一-BTree索引" class="headerlink" title="一.BTree索引"></a>一.BTree索引</h3><p> MySQL数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引</p>
<p> <strong>存储结构</strong></p>
<p> 这类索引的物理文件大多就是以BTree结构来存储的，但是会有不同的存储引擎在使用BTree索引时，对存储结构稍作修改，比如MyISAM存储引擎，使用B+Tree的数据结构，它相对与BTree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成一条数据链表，以加快相邻数据的检索效率。</p>
<p> 另外，对于In弄DB存储引擎，虽然同样使用B+Tree作为索引的存储结构，但具体实现却与MyISAM截然不同。</p>
<p> （1）MyISAM引擎索引结构的叶子结点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，这样的索引称为“非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字</p>
<p> 如下图所示为非聚簇索引的主键索引：<br><img src="pictures/非聚簇主键索引.png" alt=" 非聚簇主键索引"></p>
<p>其检索算法：先按照B+Tree的检索算法检索，找到指定关键字，则取出对应数据域的值，作为地址取出数据记录</p>
<p>（2）In弄DB引擎索引结构的叶子节点数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应的数据行）。或者说，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</p>
<p><img src="pictures/聚簇索引.png" alt="聚簇索引"></p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><strong>1、概述及存储结构</strong></p>
<p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p><strong>2、Hash索引的弊端</strong></p>
<p>一般来说，索引的检索效率非常高，可以一次定位，不像B-Tree索引需要进行从根节点到叶节点的多次IO操作。有利必有弊，Hash算法在索引的应用也有很多弊端。</p>
<p>a、Hash索引仅仅能满足等值的查询，范围查询不保证结果正确。因为数据在经过Hash算法后，其大小关系就可能发生变化。</p>
<p>b、Hash索引不能被排序。同样是因为数据经过Hash算法后，大小关系就可能发生变化，排序是没有意义的。</p>
<p>c、Hash索引不能避免表数据的扫描。因为发生Hash碰撞时，仅仅比较Hash值是不够的，需要比较实际的值以判定是否符合要求。</p>
<p>d、Hash索引在发生大量Hash值相同的情况时性能不一定比B-Tree索引高。因为碰撞情况会导致多次的表数据的扫描，造成整体性能的低下，可以通过采用合适的Hash算法一定程度解决这个问题。</p>
<p>e、Hash索引不能使用部分索引键查询。因为当使用组合索引情况时，是把多个数据库列数据合并后再计算Hash值，所以对单独列数据计算Hash值是没有意义的。</p>
<p><strong>Full-Text索引</strong></p>
<p><strong>1.概述</strong></p>
<p>全文索引，目前MySQL中只有MyISAM存储引擎支持，并且只有CHAR、VARCHAR、TEXT类型支持。它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</p>
<p><strong>2.存储结构</strong></p>
<p>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</p>
<p><img src="pictures/主存存取原理.png" alt="主存存取原理"></p>
<h3 id="一-MyISAM存储引擎（MySQL默认的存储引擎）"><a href="#一-MyISAM存储引擎（MySQL默认的存储引擎）" class="headerlink" title="一.MyISAM存储引擎（MySQL默认的存储引擎）"></a>一.MyISAM存储引擎（MySQL默认的存储引擎）</h3><p><strong>1、物理文件结构</strong></p>
<p>每一个表在MyISAM存储引擎中都以三个以表名命名的物理文件构成。</p>
<p>(1)任何存储引擎都不可或缺的存放表结构定义的.frm（Form）文件</p>
<p>(2)存放表数据的.MYD文件（My Data）</p>
<p>(3)存放索引数据的.MYI文件（My Index）</p>
<p><strong>2.支持的索引类型</strong></p>
<p>（1）BTree索引</p>
<p>（2）R-Tree索引</p>
<p>（3）Full-Text索引</p>
<p><strong>3.锁机制-支持表级锁定</strong></p>
<p>4、事务处理——为保证效率，不支持事务处理</p>
<p>5、增删改查性能——SELECT性能较高，适合执行查询较多的情况使用</p>
<p>6、COUNT(<em>)问题——MyISAM存储引擎记录表行数，所以在使用COUNT(</em>)时，只需取出存储的行数，而不用遍历表，效率较高</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p><strong>1.物理文件结构</strong></p>
<p>(1)同MyISAM一样的是，InnoDB存储引擎也有.frm文件存储表结构定义</p>
<p>(2)与MyISAM不同的是，InnoDB的表数据与索引数据是存储在一起的，但在这个文件中每张表是独自占有一块表空间还是共享所有表空间，是由用户决定的。如果独享表空间，每个表的表数据与索引数据都会存放在一个.ibd(innoDB data)文件中；如果是共享表空间，通过innodb_data_file_path指定后，每次增加数据文件后必须停机重启才能生效，很不方便。</p>
<p>(3)InnoDB有支持事务及安全的日志文件，这个文件非常重要，InnoDB可以通过日志文件将数据库崩溃时已经完成但还没来得及将内存中已经修改但未完全写入磁盘的数据写入磁盘，也可以把已部分完成并写入磁盘的未完成事务回滚，保证数据一致性。如果错误删除日志文件会导致数据库崩溃且无法启动。</p>
<p><strong>2、支持的索引类型</strong></p>
<p>与MyISAM基本一致，但具体实现因为文件结构的不同有很大差异，具体差异参看上述博客。</p>
<p><strong>3、锁机制的改进</strong></p>
<p>实现了行级锁，为承受高并发增加了竞争力。</p>
<p><strong>4、事务处理</strong></p>
<p>实现了事务处理，可谓与MyISAM最重要的区别之一。</p>
<p><strong>5、增删改查性能</strong></p>
<p>如果执行大量的增删改操作，推荐使用InnoDB存储引擎，它在删除操作时是对行删除，不会重建表。</p>
<p><strong>6、COUNT()问题</strong></p>
<p>InnoDB存储引擎会遍历表以计算数量，效率较低。</p>
<p><strong>7、其他特点</strong></p>
<p>实现了外键、提供了多版本数据的提取。</p>
<h3 id="MyISAM主键索引和辅助索引的结构"><a href="#MyISAM主键索引和辅助索引的结构" class="headerlink" title="MyISAM主键索引和辅助索引的结构"></a>MyISAM主键索引和辅助索引的结构</h3><p><img src="pictures/分析主键索引与辅助索引的结构.png" alt="索引示例"></p>
<p><strong>1.主键索引</strong></p>
<p><img src="pictures/MyISAM主键索引.png" alt="主键索引"></p>
<p><strong>2.辅助索引</strong></p>
<p><img src="pictures/MyISAM辅助索引.png" alt="辅助索引"></p>
<h3 id="InnoDB主键索引与辅助索引饥饿否"><a href="#InnoDB主键索引与辅助索引饥饿否" class="headerlink" title="InnoDB主键索引与辅助索引饥饿否"></a>InnoDB主键索引与辅助索引饥饿否</h3><p><strong>1.主键索引</strong></p>
<p><img src="pictures/InnoDB主键索引.png" alt="主键索引"></p>
<p><strong>2.辅助索引</strong></p>
<p><img src="pictures/辅助索引.png" alt="辅助索引"></p>
<h3 id="InnoDB索引结构需要注意的点"><a href="#InnoDB索引结构需要注意的点" class="headerlink" title="InnoDB索引结构需要注意的点"></a>InnoDB索引结构需要注意的点</h3><p>1.数据文件本身就是索引文件</p>
<p>2.表数据文件本身就是按照B+Tree组织的一个索引结构文件</p>
<p>3.聚集索引叶节点包含了完整的数据记录</p>
<p>4.InnoDB表必须有主见，并且推荐使用整型自增主键</p>
<p>正如我们上面介绍InnoDB存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL会从表中选择数据不重复的列建立索引，如果没有符合的列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p>
<p><strong>那为什么推荐使用整型自增主键而不是选择UUID？</strong></p>
<p>1.UUID是字符串，比整型消耗更多的存储空间；</p>
<p>2.在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</p>
<p>3.自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句<br>。<br>4.在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</p>
<p><strong>为什么非主键索引结构叶子节点存储的是主键值？</strong></p>
<p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真是名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/mysql索引/" data-id="cjuajt8kz000cfcampnx6fhqk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>

  
    
  <h5>RECENT POSTS
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2019/04/08/动态代理/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/04/08/springAOP/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/25/dubbo/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/22/操作系统_存储器管理和虚拟存储器/">(no title)</a>
        </li>
      
        <li>
          <a href="/2019/03/21/操作系统_处理机的调度与死锁/">(no title)</a>
        </li>
      
    </ul>
  </div>
</h5>
  
    <!-- Friends Blog -->

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>